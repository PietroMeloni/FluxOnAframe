'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Bluebird = require('bluebird');

var audit = require('./install/audit.js');
var fs = require('graceful-fs');
var Installer = require('./install.js').Installer;
var lockVerify = require('lock-verify');
var log = require('npmlog');
var npa = require('npm-package-arg');
var npm = require('./npm.js');
var output = require('./utils/output.js');
var parseJson = require('json-parse-better-errors');

var readFile = Bluebird.promisify(fs.readFile);

module.exports = auditCmd;

var usage = require('./utils/usage');
auditCmd.usage = usage('audit', '\nnpm audit [--json]' + '\nnpm audit fix ' + '[--force|--package-lock-only|--dry-run|--production|--only=(dev|prod)]');

auditCmd.completion = function (opts, cb) {
  var argv = opts.conf.argv.remain;

  switch (argv[2]) {
    case 'audit':
      return cb(null, []);
    default:
      return cb(new Error(argv[2] + ' not recognized'));
  }
};

var Auditor = function (_Installer) {
  _inherits(Auditor, _Installer);

  function Auditor(where, dryrun, args, opts) {
    _classCallCheck(this, Auditor);

    var _this = _possibleConstructorReturn(this, (Auditor.__proto__ || Object.getPrototypeOf(Auditor)).call(this, where, dryrun, args, opts));

    _this.deepArgs = opts && opts.deepArgs || [];
    _this.runId = opts.runId || '';
    _this.audit = false;
    return _this;
  }

  _createClass(Auditor, [{
    key: 'loadAllDepsIntoIdealTree',
    value: function loadAllDepsIntoIdealTree(cb) {
      var _this2 = this;

      Bluebird.fromNode(function (cb) {
        return _get(Auditor.prototype.__proto__ || Object.getPrototypeOf(Auditor.prototype), 'loadAllDepsIntoIdealTree', _this2).call(_this2, cb);
      }).then(function () {
        if (_this2.deepArgs && _this2.deepArgs.length) {
          _this2.deepArgs.forEach(function (arg) {
            arg.reduce(function (acc, child, ii) {
              if (!acc) {
                // We might not always be able to find `target` through the given
                // path. If we can't we'll just ignore it.
                return;
              }
              var spec = npa(child);
              var target = acc.requires.find(function (n) {
                return n.package.name === spec.name;
              }) || acc.requires.find(function (n) {
                return audit.scrub(n.package.name, _this2.runId) === spec.name;
              });
              if (target && ii === arg.length - 1) {
                target.loaded = false;
                // This kills `hasModernMeta()` and forces a re-fetch
                target.package = {
                  name: spec.name,
                  version: spec.fetchSpec,
                  _requested: target.package._requested
                };
                delete target.fakeChild;
                var parent = target.parent;
                while (parent) {
                  parent.loaded = false;
                  parent = parent.parent;
                }
                target.requiredBy.forEach(function (par) {
                  par.loaded = false;
                  delete par.fakeChild;
                });
              }
              return target;
            }, _this2.idealTree);
          });
          return Bluebird.fromNode(function (cb) {
            return _get(Auditor.prototype.__proto__ || Object.getPrototypeOf(Auditor.prototype), 'loadAllDepsIntoIdealTree', _this2).call(_this2, cb);
          });
        }
      }).nodeify(cb);
    }

    // no top level lifecycles on audit

  }, {
    key: 'runPreinstallTopLevelLifecycles',
    value: function runPreinstallTopLevelLifecycles(cb) {
      cb();
    }
  }, {
    key: 'runPostinstallTopLevelLifecycles',
    value: function runPostinstallTopLevelLifecycles(cb) {
      cb();
    }
  }]);

  return Auditor;
}(Installer);

function maybeReadFile(name) {
  var file = npm.prefix + '/' + name;
  return readFile(file).then(function (data) {
    try {
      return parseJson(data);
    } catch (ex) {
      ex.code = 'EJSONPARSE';
      throw ex;
    }
  }).catch({ code: 'ENOENT' }, function () {
    return null;
  }).catch(function (ex) {
    ex.file = file;
    throw ex;
  });
}

function filterEnv(action) {
  var includeDev = npm.config.get('dev') || !/^prod(uction)?$/.test(npm.config.get('only')) && !npm.config.get('production') || /^dev(elopment)?$/.test(npm.config.get('only')) || /^dev(elopment)?$/.test(npm.config.get('also'));
  var includeProd = !/^dev(elopment)?$/.test(npm.config.get('only'));
  var resolves = action.resolves.filter(function (_ref) {
    var dev = _ref.dev;

    return dev && includeDev || !dev && includeProd;
  });
  if (resolves.length) {
    return Object.assign({}, action, { resolves: resolves });
  }
}

function auditCmd(args, cb) {
  if (npm.config.get('global')) {
    var err = new Error('`npm audit` does not support testing globals');
    err.code = 'EAUDITGLOBAL';
    throw err;
  }
  if (args.length && args[0] !== 'fix') {
    return cb(new Error('Invalid audit subcommand: `' + args[0] + '`\n\nUsage:\n' + auditCmd.usage));
  }
  return Bluebird.all([maybeReadFile('npm-shrinkwrap.json'), maybeReadFile('package-lock.json'), maybeReadFile('package.json')]).spread(function (shrinkwrap, lockfile, pkgJson) {
    var sw = shrinkwrap || lockfile;
    if (!pkgJson) {
      var _err = new Error('No package.json found: Cannot audit a project without a package.json');
      _err.code = 'EAUDITNOPJSON';
      throw _err;
    }
    if (!sw) {
      var _err2 = new Error('Neither npm-shrinkwrap.json nor package-lock.json found: Cannot audit a project without a lockfile');
      _err2.code = 'EAUDITNOLOCK';
      throw _err2;
    } else if (shrinkwrap && lockfile) {
      log.warn('audit', 'Both npm-shrinkwrap.json and package-lock.json exist, using npm-shrinkwrap.json.');
    }
    var requires = Object.assign({}, pkgJson && pkgJson.dependencies || {}, pkgJson && pkgJson.devDependencies || {});
    return lockVerify(npm.prefix).then(function (result) {
      if (result.status) return audit.generate(sw, requires);

      var lockFile = shrinkwrap ? 'npm-shrinkwrap.json' : 'package-lock.json';
      var err = new Error('Errors were found in your ' + lockFile + ', run  npm install  to fix them.\n    ' + result.errors.join('\n    '));
      err.code = 'ELOCKVERIFY';
      throw err;
    });
  }).then(function (auditReport) {
    return audit.submitForFullReport(auditReport);
  }).catch(function (err) {
    if (err.statusCode === 404 || err.statusCode >= 500) {
      var ne = new Error('Your configured registry (' + npm.config.get('registry') + ') does not support audit requests.');
      ne.code = 'ENOAUDIT';
      ne.wrapped = err;
      throw ne;
    }
    throw err;
  }).then(function (auditResult) {
    if (args[0] === 'fix') {
      var actions = (auditResult.actions || []).reduce(function (acc, action) {
        action = filterEnv(action);
        if (!action) {
          return acc;
        }
        if (action.isMajor) {
          acc.major.add(action.module + '@' + action.target);
          action.resolves.forEach(function (_ref2) {
            var id = _ref2.id,
                path = _ref2.path;
            return acc.majorFixes.add(id + '::' + path);
          });
        } else if (action.action === 'install') {
          acc.install.add(action.module + '@' + action.target);
          action.resolves.forEach(function (_ref3) {
            var id = _ref3.id,
                path = _ref3.path;
            return acc.installFixes.add(id + '::' + path);
          });
        } else if (action.action === 'update') {
          var name = action.module;
          var version = action.target;
          action.resolves.forEach(function (vuln) {
            acc.updateFixes.add(vuln.id + '::' + vuln.path);
            var modPath = vuln.path.split('>');
            var newPath = modPath.slice(0, modPath.indexOf(name)).concat(name + '@' + version);
            if (newPath.length === 1) {
              acc.install.add(newPath[0]);
            } else {
              acc.update.add(newPath.join('>'));
            }
          });
        } else if (action.action === 'review') {
          action.resolves.forEach(function (_ref4) {
            var id = _ref4.id,
                path = _ref4.path;
            return acc.review.add(id + '::' + path);
          });
        }
        return acc;
      }, {
        install: new Set(),
        installFixes: new Set(),
        update: new Set(),
        updateFixes: new Set(),
        major: new Set(),
        majorFixes: new Set(),
        review: new Set()
      });
      return Bluebird.try(function () {
        var installMajor = npm.config.get('force');
        var installCount = actions.install.size + (installMajor ? actions.major.size : 0) + actions.update.size;
        var vulnFixCount = new Set([].concat(_toConsumableArray(actions.installFixes), _toConsumableArray(actions.updateFixes), _toConsumableArray(installMajor ? actions.majorFixes : []))).size;
        var metavuln = auditResult.metadata.vulnerabilities;
        var total = Object.keys(metavuln).reduce(function (acc, key) {
          return acc + metavuln[key];
        }, 0);
        if (installCount) {
          log.verbose('audit', 'installing', [].concat(_toConsumableArray(actions.install), _toConsumableArray(installMajor ? actions.major : []), _toConsumableArray(actions.update)));
        }
        return Bluebird.fromNode(function (cb) {
          new Auditor(npm.prefix, !!npm.config.get('dry-run'), [].concat(_toConsumableArray(actions.install), _toConsumableArray(installMajor ? actions.major : [])), {
            runId: auditResult.runId,
            deepArgs: [].concat(_toConsumableArray(actions.update)).map(function (u) {
              return u.split('>');
            })
          }).run(cb);
        }).then(function () {
          var numScanned = auditResult.metadata.totalDependencies;
          if (!npm.config.get('json') && !npm.config.get('parseable')) {
            output('fixed ' + vulnFixCount + ' of ' + total + ' vulnerabilit' + (total === 1 ? 'y' : 'ies') + ' in ' + numScanned + ' scanned package' + (numScanned === 1 ? '' : 's'));
            if (actions.review.size) {
              output('  ' + actions.review.size + ' vulnerabilit' + (actions.review.size === 1 ? 'y' : 'ies') + ' required manual review and could not be updated');
            }
            if (actions.major.size) {
              output('  ' + actions.major.size + ' package update' + (actions.major.size === 1 ? '' : 's') + ' for ' + actions.majorFixes.size + ' vuln' + (actions.majorFixes.size === 1 ? '' : 's') + ' involved breaking changes');
              if (installMajor) {
                output('  (installed due to `--force` option)');
              } else {
                output('  (use `npm audit fix --force` to install breaking changes; or do it by hand)');
              }
            }
          }
        });
      });
    } else {
      var vulns = auditResult.metadata.vulnerabilities.low + auditResult.metadata.vulnerabilities.moderate + auditResult.metadata.vulnerabilities.high + auditResult.metadata.vulnerabilities.critical;
      if (vulns > 0) process.exitCode = 1;
      if (npm.config.get('parseable')) {
        return audit.printParseableReport(auditResult);
      } else {
        return audit.printFullReport(auditResult);
      }
    }
  }).asCallback(cb);
}
//# sourceMappingURL=audit.js.map