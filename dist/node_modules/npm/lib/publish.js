'use strict';

var BB = require('bluebird');

var cacache = require('cacache');
var createReadStream = require('graceful-fs').createReadStream;
var getPublishConfig = require('./utils/get-publish-config.js');
var lifecycle = BB.promisify(require('./utils/lifecycle.js'));
var log = require('npmlog');
var mapToRegistry = require('./utils/map-to-registry.js');
var npa = require('npm-package-arg');
var npm = require('./npm.js');
var output = require('./utils/output.js');
var pack = require('./pack');
var pacote = require('pacote');
var pacoteOpts = require('./config/pacote');
var path = require('path');
var readJson = BB.promisify(require('read-package-json'));
var readUserInfo = require('./utils/read-user-info.js');
var semver = require('semver');
var statAsync = BB.promisify(require('graceful-fs').stat);

publish.usage = 'npm publish [<tarball>|<folder>] [--tag <tag>] [--access <public|restricted>]' + "\n\nPublishes '.' if no argument supplied" + '\n\nSets tag `latest` if no --tag specified';

publish.completion = function (opts, cb) {
  // publish can complete to a folder with a package.json
  // or a tarball, or a tarball url.
  // for now, not yet implemented.
  return cb();
};

module.exports = publish;
function publish(args, isRetry, cb) {
  if (typeof cb !== 'function') {
    cb = isRetry;
    isRetry = false;
  }
  if (args.length === 0) args = ['.'];
  if (args.length !== 1) return cb(publish.usage);

  log.verbose('publish', args);

  var t = npm.config.get('tag').trim();
  if (semver.validRange(t)) {
    return cb(new Error('Tag name must not be a valid SemVer range: ' + t));
  }

  return publish_(args[0]).then(function (tarball) {
    var silent = log.level === 'silent';
    if (!silent && npm.config.get('json')) {
      output(JSON.stringify(tarball, null, 2));
    } else if (!silent) {
      output('+ ' + tarball.id);
    }
  }).nodeify(cb);
}

function publish_(arg) {
  return statAsync(arg).then(function (stat) {
    if (stat.isDirectory()) {
      return stat;
    } else {
      var err = new Error('not a directory');
      err.code = 'ENOTDIR';
      throw err;
    }
  }).then(function () {
    return publishFromDirectory(arg);
  }, function (err) {
    if (err.code !== 'ENOENT' && err.code !== 'ENOTDIR') {
      throw err;
    } else {
      return publishFromPackage(arg);
    }
  });
}

function publishFromDirectory(arg) {
  // All this readJson is because any of the given scripts might modify the
  // package.json in question, so we need to refresh after every step.
  var contents = void 0;
  return pack.prepareDirectory(arg).then(function () {
    return readJson(path.join(arg, 'package.json'));
  }).then(function (pkg) {
    return lifecycle(pkg, 'prepublishOnly', arg);
  }).then(function () {
    return readJson(path.join(arg, 'package.json'));
  }).then(function (pkg) {
    return cacache.tmp.withTmp(npm.tmp, { tmpPrefix: 'fromDir' }, function (tmpDir) {
      var target = path.join(tmpDir, 'package.tgz');
      return pack.packDirectory(pkg, arg, target, null, true).tap(function (c) {
        contents = c;
      }).then(function (c) {
        return !npm.config.get('json') && pack.logContents(c);
      }).then(function () {
        return upload(arg, pkg, false, target);
      });
    });
  }).then(function () {
    return readJson(path.join(arg, 'package.json'));
  }).tap(function (pkg) {
    return lifecycle(pkg, 'publish', arg);
  }).tap(function (pkg) {
    return lifecycle(pkg, 'postpublish', arg);
  }).then(function () {
    return contents;
  });
}

function publishFromPackage(arg) {
  return cacache.tmp.withTmp(npm.tmp, { tmpPrefix: 'fromPackage' }, function (tmp) {
    var extracted = path.join(tmp, 'package');
    var target = path.join(tmp, 'package.json');
    var opts = pacoteOpts();
    return pacote.tarball.toFile(arg, target, opts).then(function () {
      return pacote.extract(arg, extracted, opts);
    }).then(function () {
      return readJson(path.join(extracted, 'package.json'));
    }).then(function (pkg) {
      return BB.resolve(pack.getContents(pkg, target)).tap(function (c) {
        return !npm.config.get('json') && pack.logContents(c);
      }).tap(function () {
        return upload(arg, pkg, false, target);
      });
    });
  });
}

function upload(arg, pkg, isRetry, cached) {
  if (!pkg) {
    return BB.reject(new Error('no package.json file found'));
  }
  if (pkg.private) {
    return BB.reject(new Error('This package has been marked as private\n' + "Remove the 'private' field from the package.json to publish it."));
  }
  var mappedConfig = getPublishConfig(pkg.publishConfig, npm.config, npm.registry);
  var config = mappedConfig.config;
  var registry = mappedConfig.client;

  pkg._npmVersion = npm.version;
  pkg._nodeVersion = process.versions.node;

  delete pkg.modules;

  return BB.fromNode(function (cb) {
    mapToRegistry(pkg.name, config, function (err, registryURI, auth, registryBase) {
      if (err) {
        return cb(err);
      }
      cb(null, [registryURI, auth, registryBase]);
    });
  }).spread(function (registryURI, auth, registryBase) {
    // we just want the base registry URL in this case
    log.verbose('publish', 'registryBase', registryBase);
    log.silly('publish', 'uploading', cached);

    pkg._npmUser = {
      name: auth.username,
      email: auth.email
    };

    var params = {
      metadata: pkg,
      body: !npm.config.get('dry-run') && createReadStream(cached),
      auth: auth

      // registry-frontdoor cares about the access level, which is only
      // configurable for scoped packages
    };if (config.get('access')) {
      if (!npa(pkg.name).scope && config.get('access') === 'restricted') {
        throw new Error("Can't restrict access to unscoped packages.");
      }

      params.access = config.get('access');
    }

    if (npm.config.get('dry-run')) {
      log.verbose('publish', '--dry-run mode enabled. Skipping upload.');
      return BB.resolve();
    }

    log.showProgress('publish:' + pkg._id);
    return BB.fromNode(function (cb) {
      registry.publish(registryBase, params, cb);
    }).catch(function (err) {
      if (err.code === 'EPUBLISHCONFLICT' && npm.config.get('force') && !isRetry) {
        log.warn('publish', 'Forced publish over ' + pkg._id);
        return BB.fromNode(function (cb) {
          npm.commands.unpublish([pkg._id], cb);
        }).finally(function () {
          // ignore errors.  Use the force.  Reach out with your feelings.
          return upload(arg, pkg, true, cached).catch(function () {
            // but if it fails again, then report the first error.
            throw err;
          });
        });
      } else {
        throw err;
      }
    });
  }).catch(function (err) {
    if (err.code !== 'EOTP' && !(err.code === 'E401' && /one-time pass/.test(err.message))) throw err;
    // we prompt on stdout and read answers from stdin, so they need to be ttys.
    if (!process.stdin.isTTY || !process.stdout.isTTY) throw err;
    return readUserInfo.otp().then(function (otp) {
      npm.config.set('otp', otp);
      return upload(arg, pkg, isRetry, cached);
    });
  });
}
//# sourceMappingURL=publish.js.map