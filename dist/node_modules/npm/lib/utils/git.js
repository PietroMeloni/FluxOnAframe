'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var BB = require('bluebird');

var exec = require('child_process').execFile;
var spawn = require('./spawn');
var npm = require('../npm.js');
var which = require('which');
var git = npm.config.get('git');
var assert = require('assert');
var log = require('npmlog');
var noProgressTillDone = require('./no-progress-while-running.js').tillDone;

exports.spawn = spawnGit;
exports.exec = BB.promisify(execGit);
exports.chainableExec = chainableExec;
exports.whichAndExec = whichAndExec;

function prefixGitArgs() {
  return process.platform === 'win32' ? ['-c', 'core.longpaths=true'] : [];
}

function execGit(args, options, cb) {
  log.info('git', args);
  var fullArgs = prefixGitArgs().concat(args || []);
  return exec(git, fullArgs, options, noProgressTillDone(cb));
}

function spawnGit(args, options) {
  log.info('git', args);
  return spawn(git, prefixGitArgs().concat(args || []), options);
}

function chainableExec() {
  var args = Array.prototype.slice.call(arguments);
  return [execGit].concat(args);
}

function whichAndExec(args, options, cb) {
  assert.equal(typeof cb === 'undefined' ? 'undefined' : _typeof(cb), 'function', 'no callback provided');
  // check for git
  which(git, function (err) {
    if (err) {
      err.code = 'ENOGIT';
      return cb(err);
    }

    execGit(args, options, cb);
  });
}
//# sourceMappingURL=git.js.map