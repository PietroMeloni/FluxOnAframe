'use strict';

var _templateObject = _taggedTemplateLiteral(['enable-2fa disable-2fa get set'], ['enable-2fa disable-2fa get set']),
    _templateObject2 = _taggedTemplateLiteral(['auth-and-writes auth-only'], ['auth-and-writes auth-only']),
    _templateObject3 = _taggedTemplateLiteral(['\n  name email ', ' fullname homepage\n  freenode twitter github created updated'], ['\n  name email ', ' fullname homepage\n  freenode twitter github created updated']),
    _templateObject4 = _taggedTemplateLiteral(['\n  email password fullname homepage freenode twitter github'], ['\n  email password fullname homepage freenode twitter github']);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var profile = require('npm-profile');
var npm = require('./npm.js');
var log = require('npmlog');
var output = require('./utils/output.js');
var qw = require('qw');
var Table = require('cli-table3');
var ansistyles = require('ansistyles');
var Bluebird = require('bluebird');
var readUserInfo = require('./utils/read-user-info.js');
var qrcodeTerminal = require('qrcode-terminal');
var url = require('url');
var queryString = require('query-string');
var pulseTillDone = require('./utils/pulse-till-done.js');
var inspect = require('util').inspect;

module.exports = profileCmd;

profileCmd.usage = 'npm profile enable-2fa [auth-only|auth-and-writes]\n' + 'npm profile disable-2fa\n' + 'npm profile get [<key>]\n' + 'npm profile set <key> <value>';

profileCmd.subcommands = qw(_templateObject);

profileCmd.completion = function (opts, cb) {
  var argv = opts.conf.argv.remain;
  switch (argv[2]) {
    case 'enable-2fa':
    case 'enable-tfa':
      if (argv.length === 3) {
        return cb(null, qw(_templateObject2));
      } else {
        return cb(null, []);
      }
    case 'disable-2fa':
    case 'disable-tfa':
    case 'get':
    case 'set':
      return cb(null, []);
    default:
      return cb(new Error(argv[2] + ' not recognized'));
  }
};

function withCb(prom, cb) {
  prom.then(function (value) {
    return cb(null, value);
  }, cb);
}

function profileCmd(args, cb) {
  if (args.length === 0) return cb(new Error(profileCmd.usage));
  log.gauge.show('profile');
  switch (args[0]) {
    case 'enable-2fa':
    case 'enable-tfa':
    case 'enable2fa':
    case 'enabletfa':
      withCb(enable2fa(args.slice(1)), cb);
      break;
    case 'disable-2fa':
    case 'disable-tfa':
    case 'disable2fa':
    case 'disabletfa':
      withCb(disable2fa(), cb);
      break;
    case 'get':
      withCb(get(args.slice(1)), cb);
      break;
    case 'set':
      withCb(set(args.slice(1)), cb);
      break;
    default:
      cb(new Error('Unknown profile command: ' + args[0]));
  }
}

function config() {
  var conf = {
    json: npm.config.get('json'),
    parseable: npm.config.get('parseable'),
    registry: npm.config.get('registry'),
    otp: npm.config.get('otp')
  };
  var creds = npm.config.getCredentialsByURI(conf.registry);
  if (creds.token) {
    conf.auth = { token: creds.token };
  } else if (creds.username) {
    conf.auth = { basic: { username: creds.username, password: creds.password } };
  } else if (creds.auth) {
    var auth = Buffer.from(creds.auth, 'base64').toString().split(':', 2);
    conf.auth = { basic: { username: auth[0], password: auth[1] } };
  } else {
    conf.auth = {};
  }

  if (conf.otp) conf.auth.otp = conf.otp;
  return conf;
}

var knownProfileKeys = qw(_templateObject3, 'two-factor auth');

function get(args) {
  var tfa = 'two-factor auth';
  var conf = config();
  return pulseTillDone.withPromise(profile.get(conf)).then(function (info) {
    if (!info.cidr_whitelist) delete info.cidr_whitelist;
    if (conf.json) {
      output(JSON.stringify(info, null, 2));
      return;
    }
    var cleaned = {};
    knownProfileKeys.forEach(function (k) {
      cleaned[k] = info[k] || '';
    });
    Object.keys(info).filter(function (k) {
      return !(k in cleaned);
    }).forEach(function (k) {
      cleaned[k] = info[k] || '';
    });
    delete cleaned.tfa;
    delete cleaned.email_verified;
    cleaned['email'] += info.email_verified ? ' (verified)' : '(unverified)';
    if (info.tfa && !info.tfa.pending) {
      cleaned[tfa] = info.tfa.mode;
    } else {
      cleaned[tfa] = 'disabled';
    }
    if (args.length) {
      var values = args // comma or space separated â†“
      .join(',').split(/,/).map(function (arg) {
        return arg.trim();
      }).filter(function (arg) {
        return arg !== '';
      }).map(function (arg) {
        return cleaned[arg];
      }).join('\t');
      output(values);
    } else {
      if (conf.parseable) {
        Object.keys(info).forEach(function (key) {
          if (key === 'tfa') {
            output(key + '\t' + cleaned[tfa]);
          } else {
            output(key + '\t' + info[key]);
          }
        });
      } else {
        var table = new Table();
        Object.keys(cleaned).forEach(function (k) {
          return table.push(_defineProperty({}, ansistyles.bright(k), cleaned[k]));
        });
        output(table.toString());
      }
    }
  });
}

var writableProfileKeys = qw(_templateObject4);

function set(args) {
  var conf = config();
  var prop = (args[0] || '').toLowerCase().trim();
  var value = args.length > 1 ? args.slice(1).join(' ') : null;
  if (prop !== 'password' && value === null) {
    return Promise.reject(Error('npm profile set <prop> <value>'));
  }
  if (prop === 'password' && value !== null) {
    return Promise.reject(Error('npm profile set password\n' + 'Do not include your current or new passwords on the command line.'));
  }
  if (writableProfileKeys.indexOf(prop) === -1) {
    return Promise.reject(Error('"' + prop + '" is not a property we can set. Valid properties are: ' + writableProfileKeys.join(', ')));
  }
  return Bluebird.try(function () {
    if (prop === 'password') {
      return readUserInfo.password('Current password: ').then(function (current) {
        return readPasswords().then(function (newpassword) {
          value = { old: current, new: newpassword };
        });
      });
    } else if (prop === 'email') {
      return readUserInfo.password('Password: ').then(function (current) {
        return { password: current, email: value };
      });
    }
    function readPasswords() {
      return readUserInfo.password('New password: ').then(function (password1) {
        return readUserInfo.password('       Again:     ').then(function (password2) {
          if (password1 !== password2) {
            log.warn('profile', 'Passwords do not match, please try again.');
            return readPasswords();
          }
          return password1;
        });
      });
    }
  }).then(function () {
    // FIXME: Work around to not clear everything other than what we're setting
    return pulseTillDone.withPromise(profile.get(conf).then(function (user) {
      var newUser = {};
      writableProfileKeys.forEach(function (k) {
        newUser[k] = user[k];
      });
      newUser[prop] = value;
      return profile.set(newUser, conf).catch(function (err) {
        if (err.code !== 'EOTP') throw err;
        return readUserInfo.otp('Enter OTP:  ').then(function (otp) {
          conf.auth.otp = otp;
          return profile.set(newUser, conf);
        });
      }).then(function (result) {
        if (conf.json) {
          output(JSON.stringify(_defineProperty({}, prop, result[prop]), null, 2));
        } else if (conf.parseable) {
          output(prop + '\t' + result[prop]);
        } else if (result[prop] != null) {
          output('Set', prop, 'to', result[prop]);
        } else {
          output('Set', prop);
        }
      });
    }));
  });
}

function enable2fa(args) {
  if (args.length > 1) {
    return Promise.reject(new Error('npm profile enable-2fa [auth-and-writes|auth-only]'));
  }
  var mode = args[0] || 'auth-and-writes';
  if (mode !== 'auth-only' && mode !== 'auth-and-writes') {
    return Promise.reject(new Error('Invalid two-factor authentication mode "' + mode + '".\n' + 'Valid modes are:\n' + '  auth-only - Require two-factor authentication only when logging in\n' + '  auth-and-writes - Require two-factor authentication when logging in AND when publishing'));
  }
  var conf = config();
  if (conf.json || conf.parseable) {
    return Promise.reject(new Error('Enabling two-factor authentication is an interactive operation and ' + (conf.json ? 'JSON' : 'parseable') + ' output mode is not available'));
  }

  var info = {
    tfa: {
      mode: mode
    }
  };

  return Bluebird.try(function () {
    // if they're using legacy auth currently then we have to update them to a
    // bearer token before continuing.
    if (conf.auth.basic) {
      log.info('profile', 'Updating authentication to bearer token');
      return profile.login(conf.auth.basic.username, conf.auth.basic.password, conf).then(function (result) {
        if (!result.token) throw new Error('Your registry ' + conf.registry + 'does not seem to support bearer tokens. Bearer tokens are required for two-factor authentication');
        npm.config.setCredentialsByURI(conf.registry, { token: result.token });
        return Bluebird.fromNode(function (cb) {
          return npm.config.save('user', cb);
        });
      });
    }
  }).then(function () {
    log.notice('profile', 'Enabling two factor authentication for ' + mode);
    return readUserInfo.password();
  }).then(function (password) {
    info.tfa.password = password;
    log.info('profile', 'Determine if tfa is pending');
    return pulseTillDone.withPromise(profile.get(conf)).then(function (info) {
      if (!info.tfa) return;
      if (info.tfa.pending) {
        log.info('profile', 'Resetting two-factor authentication');
        return pulseTillDone.withPromise(profile.set({ tfa: { password: password, mode: 'disable' } }, conf));
      } else {
        if (conf.auth.otp) return;
        return readUserInfo.otp('Enter OTP:  ').then(function (otp) {
          conf.auth.otp = otp;
        });
      }
    });
  }).then(function () {
    log.info('profile', 'Setting two-factor authentication to ' + mode);
    return pulseTillDone.withPromise(profile.set(info, conf));
  }).then(function (challenge) {
    if (challenge.tfa === null) {
      output('Two factor authentication mode changed to: ' + mode);
      return;
    }
    if (typeof challenge.tfa !== 'string' || !/^otpauth:[/][/]/.test(challenge.tfa)) {
      throw new Error('Unknown error enabling two-factor authentication. Expected otpauth URL, got: ' + inspect(challenge.tfa));
    }
    var otpauth = url.parse(challenge.tfa);
    var opts = queryString.parse(otpauth.query);
    return qrcode(challenge.tfa).then(function (code) {
      output('Scan into your authenticator app:\n' + code + '\n Or enter code:', opts.secret);
    }).then(function (code) {
      return readUserInfo.otp('And an OTP code from your authenticator: ');
    }).then(function (otp1) {
      log.info('profile', 'Finalizing two-factor authentication');
      return profile.set({ tfa: [otp1] }, conf);
    }).then(function (result) {
      output('2FA successfully enabled. Below are your recovery codes, please print these out.');
      output('You will need these to recover access to your account if you lose your authentication device.');
      result.tfa.forEach(function (c) {
        return output('\t' + c);
      });
    });
  });
}

function disable2fa(args) {
  var conf = config();
  return pulseTillDone.withPromise(profile.get(conf)).then(function (info) {
    if (!info.tfa || info.tfa.pending) {
      output('Two factor authentication not enabled.');
      return;
    }
    return readUserInfo.password().then(function (password) {
      return Bluebird.try(function () {
        if (conf.auth.otp) return;
        return readUserInfo.otp('Enter one-time password from your authenticator: ').then(function (otp) {
          conf.auth.otp = otp;
        });
      }).then(function () {
        log.info('profile', 'disabling tfa');
        return pulseTillDone.withPromise(profile.set({ tfa: { password: password, mode: 'disable' } }, conf)).then(function () {
          if (conf.json) {
            output(JSON.stringify({ tfa: false }, null, 2));
          } else if (conf.parseable) {
            output('tfa\tfalse');
          } else {
            output('Two factor authentication disabled.');
          }
        });
      });
    });
  });
}

function qrcode(url) {
  return new Promise(function (resolve) {
    return qrcodeTerminal.generate(url, resolve);
  });
}
//# sourceMappingURL=profile.js.map