'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var deprCheck = require('./utils/depr-check');
var path = require('path');
var log = require('npmlog');
var readPackageTree = require('read-package-tree');
var rimraf = require('rimraf');
var validate = require('aproba');
var npa = require('npm-package-arg');
var npm = require('./npm');
var npmlog = require('npmlog');
var limit = require('call-limit');
var tempFilename = require('./utils/temp-filename');
var pacote = require('pacote');
var pacoteOpts = void 0;
var isWindows = require('./utils/is-windows.js');

function andLogAndFinish(spec, tracker, done) {
  validate('SOF|SZF|OOF|OZF', [spec, tracker, done]);
  return function (er, pkg) {
    if (er) {
      log.silly('fetchPackageMetaData', 'error for ' + String(spec), er.message);
      if (tracker) tracker.finish();
    }
    return done(er, pkg);
  };
}

var CACHE = require('lru-cache')({
  max: 300 * 1024 * 1024,
  length: function length(p) {
    return p._contentLength;
  }
});

module.exports = limit(fetchPackageMetadata, npm.limit.fetch);
function fetchPackageMetadata(spec, where, opts, done) {
  validate('SSOF|SSFZ|OSOF|OSFZ', [spec, where, opts, done]);

  if (!done) {
    done = opts;
    opts = {};
  }
  var tracker = opts.tracker;
  var logAndFinish = andLogAndFinish(spec, tracker, done);

  if ((typeof spec === 'undefined' ? 'undefined' : _typeof(spec)) === 'object') {
    var dep = spec;
  } else {
    dep = npa(spec);
  }
  if (!isWindows && dep.type === 'directory' && /^[a-zA-Z]:/.test(dep.fetchSpec)) {
    var err = new Error('Can\'t install from windows path on a non-windows system: ' + dep.fetchSpec.replace(/[/]/g, '\\'));
    err.code = 'EWINDOWSPATH';
    return logAndFinish(err);
  }
  if (!pacoteOpts) {
    pacoteOpts = require('./config/pacote');
  }
  pacote.manifest(dep, pacoteOpts({
    annotate: true,
    fullMetadata: opts.fullMetadata,
    log: tracker || npmlog,
    memoize: CACHE,
    where: where
  })).then(function (pkg) {
    return logAndFinish(null, deprCheck(pkg));
  }, function (err) {
    if (dep.type !== 'directory') return logAndFinish(err);
    if (err.code === 'ENOTDIR') {
      var enolocal = new Error('Could not install "' + path.relative(process.cwd(), dep.fetchSpec) + '" as it is not a directory and is not a file with a name ending in .tgz, .tar.gz or .tar');
      enolocal.code = 'ENOLOCAL';
      if (err.stack) enolocal.stack = err.stack;
      return logAndFinish(enolocal);
    } else if (err.code === 'ENOPACKAGEJSON') {
      var enopackage = new Error('Could not install from "' + path.relative(process.cwd(), dep.fetchSpec) + '" as it does not contain a package.json file.');
      enopackage.code = 'ENOLOCAL';
      if (err.stack) enopackage.stack = err.stack;
      return logAndFinish(enopackage);
    } else {
      return logAndFinish(err);
    }
  });
}

module.exports.addBundled = addBundled;
function addBundled(pkg, next) {
  validate('OF', arguments);
  if (!pacoteOpts) {
    pacoteOpts = require('./config/pacote');
  }
  if (pkg._bundled !== undefined) return next(null, pkg);

  if (!pkg.bundleDependencies && pkg._requested.type !== 'directory') return next(null, pkg);
  var requested = pkg._requested || npa(pkg._from);
  if (requested.type === 'directory') {
    pkg._bundled = null;
    return readPackageTree(pkg._requested.fetchSpec, function (er, tree) {
      if (tree) pkg._bundled = tree.children;
      return next(null, pkg);
    });
  }
  pkg._bundled = null;
  var target = tempFilename('unpack');
  var opts = pacoteOpts({ integrity: pkg._integrity });
  pacote.extract(pkg._resolved || pkg._requested || npa.resolve(pkg.name, pkg.version), target, opts).then(function () {
    log.silly('addBundled', 'read tarball');
    readPackageTree(target, function (err, tree) {
      if (err) {
        return next(err);
      }
      log.silly('cleanup', 'remove extracted module');
      rimraf(target, function () {
        if (tree) {
          pkg._bundled = tree.children;
        }
        next(null, pkg);
      });
    });
  }, next);
}
//# sourceMappingURL=fetch-package-metadata.js.map