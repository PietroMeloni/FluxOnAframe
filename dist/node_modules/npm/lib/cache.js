'use strict';
/* eslint-disable standard/no-callback-literal */

var BB = require('bluebird');

var assert = require('assert');
var cacache = require('cacache');
var finished = BB.promisify(require('mississippi').finished);
var log = require('npmlog');
var npa = require('npm-package-arg');
var npm = require('./npm.js');
var output = require('./utils/output.js');
var pacote = require('pacote');
var pacoteOpts = require('./config/pacote');
var path = require('path');
var rm = BB.promisify(require('./utils/gently-rm.js'));
var unbuild = BB.promisify(npm.commands.unbuild);

cache.usage = 'npm cache add <tarball file>' + '\nnpm cache add <folder>' + '\nnpm cache add <tarball url>' + '\nnpm cache add <git url>' + '\nnpm cache add <name>@<version>' + '\nnpm cache clean' + '\nnpm cache verify';

cache.completion = function (opts, cb) {
  var argv = opts.conf.argv.remain;
  if (argv.length === 2) {
    return cb(null, ['add', 'clean']);
  }

  // TODO - eventually...
  switch (argv[2]) {
    case 'clean':
    case 'add':
      return cb(null, []);
  }
};

exports = module.exports = cache;
function cache(args, cb) {
  var cmd = args.shift();
  var result = void 0;
  switch (cmd) {
    case 'rm':case 'clear':case 'clean':
      result = clean(args);
      break;
    case 'add':
      result = add(args, npm.prefix);
      break;
    case 'verify':case 'check':
      result = verify();
      break;
    default:
      return cb('Usage: ' + cache.usage);
  }
  if (!result || !result.then) {
    throw new Error('npm cache ' + cmd + ' handler did not return a Promise');
  }
  result.then(function () {
    return cb();
  }, cb);
}

// npm cache clean [pkg]*
cache.clean = clean;
function clean(args) {
  if (!args) args = [];
  if (args.length) {
    return BB.reject(new Error('npm cache clear does not accept arguments'));
  }
  var cachePath = path.join(npm.cache, '_cacache');
  if (!npm.config.get('force')) {
    return BB.reject(new Error("As of npm@5, the npm cache self-heals from corruption issues and data extracted from the cache is guaranteed to be valid. If you want to make sure everything is consistent, use 'npm cache verify' instead. On the other hand, if you're debugging an issue with the installer, you can use `npm install --cache /tmp/empty-cache` to use a temporary cache instead of nuking the actual one.\n\nIf you're sure you want to delete the entire cache, rerun this command with --force."));
  }
  // TODO - remove specific packages or package versions
  return rm(cachePath);
}

// npm cache add <tarball-url>
// npm cache add <pkg> <ver>
// npm cache add <tarball>
// npm cache add <folder>
cache.add = function (pkg, ver, where, scrub) {
  assert(typeof pkg === 'string', 'must include name of package to install');
  if (scrub) {
    return clean([]).then(function () {
      return add([pkg, ver], where);
    });
  }
  return add([pkg, ver], where);
};

function add(args, where) {
  var usage = 'Usage:\n' + '    npm cache add <tarball-url>\n' + '    npm cache add <pkg>@<ver>\n' + '    npm cache add <tarball>\n' + '    npm cache add <folder>\n';
  var spec;
  log.silly('cache add', 'args', args);
  if (args[1] === undefined) args[1] = null;
  // at this point the args length must ==2
  if (args[1] !== null) {
    spec = args[0] + '@' + args[1];
  } else if (args.length === 2) {
    spec = args[0];
  }
  log.verbose('cache add', 'spec', spec);
  if (!spec) return BB.reject(new Error(usage));
  log.silly('cache add', 'parsed spec', spec);
  return finished(pacote.tarball.stream(spec, pacoteOpts({ where: where })).resume());
}

cache.verify = verify;
function verify() {
  var cache = path.join(npm.config.get('cache'), '_cacache');
  var prefix = cache;
  if (prefix.indexOf(process.env.HOME) === 0) {
    prefix = '~' + prefix.substr(process.env.HOME.length);
  }
  return cacache.verify(cache).then(function (stats) {
    output('Cache verified and compressed (' + prefix + '):');
    output('Content verified: ' + stats.verifiedContent + ' (' + stats.keptSize + ' bytes)');
    stats.badContentCount && output('Corrupted content removed: ' + stats.badContentCount);
    stats.reclaimedCount && output('Content garbage-collected: ' + stats.reclaimedCount + ' (' + stats.reclaimedSize + ' bytes)');
    stats.missingContent && output('Missing content: ' + stats.missingContent);
    output('Index entries: ' + stats.totalEntries);
    output('Finished in ' + stats.runTime.total / 1000 + 's');
  });
}

cache.unpack = unpack;
function unpack(pkg, ver, unpackTarget, dmode, fmode, uid, gid) {
  return unbuild([unpackTarget], true).then(function () {
    var opts = pacoteOpts({ dmode: dmode, fmode: fmode, uid: uid, gid: gid, offline: true });
    return pacote.extract(npa.resolve(pkg, ver), unpackTarget, opts);
  });
}
//# sourceMappingURL=cache.js.map