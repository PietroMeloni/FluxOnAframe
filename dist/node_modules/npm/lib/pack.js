'use strict';

// npm pack <pkg>
// Packs the specified package into a .tgz file, which can then
// be installed.

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var BB = require('bluebird');

var byteSize = require('byte-size');
var cacache = require('cacache');
var columnify = require('columnify');
var cp = require('child_process');
var deprCheck = require('./utils/depr-check');
var fpm = require('./fetch-package-metadata');
var fs = require('graceful-fs');
var install = require('./install');
var lifecycle = BB.promisify(require('./utils/lifecycle'));
var log = require('npmlog');
var move = require('move-concurrently');
var npm = require('./npm');
var output = require('./utils/output');
var pacote = require('pacote');
var pacoteOpts = require('./config/pacote');
var path = require('path');
var PassThrough = require('stream').PassThrough;
var pathIsInside = require('path-is-inside');
var pipe = BB.promisify(require('mississippi').pipe);
var prepublishWarning = require('./utils/warn-deprecated')('prepublish-on-install');
var pinflight = require('promise-inflight');
var readJson = BB.promisify(require('read-package-json'));
var tar = require('tar');
var packlist = require('npm-packlist');
var ssri = require('ssri');

pack.usage = 'npm pack [[<@scope>/]<pkg>...]';

// if it can be installed, it can be packed.
pack.completion = install.completion;

module.exports = pack;
function pack(args, silent, cb) {
  var cwd = process.cwd();
  if (typeof cb !== 'function') {
    cb = silent;
    silent = false;
  }

  if (args.length === 0) args = ['.'];

  BB.all(args.map(function (arg) {
    return pack_(arg, cwd);
  })).then(function (tarballs) {
    if (!silent && npm.config.get('json')) {
      output(JSON.stringify(tarballs, null, 2));
    } else if (!silent) {
      tarballs.forEach(logContents);
      output(tarballs.map(function (f) {
        return path.relative(cwd, f.filename);
      }).join('\n'));
    }
    return tarballs;
  }).nodeify(cb);
}

function pack_(pkg, dir) {
  return BB.fromNode(function (cb) {
    return fpm(pkg, dir, cb);
  }).then(function (mani) {
    var name = mani.name[0] === '@'
    // scoped packages get special treatment
    ? mani.name.substr(1).replace(/\//g, '-') : mani.name;
    var target = name + '-' + mani.version + '.tgz';
    return pinflight(target, function () {
      if (mani._requested.type === 'directory') {
        return cacache.tmp.withTmp(npm.tmp, { tmpPrefix: 'packing' }, function (tmp) {
          var tmpTarget = path.join(tmp, path.basename(target));
          return prepareDirectory(mani._resolved).then(function () {
            return packDirectory(mani, mani._resolved, tmpTarget, target, true);
          }).tap(function () {
            if (npm.config.get('dry-run')) {
              log.verbose('pack', '--dry-run mode enabled. Skipping write.');
            } else {
              return move(tmpTarget, target, { Promise: BB, fs: fs });
            }
          });
        });
      } else if (npm.config.get('dry-run')) {
        log.verbose('pack', '--dry-run mode enabled. Skipping write.');
        return cacache.tmp.withTmp(npm.tmp, { tmpPrefix: 'packing' }, function (tmp) {
          var tmpTarget = path.join(tmp, path.basename(target));
          return packFromPackage(pkg, tmpTarget, target);
        });
      } else {
        return packFromPackage(pkg, target, target);
      }
    });
  });
}

function packFromPackage(arg, target, filename) {
  var opts = pacoteOpts();
  return pacote.tarball.toFile(arg, target, pacoteOpts()).then(function () {
    return cacache.tmp.withTmp(npm.tmp, { tmpPrefix: 'unpacking' }, function (tmp) {
      var tmpTarget = path.join(tmp, filename);
      return pacote.extract(arg, tmpTarget, opts).then(function () {
        return readJson(path.join(tmpTarget, 'package.json'));
      });
    });
  }).then(function (pkg) {
    return getContents(pkg, target, filename);
  });
}

module.exports.prepareDirectory = prepareDirectory;
function prepareDirectory(dir) {
  return readJson(path.join(dir, 'package.json')).then(function (pkg) {
    if (!pkg.name) {
      throw new Error('package.json requires a "name" field');
    }
    if (!pkg.version) {
      throw new Error('package.json requires a valid "version" field');
    }
    if (!pathIsInside(dir, npm.tmp)) {
      if (pkg.scripts && pkg.scripts.prepublish) {
        prepublishWarning(['As of npm@5, `prepublish` scripts are deprecated.', 'Use `prepare` for build steps and `prepublishOnly` for upload-only.', 'See the deprecation note in `npm help scripts` for more information.']);
      }
      if (npm.config.get('ignore-prepublish')) {
        return lifecycle(pkg, 'prepare', dir).then(function () {
          return pkg;
        });
      } else {
        return lifecycle(pkg, 'prepublish', dir).then(function () {
          return lifecycle(pkg, 'prepare', dir);
        }).then(function () {
          return pkg;
        });
      }
    }
    return pkg;
  });
}

module.exports.packDirectory = packDirectory;
function packDirectory(mani, dir, target, filename, logIt) {
  deprCheck(mani);
  return readJson(path.join(dir, 'package.json')).then(function (pkg) {
    return lifecycle(pkg, 'prepack', dir);
  }).then(function () {
    return readJson(path.join(dir, 'package.json'));
  }).then(function (pkg) {
    return cacache.tmp.withTmp(npm.tmp, { tmpPrefix: 'packing' }, function (tmp) {
      var tmpTarget = path.join(tmp, path.basename(target));

      var tarOpt = {
        file: tmpTarget,
        cwd: dir,
        prefix: 'package/',
        portable: true,
        // Provide a specific date in the 1980s for the benefit of zip,
        // which is confounded by files dated at the Unix epoch 0.
        mtime: new Date('1985-10-26T08:15:00.000Z'),
        gzip: true
      };

      return BB.resolve(packlist({ path: dir }))
      // NOTE: node-tar does some Magic Stuff depending on prefixes for files
      //       specifically with @ signs, so we just neutralize that one
      //       and any such future "features" by prepending `./`
      .then(function (files) {
        return tar.create(tarOpt, files.map(function (f) {
          return './' + f;
        }));
      }).then(function () {
        return getContents(pkg, tmpTarget, filename, logIt);
      })
      // thread the content info through
      .tap(function () {
        return move(tmpTarget, target, { Promise: BB, fs: fs });
      }).tap(function () {
        return lifecycle(pkg, 'postpack', dir);
      });
    });
  });
}

module.exports.logContents = logContents;
function logContents(tarball) {
  log.notice('');
  log.notice('', (npm.config.get('unicode') ? 'ðŸ“¦ ' : 'package:') + ' ' + tarball.name + '@' + tarball.version);
  log.notice('=== Tarball Contents ===');
  if (tarball.files.length) {
    log.notice('', columnify(tarball.files.map(function (f) {
      var bytes = byteSize(f.size);
      return { path: f.path, size: '' + bytes.value + bytes.unit };
    }), {
      include: ['size', 'path'],
      showHeaders: false
    }));
  }
  if (tarball.bundled.length) {
    log.notice('=== Bundled Dependencies ===');
    tarball.bundled.forEach(function (name) {
      return log.notice('', name);
    });
  }
  log.notice('=== Tarball Details ===');
  log.notice('', columnify([{ name: 'name:', value: tarball.name }, { name: 'version:', value: tarball.version }, tarball.filename && { name: 'filename:', value: tarball.filename }, { name: 'package size:', value: byteSize(tarball.size) }, { name: 'unpacked size:', value: byteSize(tarball.unpackedSize) }, { name: 'shasum:', value: tarball.shasum }, {
    name: 'integrity:',
    value: tarball.integrity.toString().substr(0, 20) + '[...]' + tarball.integrity.toString().substr(80) }, tarball.bundled.length && { name: 'bundled deps:', value: tarball.bundled.length }, tarball.bundled.length && { name: 'bundled files:', value: tarball.entryCount - tarball.files.length }, tarball.bundled.length && { name: 'own files:', value: tarball.files.length }, { name: 'total files:', value: tarball.entryCount }].filter(function (x) {
    return x;
  }), {
    include: ['name', 'value'],
    showHeaders: false
  }));
  log.notice('', '');
}

module.exports.getContents = getContents;
function getContents(pkg, target, filename, silent) {
  var bundledWanted = new Set(pkg.bundleDependencies || pkg.bundledDependencies || []);
  var files = [];
  var bundled = new Set();
  var totalEntries = 0;
  var totalEntrySize = 0;
  return tar.t({
    file: target,
    onentry: function onentry(entry) {
      totalEntries++;
      totalEntrySize += entry.size;
      var p = entry.path;
      if (p.startsWith('package/node_modules/')) {
        var name = p.match(/^package\/node_modules\/((?:@[^/]+\/)?[^/]+)/)[1];
        if (bundledWanted.has(name)) {
          bundled.add(name);
        }
      } else {
        files.push({
          path: entry.path.replace(/^package\//, ''),
          size: entry.size,
          mode: entry.mode
        });
      }
    },

    strip: 1
  }).then(function () {
    return BB.all([BB.fromNode(function (cb) {
      return fs.stat(target, cb);
    }), ssri.fromStream(fs.createReadStream(target), {
      algorithms: ['sha1', 'sha512']
    })]);
  }).then(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        stat = _ref2[0],
        integrity = _ref2[1];

    var shasum = integrity['sha1'][0].hexDigest();
    return {
      id: pkg._id,
      name: pkg.name,
      version: pkg.version,
      from: pkg._from,
      size: stat.size,
      unpackedSize: totalEntrySize,
      shasum: shasum,
      integrity: ssri.parse(integrity['sha512'][0]),
      filename: filename,
      files: files,
      entryCount: totalEntries,
      bundled: Array.from(bundled)
    };
  });
}

var PASSTHROUGH_OPTS = ['always-auth', 'auth-type', 'ca', 'cafile', 'cert', 'git', 'local-address', 'maxsockets', 'offline', 'prefer-offline', 'prefer-online', 'proxy', 'https-proxy', 'registry', 'send-metrics', 'sso-poll-frequency', 'sso-type', 'strict-ssl'];

module.exports.packGitDep = packGitDep;
function packGitDep(manifest, dir) {
  var stream = new PassThrough();
  readJson(path.join(dir, 'package.json')).then(function (pkg) {
    if (pkg.scripts && pkg.scripts.prepare) {
      log.verbose('prepareGitDep', manifest._spec + ': installing devDeps and running prepare script.');
      var cliArgs = PASSTHROUGH_OPTS.reduce(function (acc, opt) {
        if (npm.config.get(opt, 'cli') != null) {
          acc.push('--' + opt + '=' + npm.config.get(opt));
        }
        return acc;
      }, []);
      var child = cp.spawn(process.env.NODE || process.execPath, [require.resolve('../bin/npm-cli.js'), 'install', '--dev', '--prod', '--ignore-prepublish', '--no-progress', '--no-save'].concat(cliArgs), {
        cwd: dir,
        env: process.env
      });
      var errData = [];
      var errDataLen = 0;
      var outData = [];
      var outDataLen = 0;
      child.stdout.on('data', function (data) {
        outData.push(data);
        outDataLen += data.length;
        log.gauge.pulse('preparing git package');
      });
      child.stderr.on('data', function (data) {
        errData.push(data);
        errDataLen += data.length;
        log.gauge.pulse('preparing git package');
      });
      return BB.fromNode(function (cb) {
        child.on('error', cb);
        child.on('exit', function (code, signal) {
          if (code > 0) {
            var err = new Error(signal + ': npm exited with code ' + code + ' while attempting to build ' + manifest._requested + '. Clone the repository manually and run \'npm install\' in it for more information.');
            err.code = code;
            err.signal = signal;
            cb(err);
          } else {
            cb();
          }
        });
      }).then(function () {
        if (outDataLen > 0) log.silly('prepareGitDep', '1>', Buffer.concat(outData, outDataLen).toString());
        if (errDataLen > 0) log.silly('prepareGitDep', '2>', Buffer.concat(errData, errDataLen).toString());
      }, function (err) {
        if (outDataLen > 0) log.error('prepareGitDep', '1>', Buffer.concat(outData, outDataLen).toString());
        if (errDataLen > 0) log.error('prepareGitDep', '2>', Buffer.concat(errData, errDataLen).toString());
        throw err;
      });
    }
  }).then(function () {
    return readJson(path.join(dir, 'package.json'));
  }).then(function (pkg) {
    return cacache.tmp.withTmp(npm.tmp, {
      tmpPrefix: 'pacote-packing'
    }, function (tmp) {
      var tmpTar = path.join(tmp, 'package.tgz');
      return packDirectory(manifest, dir, tmpTar).then(function () {
        return pipe(fs.createReadStream(tmpTar), stream);
      });
    });
  }).catch(function (err) {
    return stream.emit('error', err);
  });
  return stream;
}
//# sourceMappingURL=pack.js.map