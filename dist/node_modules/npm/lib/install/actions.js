'use strict';

var BB = require('bluebird');

var andAddParentToErrors = require('./and-add-parent-to-errors.js');
var failedDependency = require('./deps.js').failedDependency;
var isInstallable = BB.promisify(require('./validate-args.js').isInstallable);
var moduleName = require('../utils/module-name.js');
var npm = require('../npm.js');
var reportOptionalFailure = require('./report-optional-failure.js');
var validate = require('aproba');

var actions = {};

actions.fetch = require('./action/fetch.js');
actions.extract = require('./action/extract.js');
actions.build = require('./action/build.js');
actions.preinstall = require('./action/preinstall.js');
actions.install = require('./action/install.js');
actions.postinstall = require('./action/postinstall.js');
actions.prepare = require('./action/prepare.js');
actions.finalize = require('./action/finalize.js');
actions.remove = require('./action/remove.js');
actions.unbuild = require('./action/unbuild.js');
actions.move = require('./action/move.js');
actions['global-install'] = require('./action/global-install.js');
actions['global-link'] = require('./action/global-link.js');
actions['refresh-package-json'] = require('./action/refresh-package-json.js');

// FIXME: We wrap actions like three ways to sunday here.
// Rewrite this to only work one way.

Object.keys(actions).forEach(function (actionName) {
  var action = actions[actionName];
  actions[actionName] = function (staging, pkg, log) {
    validate('SOO', [staging, pkg, log]);
    // refuse to run actions for failed packages
    if (pkg.failed) return BB.resolve();
    if (action.rollback) {
      if (!pkg.rollback) pkg.rollback = [];
      pkg.rollback.unshift(action.rollback);
    }
    if (action.commit) {
      if (!pkg.commit) pkg.commit = [];
      pkg.commit.push(action.commit);
    }

    var actionP = void 0;
    if (pkg.knownInstallable) {
      actionP = runAction(action, staging, pkg, log);
    } else {
      actionP = isInstallable(pkg.package).then(function () {
        pkg.knownInstallable = true;
        return runAction(action, staging, pkg, log);
      });
    }

    return actionP.then(function () {
      log.finish();
    }, function (err) {
      return BB.fromNode(function (cb) {
        andAddParentToErrors(pkg.parent, cb)(err);
      }).catch(function (err) {
        return handleOptionalDepErrors(pkg, err);
      });
    });
  };
  actions[actionName].init = action.init || function () {
    return BB.resolve();
  };
  actions[actionName].teardown = action.teardown || function () {
    return BB.resolve();
  };
});
exports.actions = actions;

function runAction(action, staging, pkg, log) {
  return BB.fromNode(function (cb) {
    var result = action(staging, pkg, log, cb);
    if (result && result.then) {
      result.then(function () {
        return cb();
      }, cb);
    }
  });
}

function markAsFailed(pkg) {
  if (pkg.failed) return;
  pkg.failed = true;
  pkg.requires.forEach(function (req) {
    var requiredBy = req.requiredBy.filter(function (reqReqBy) {
      return !reqReqBy.failed;
    });
    if (requiredBy.length === 0 && !req.userRequired) {
      markAsFailed(req);
    }
  });
}

function handleOptionalDepErrors(pkg, err) {
  markAsFailed(pkg);
  var anyFatal = failedDependency(pkg);
  if (anyFatal) {
    throw err;
  } else {
    reportOptionalFailure(pkg, null, err);
  }
}

exports.doOne = doOne;
function doOne(cmd, staging, pkg, log, next) {
  validate('SSOOF', arguments);
  var prepped = prepareAction([cmd, pkg], staging, log);
  return withInit(actions[cmd], function () {
    return execAction(prepped);
  }).nodeify(next);
}

exports.doParallel = doParallel;
function doParallel(type, staging, actionsToRun, log, next) {
  validate('SSAOF', arguments);
  var acts = actionsToRun.reduce(function (acc, todo) {
    if (todo[0] === type) {
      acc.push(prepareAction(todo, staging, log));
    }
    return acc;
  }, []);
  log.silly('doParallel', type + ' ' + acts.length);
  time(log);
  if (!acts.length) {
    return next();
  }
  return withInit(actions[type], function () {
    return BB.map(acts, execAction, {
      concurrency: npm.limit.action
    });
  }).nodeify(function (err) {
    log.finish();
    timeEnd(log);
    next(err);
  });
}

exports.doSerial = doSerial;
function doSerial(type, staging, actionsToRun, log, next) {
  validate('SSAOF', arguments);
  log.silly('doSerial', '%s %d', type, actionsToRun.length);
  runSerial(type, staging, actionsToRun, log, next);
}

exports.doReverseSerial = doReverseSerial;
function doReverseSerial(type, staging, actionsToRun, log, next) {
  validate('SSAOF', arguments);
  log.silly('doReverseSerial', '%s %d', type, actionsToRun.length);
  runSerial(type, staging, [].concat(actionsToRun).reverse(), log, next);
}

function runSerial(type, staging, actionsToRun, log, next) {
  var acts = actionsToRun.reduce(function (acc, todo) {
    if (todo[0] === type) {
      acc.push(prepareAction(todo, staging, log));
    }
    return acc;
  }, []);
  time(log);
  if (!acts.length) {
    return next();
  }
  return withInit(actions[type], function () {
    return BB.each(acts, execAction);
  }).nodeify(function (err) {
    log.finish();
    timeEnd(log);
    next(err);
  });
}

function time(log) {
  process.emit('time', 'action:' + log.name);
}
function timeEnd(log) {
  process.emit('timeEnd', 'action:' + log.name);
}

function withInit(action, body) {
  return BB.using(action.init().disposer(function () {
    return action.teardown();
  }), body);
}

function prepareAction(action, staging, log) {
  validate('ASO', arguments);
  validate('SO', action);
  var cmd = action[0];
  var pkg = action[1];
  if (!actions[cmd]) throw new Error('Unknown decomposed command "' + cmd + '" (is it new?)');
  return [actions[cmd], staging, pkg, log.newGroup(cmd + ':' + moduleName(pkg))];
}

function execAction(todo) {
  return todo[0].apply(null, todo.slice(1));
}
//# sourceMappingURL=actions.js.map