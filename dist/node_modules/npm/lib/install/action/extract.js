'use strict';

var BB = require('bluebird');

var stat = BB.promisify(require('graceful-fs').stat);
var gentlyRm = BB.promisify(require('../../utils/gently-rm.js'));
var mkdirp = BB.promisify(require('mkdirp'));
var moduleStagingPath = require('../module-staging-path.js');
var move = require('../../utils/move.js');
var npa = require('npm-package-arg');
var npm = require('../../npm.js');
var packageId = require('../../utils/package-id.js');
var pacoteOpts = void 0;
var path = require('path');
var localWorker = require('./extract-worker.js');
var workerFarm = require('worker-farm');
var isRegistry = require('../../utils/is-registry.js');

var WORKER_PATH = require.resolve('./extract-worker.js');
var workers = void 0;

// NOTE: temporarily disabled on non-OSX due to ongoing issues:
//
// * Seems to make Windows antivirus issues much more common
// * Messes with Docker (I think)
//
// There are other issues that should be fixed that affect OSX too:
//
// * Logging is messed up right now because pacote does its own thing
// * Global deduplication in pacote breaks due to multiple procs
//
// As these get fixed, we can start experimenting with re-enabling it
// at least on some platforms.
var ENABLE_WORKERS = process.platform === 'darwin';

extract.init = function () {
  if (ENABLE_WORKERS) {
    workers = workerFarm({
      maxConcurrentCallsPerWorker: npm.limit.fetch,
      maxRetries: 1
    }, WORKER_PATH);
  }
  return BB.resolve();
};
extract.teardown = function () {
  if (ENABLE_WORKERS) {
    workerFarm.end(workers);
    workers = null;
  }
  return BB.resolve();
};
module.exports = extract;
function extract(staging, pkg, log) {
  log.silly('extract', packageId(pkg));
  var extractTo = moduleStagingPath(staging, pkg);
  if (!pacoteOpts) {
    pacoteOpts = require('../../config/pacote');
  }
  var opts = pacoteOpts({
    integrity: pkg.package._integrity,
    resolved: pkg.package._resolved
  });
  var args = [pkg.package._requested, extractTo, opts];
  return BB.fromNode(function (cb) {
    var launcher = localWorker;
    var msg = args;
    var spec = typeof args[0] === 'string' ? npa(args[0]) : args[0];
    args[0] = spec.raw;
    if (ENABLE_WORKERS && (isRegistry(spec) || spec.type === 'remote')) {
      // We can't serialize these options
      opts.loglevel = opts.log.level;
      opts.log = null;
      opts.dirPacker = null;
      // workers will run things in parallel!
      launcher = workers;
      try {
        msg = JSON.stringify(msg);
      } catch (e) {
        return cb(e);
      }
    }
    launcher(msg, cb);
  }).then(function () {
    if (pkg.package.bundleDependencies || anyBundled(pkg)) {
      return readBundled(pkg, staging, extractTo);
    }
  }).then(function () {
    return gentlyRm(path.join(extractTo, 'node_modules'));
  });
}

function anyBundled(top, pkg) {
  if (!pkg) pkg = top;
  return pkg.children.some(function (child) {
    return child.fromBundle === top || anyBundled(top, child);
  });
}

function readBundled(pkg, staging, extractTo) {
  return BB.map(pkg.children, function (child) {
    if (!child.fromBundle) return;
    if (child.error) {
      throw child.error;
    } else {
      return stageBundledModule(pkg, child, staging, extractTo);
    }
  }, { concurrency: 10 });
}

function stageBundledModule(bundler, child, staging, parentPath) {
  var stageFrom = path.join(parentPath, 'node_modules', child.package.name);
  var stageTo = moduleStagingPath(staging, child);

  return BB.map(child.children, function (child) {
    if (child.error) {
      throw child.error;
    } else {
      return stageBundledModule(bundler, child, staging, stageFrom);
    }
  }).then(function () {
    return finishModule(bundler, child, stageTo, stageFrom);
  });
}

function finishModule(bundler, child, stageTo, stageFrom) {
  // If we were the one's who bundled this moduleâ€¦
  if (child.fromBundle === bundler) {
    return mkdirp(path.dirname(stageTo)).then(function () {
      return move(stageFrom, stageTo);
    });
  } else {
    return stat(stageFrom).then(function () {
      return gentlyRm(stageFrom);
    }, function () {});
  }
}
//# sourceMappingURL=extract.js.map