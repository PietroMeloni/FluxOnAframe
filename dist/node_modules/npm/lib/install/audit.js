'use strict';

var _templateObject = _taggedTemplateLiteral(['version'], ['version']),
    _templateObject2 = _taggedTemplateLiteral(['from resolved'], ['from resolved']);

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

exports.generate = generate;
exports.generateFromInstall = generateFromInstall;
exports.submitForInstallReport = submitForInstallReport;
exports.submitForFullReport = submitForFullReport;
exports.printInstallReport = printInstallReport;
exports.printParseableReport = printParseableReport;
exports.printFullReport = printFullReport;

var Bluebird = require('bluebird');
var auditReport = require('npm-audit-report');
var treeToShrinkwrap = require('../shrinkwrap.js').treeToShrinkwrap;
var packageId = require('../utils/package-id.js');
var output = require('../utils/output.js');
var npm = require('../npm.js');
var qw = require('qw');
var registryFetch = require('npm-registry-fetch');
var zlib = require('zlib');
var gzip = Bluebird.promisify(zlib.gzip);
var log = require('npmlog');
var perf = require('../utils/perf.js');
var url = require('url');
var npa = require('npm-package-arg');
var uuid = require('uuid');
var ssri = require('ssri');
var cloneDeep = require('lodash.clonedeep');
var pacoteOpts = require('../config/pacote.js');

// used when scrubbing module names/specifiers
var runId = uuid.v4();

function submitForInstallReport(auditData) {
  var cfg = npm.config; // avoid the no-dynamic-lookups test
  var scopedRegistries = cfg.keys.filter(function (_) {
    return (/:registry$/.test(_)
    );
  }).map(function (_) {
    return cfg.get(_);
  });
  perf.emit('time', 'audit compress');
  // TODO: registryFetch will be adding native support for `Content-Encoding: gzip` at which point
  // we'll pass in something like `gzip: true` and not need to JSON stringify, gzip or headers.
  return gzip(JSON.stringify(auditData)).then(function (body) {
    perf.emit('timeEnd', 'audit compress');
    log.info('audit', 'Submitting payload of ' + body.length + 'bytes');
    scopedRegistries.forEach(function (reg) {
      // we don't care about the response so destroy the stream if we can, or leave it flowing
      // so it can eventually finish and clean up after itself
      fetchAudit(url.resolve(reg, '/-/npm/v1/security/audits/quick')).then(function (_) {
        _.body.on('error', function () {});
        if (_.body.destroy) {
          _.body.destroy();
        } else {
          _.body.resume();
        }
      }, function (_) {});
    });
    perf.emit('time', 'audit submit');
    return fetchAudit('/-/npm/v1/security/audits/quick', body).then(function (response) {
      perf.emit('timeEnd', 'audit submit');
      perf.emit('time', 'audit body');
      return response.json();
    }).then(function (result) {
      perf.emit('timeEnd', 'audit body');
      return result;
    });
  });
}

function submitForFullReport(auditData) {
  perf.emit('time', 'audit compress');
  // TODO: registryFetch will be adding native support for `Content-Encoding: gzip` at which point
  // we'll pass in something like `gzip: true` and not need to JSON stringify, gzip or headers.
  return gzip(JSON.stringify(auditData)).then(function (body) {
    perf.emit('timeEnd', 'audit compress');
    log.info('audit', 'Submitting payload of ' + body.length + ' bytes');
    perf.emit('time', 'audit submit');
    return fetchAudit('/-/npm/v1/security/audits', body).then(function (response) {
      perf.emit('timeEnd', 'audit submit');
      perf.emit('time', 'audit body');
      return response.json();
    }).then(function (result) {
      perf.emit('timeEnd', 'audit body');
      result.runId = runId;
      return result;
    });
  });
}

function fetchAudit(href, body) {
  var opts = pacoteOpts();
  return registryFetch(href, {
    method: 'POST',
    headers: { 'Content-Encoding': 'gzip', 'Content-Type': 'application/json' },
    config: npm.config,
    npmSession: opts.npmSession,
    projectScope: npm.projectScope,
    log: log,
    body: body
  });
}

function printInstallReport(auditResult) {
  return auditReport(auditResult, {
    reporter: 'install',
    withColor: npm.color,
    withUnicode: npm.config.get('unicode')
  }).then(function (result) {
    return output(result.report);
  });
}

function printFullReport(auditResult) {
  return auditReport(auditResult, {
    log: output,
    reporter: npm.config.get('json') ? 'json' : 'detail',
    withColor: npm.color,
    withUnicode: npm.config.get('unicode')
  }).then(function (result) {
    return output(result.report);
  });
}

function printParseableReport(auditResult) {
  return auditReport(auditResult, {
    log: output,
    reporter: 'parseable',
    withColor: npm.color,
    withUnicode: npm.config.get('unicode')
  }).then(function (result) {
    return output(result.report);
  });
}

function generate(shrinkwrap, requires, diffs, install, remove) {
  var sw = cloneDeep(shrinkwrap);
  delete sw.lockfileVersion;
  sw.requires = scrubRequires(requires);
  scrubDeps(sw.dependencies);

  // sw.diffs = diffs || {}
  sw.install = (install || []).map(scrubArg);
  sw.remove = (remove || []).map(scrubArg);
  return generateMetadata().then(function (md) {
    sw.metadata = md;
    return sw;
  });
}

var scrubKeys = qw(_templateObject);
var deleteKeys = qw(_templateObject2);

function scrubDeps(deps) {
  if (!deps) return;
  Object.keys(deps).forEach(function (name) {
    if (!shouldScrubName(name) && !shouldScrubSpec(name, deps[name].version)) return;
    var value = deps[name];
    delete deps[name];
    deps[scrub(name)] = value;
  });
  Object.keys(deps).forEach(function (name) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = scrubKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var toScrub = _step.value;

        if (!deps[name][toScrub]) continue;
        deps[name][toScrub] = scrubSpec(name, deps[name][toScrub]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = deleteKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var toDelete = _step2.value;
        delete deps[name][toDelete];
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    scrubRequires(deps[name].requires);
    scrubDeps(deps[name].dependencies);
  });
}

function scrubRequires(reqs) {
  if (!reqs) return reqs;
  Object.keys(reqs).forEach(function (name) {
    var spec = reqs[name];
    if (shouldScrubName(name) || shouldScrubSpec(name, spec)) {
      delete reqs[name];
      reqs[scrub(name)] = scrubSpec(name, spec);
    } else {
      reqs[name] = scrubSpec(name, spec);
    }
  });
  return reqs;
}

function getScope(name) {
  if (name[0] === '@') return name.slice(0, name.indexOf('/'));
}

function shouldScrubName(name) {
  var scope = getScope(name);
  var cfg = npm.config; // avoid the no-dynamic-lookups test
  return Boolean(scope && cfg.get(scope + ':registry'));
}
function shouldScrubSpec(name, spec) {
  var req = npa.resolve(name, spec);
  return !req.registry;
}

function scrubArg(arg) {
  var req = npa(arg);
  var name = req.name;
  if (shouldScrubName(name) || shouldScrubSpec(name, req.rawSpec)) {
    name = scrubName(name);
  }
  var spec = scrubSpec(req.name, req.rawSpec);
  return name + '@' + spec;
}

function scrubName(name) {
  return shouldScrubName(name) ? scrub(name) : name;
}

function scrubSpec(name, spec) {
  var req = npa.resolve(name, spec);
  if (req.registry) return spec;
  if (req.type === 'git') {
    return 'git+ssh://' + scrub(spec);
  } else if (req.type === 'remote') {
    return 'https://' + scrub(spec);
  } else if (req.type === 'directory') {
    return 'file:' + scrub(spec);
  } else if (req.type === 'file') {
    return 'file:' + scrub(spec) + '.tar';
  } else {
    return scrub(spec);
  }
}

module.exports.scrub = scrub;
function scrub(value, rid) {
  return ssri.fromData((rid || runId) + ' ' + value, { algorithms: ['sha256'] }).hexDigest();
}

function generateMetadata() {
  var meta = {};
  meta.npm_version = npm.version;
  meta.node_version = process.version;
  meta.platform = process.platform;
  meta.node_env = process.env.NODE_ENV;

  return Promise.resolve(meta);
}
/*
  const head = path.resolve(npm.prefix, '.git/HEAD')
  return readFile(head, 'utf8').then((head) => {
    if (!head.match(/^ref: /)) {
      meta.commit_hash = head.trim()
      return
    }
    const headFile = head.replace(/^ref: /, '').trim()
    meta.branch = headFile.replace(/^refs[/]heads[/]/, '')
    return readFile(path.resolve(npm.prefix, '.git', headFile), 'utf8')
  }).then((commitHash) => {
    meta.commit_hash = commitHash.trim()
    const proc = spawn('git', qw`diff --quiet --exit-code package.json package-lock.json`, {cwd: npm.prefix, stdio: 'ignore'})
    return new Promise((resolve, reject) => {
      proc.once('error', reject)
      proc.on('exit', (code, signal) => {
        if (signal == null) meta.state = code === 0 ? 'clean' : 'dirty'
        resolve()
      })
    })
  }).then(() => meta, () => meta)
*/

function generateFromInstall(tree, diffs, install, remove) {
  var requires = {};
  tree.requires.forEach(function (pkg) {
    requires[pkg.package.name] = tree.package.dependencies[pkg.package.name] || tree.package.devDependencies[pkg.package.name] || pkg.package.version;
  });

  var auditInstall = (install || []).filter(function (a) {
    return a.name;
  }).map(packageId);
  var auditRemove = (remove || []).filter(function (a) {
    return a.name;
  }).map(packageId);
  var auditDiffs = {};
  diffs.forEach(function (action) {
    var mutation = action[0];
    var child = action[1];
    if (mutation !== 'add' && mutation !== 'update' && mutation !== 'remove') return;
    if (!auditDiffs[mutation]) auditDiffs[mutation] = [];
    if (mutation === 'add') {
      auditDiffs[mutation].push({ location: child.location });
    } else if (mutation === 'update') {
      auditDiffs[mutation].push({ location: child.location, previous: packageId(child.oldPkg) });
    } else if (mutation === 'remove') {
      auditDiffs[mutation].push({ previous: packageId(child) });
    }
  });

  return generate(treeToShrinkwrap(tree), requires, auditDiffs, auditInstall, auditRemove);
}
//# sourceMappingURL=audit.js.map