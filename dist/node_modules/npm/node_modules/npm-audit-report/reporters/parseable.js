'use strict';

var report = function report(data, options) {
  var defaults = {
    severityThreshold: 'info'
  };

  var config = Object.assign({}, defaults, options);

  var exit = 0;

  var actions = function actions(data, config) {
    var accumulator = {
      high: '',
      moderate: '',
      low: ''
    };

    if (Object.keys(data.advisories).length !== 0) {
      data.actions.forEach(function (action) {
        var l = {};
        // Start with install/update actions
        if (action.action === 'update' || action.action === 'install') {
          var recommendation = getRecommendation(action, config);
          l.recommendation = recommendation.cmd;
          l.breaking = recommendation.isBreaking ? 'Y' : 'N';

          // TODO: Verify: The advisory seems to repeat and be the same for all the 'resolves'. Is it true?
          var advisory = data.advisories[action.resolves[0].id];
          l.sevLevel = advisory.severity;
          l.severity = advisory.title;
          l.package = advisory.module_name;
          l.moreInfo = 'https://nodesecurity.io/advisories/' + advisory.id;
          l.path = action.resolves[0].path;

          accumulator[advisory.severity] += [action.action, l.package, l.sevLevel, l.recommendation, l.severity, l.moreInfo, l.path, l.breaking].join('\t') + '\n';
        }

        if (action.action === 'review') {
          action.resolves.forEach(function (resolution) {
            var advisory = data.advisories[resolution.id];

            l.sevLevel = advisory.severity;
            l.severity = advisory.title;
            l.package = advisory.module_name;
            l.moreInfo = 'https://nodesecurity.io/advisories/' + advisory.id;
            l.patchedIn = advisory.patched_versions.replace(' ', '') === '<0.0.0' ? 'No patch available' : advisory.patched_versions;
            l.path = resolution.path;

            accumulator[advisory.severity] += [action.action, l.package, l.sevLevel, l.patchedIn, l.severity, l.moreInfo, l.path].join('\t') + '\n';
          }); // forEach resolves
        } // is review
      }); // forEach actions
    }
    return accumulator['high'] + accumulator['moderate'] + accumulator['low'];
  };

  var exitCode = function exitCode(metadata) {
    var total = 0;
    var keys = Object.keys(metadata.vulnerabilities);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key = _step.value;

        var value = metadata.vulnerabilities[key];
        total = total + value;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (total > 0) {
      exit = 1;
    }
  };

  exitCode(data.metadata);

  return {
    report: actions(data, config),
    exitCode: exit
  };
};

var getRecommendation = function getRecommendation(action, config) {
  if (action.action === 'install') {
    var isDev = action.resolves[0].dev;

    return {
      cmd: 'npm install ' + (isDev ? '--save-dev ' : '') + action.module + '@' + action.target,
      isBreaking: action.isMajor
    };
  } else {
    return {
      cmd: 'npm update ' + action.module + ' --depth ' + action.depth,
      isBreaking: false
    };
  }
};

module.exports = report;
//# sourceMappingURL=parseable.js.map