{"version":3,"sources":["../../../../../node_modules/npm/node_modules/https-proxy-agent/index.js"],"names":["net","require","tls","url","Agent","inherits","debug","module","exports","HttpsProxyAgent","opts","parse","Error","call","proxy","Object","assign","secureProxy","protocol","test","host","hostname","port","ALPNProtocols","path","pathname","defaultPort","prototype","callback","connect","req","fn","socket","buffers","buffersLength","read","b","ondata","once","cleanup","removeListener","onend","onerror","onclose","err","push","length","buffered","Buffer","concat","str","toString","indexOf","firstLine","substring","statusCode","split","sock","secureEndpoint","servername","onsocket","listeners","emit","on","msg","headers","auth","from","isDefaultPort","keys","forEach","name","write","secure","Boolean"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Module dependencies.\n */\n\nvar net = require('net');\nvar tls = require('tls');\nvar url = require('url');\nvar Agent = require('agent-base');\nvar inherits = require('util').inherits;\nvar debug = require('debug')('https-proxy-agent');\n\n/**\n * Module exports.\n */\n\nmodule.exports = HttpsProxyAgent;\n\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to the\n * specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * @api public\n */\n\nfunction HttpsProxyAgent(opts) {\n  if (!(this instanceof HttpsProxyAgent)) return new HttpsProxyAgent(opts);\n  if ('string' == typeof opts) opts = url.parse(opts);\n  if (!opts)\n    throw new Error(\n      'an HTTP(S) proxy server `host` and `port` must be specified!'\n    );\n  debug('creating new HttpsProxyAgent instance: %o', opts);\n  Agent.call(this, opts);\n\n  var proxy = Object.assign({}, opts);\n\n  // if `true`, then connect to the proxy server over TLS. defaults to `false`.\n  this.secureProxy = proxy.protocol ? /^https:?$/i.test(proxy.protocol) : false;\n\n  // prefer `hostname` over `host`, and set the `port` if needed\n  proxy.host = proxy.hostname || proxy.host;\n  proxy.port = +proxy.port || (this.secureProxy ? 443 : 80);\n\n  // ALPN is supported by Node.js >= v5.\n  // attempt to negotiate http/1.1 for proxy servers that support http/2\n  if (this.secureProxy && !('ALPNProtocols' in proxy)) {\n    proxy.ALPNProtocols = ['http 1.1']\n  }\n\n  if (proxy.host && proxy.path) {\n    // if both a `host` and `path` are specified then it's most likely the\n    // result of a `url.parse()` call... we need to remove the `path` portion so\n    // that `net.connect()` doesn't attempt to open that as a unix socket file.\n    delete proxy.path;\n    delete proxy.pathname;\n  }\n\n  this.proxy = proxy;\n  this.defaultPort = 443;\n}\ninherits(HttpsProxyAgent, Agent);\n\n/**\n * Called when the node-core HTTP client library is creating a new HTTP request.\n *\n * @api public\n */\n\nHttpsProxyAgent.prototype.callback = function connect(req, opts, fn) {\n  var proxy = this.proxy;\n\n  // create a socket connection to the proxy server\n  var socket;\n  if (this.secureProxy) {\n    socket = tls.connect(proxy);\n  } else {\n    socket = net.connect(proxy);\n  }\n\n  // we need to buffer any HTTP traffic that happens with the proxy before we get\n  // the CONNECT response, so that if the response is anything other than an \"200\"\n  // response code, then we can re-play the \"data\" events on the socket once the\n  // HTTP parser is hooked up...\n  var buffers = [];\n  var buffersLength = 0;\n\n  function read() {\n    var b = socket.read();\n    if (b) ondata(b);\n    else socket.once('readable', read);\n  }\n\n  function cleanup() {\n    socket.removeListener('data', ondata);\n    socket.removeListener('end', onend);\n    socket.removeListener('error', onerror);\n    socket.removeListener('close', onclose);\n    socket.removeListener('readable', read);\n  }\n\n  function onclose(err) {\n    debug('onclose had error %o', err);\n  }\n\n  function onend() {\n    debug('onend');\n  }\n\n  function onerror(err) {\n    cleanup();\n    fn(err);\n  }\n\n  function ondata(b) {\n    buffers.push(b);\n    buffersLength += b.length;\n    var buffered = Buffer.concat(buffers, buffersLength);\n    var str = buffered.toString('ascii');\n\n    if (!~str.indexOf('\\r\\n\\r\\n')) {\n      // keep buffering\n      debug('have not received end of HTTP headers yet...');\n      if (socket.read) {\n        read();\n      } else {\n        socket.once('data', ondata);\n      }\n      return;\n    }\n\n    var firstLine = str.substring(0, str.indexOf('\\r\\n'));\n    var statusCode = +firstLine.split(' ')[1];\n    debug('got proxy server response: %o', firstLine);\n\n    if (200 == statusCode) {\n      // 200 Connected status code!\n      var sock = socket;\n\n      // nullify the buffered data since we won't be needing it\n      buffers = buffered = null;\n\n      if (opts.secureEndpoint) {\n        // since the proxy is connecting to an SSL server, we have\n        // to upgrade this socket connection to an SSL connection\n        debug(\n          'upgrading proxy-connected socket to TLS connection: %o',\n          opts.host\n        );\n        opts.socket = socket;\n        opts.servername = opts.servername || opts.host;\n        opts.host = null;\n        opts.hostname = null;\n        opts.port = null;\n        sock = tls.connect(opts);\n      }\n\n      cleanup();\n      fn(null, sock);\n    } else {\n      // some other status code that's not 200... need to re-play the HTTP header\n      // \"data\" events onto the socket once the HTTP machinery is attached so that\n      // the user can parse and handle the error status code\n      cleanup();\n\n      // save a reference to the concat'd Buffer for the `onsocket` callback\n      buffers = buffered;\n\n      // need to wait for the \"socket\" event to re-play the \"data\" events\n      req.once('socket', onsocket);\n      fn(null, socket);\n    }\n  }\n\n  function onsocket(socket) {\n    // replay the \"buffers\" Buffer onto the `socket`, since at this point\n    // the HTTP module machinery has been hooked up for the user\n    if ('function' == typeof socket.ondata) {\n      // node <= v0.11.3, the `ondata` function is set on the socket\n      socket.ondata(buffers, 0, buffers.length);\n    } else if (socket.listeners('data').length > 0) {\n      // node > v0.11.3, the \"data\" event is listened for directly\n      socket.emit('data', buffers);\n    } else {\n      // never?\n      throw new Error('should not happen...');\n    }\n\n    // nullify the cached Buffer instance\n    buffers = null;\n  }\n\n  socket.on('error', onerror);\n  socket.on('close', onclose);\n  socket.on('end', onend);\n\n  if (socket.read) {\n    read();\n  } else {\n    socket.once('data', ondata);\n  }\n\n  var hostname = opts.host + ':' + opts.port;\n  var msg = 'CONNECT ' + hostname + ' HTTP/1.1\\r\\n';\n\n  var headers = Object.assign({}, proxy.headers);\n  if (proxy.auth) {\n    headers['Proxy-Authorization'] =\n      'Basic ' + Buffer.from(proxy.auth).toString('base64');\n  }\n\n  // the Host header should only include the port\n  // number when it is a non-standard port\n  var host = opts.host;\n  if (!isDefaultPort(opts.port, opts.secureEndpoint)) {\n    host += ':' + opts.port;\n  }\n  headers['Host'] = host;\n\n  headers['Connection'] = 'close';\n  Object.keys(headers).forEach(function(name) {\n    msg += name + ': ' + headers[name] + '\\r\\n';\n  });\n\n  socket.write(msg + '\\r\\n');\n};\n\nfunction isDefaultPort(port, secure) {\n  return Boolean((!secure && port === 80) || (secure && port === 443));\n}\n"]}