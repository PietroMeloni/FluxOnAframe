{"version":3,"sources":["../../../../../../../../node_modules/npm/node_modules/npm-registry-fetch/node_modules/cacache/lib/entry-index.js"],"names":["BB","require","contentPath","crypto","fixOwner","fs","hashToSegments","ms","path","ssri","Y","indexV","index","appendFileAsync","promisify","appendFile","readFileAsync","readFile","readdirAsync","readdir","concat","from","module","exports","NotFoundError","cache","key","code","Error","insert","integrity","opts","bucket","bucketPath","entry","stringify","time","Date","now","size","metadata","mkdirfix","dirname","uid","gid","then","stringified","JSON","hashEntry","chownr","catch","formatEntry","find","bucketEntries","entries","reduce","latest","next","err","delete","del","lsStream","indexDir","bucketDir","stream","obj","readdirOrEmpty","map","join","subbucketPath","subbucket","getKeyToEntry","acc","set","Map","reduced","values","formatted","push","nop","emit","ls","fromNode","on","cb","pipe","xs","filter","data","split","forEach","pieces","parse","e","_bucketDir","_bucketPath","hashed","hashKey","apply","_hashKey","hash","_hashEntry","str","digest","createHash","update","dir"],"mappings":"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","file":"entry-index.js","sourcesContent":["'use strict'\n\nconst BB = require('bluebird')\n\nconst contentPath = require('./content/path')\nconst crypto = require('crypto')\nconst fixOwner = require('./util/fix-owner')\nconst fs = require('graceful-fs')\nconst hashToSegments = require('./util/hash-to-segments')\nconst ms = require('mississippi')\nconst path = require('path')\nconst ssri = require('ssri')\nconst Y = require('./util/y.js')\n\nconst indexV = require('../package.json')['cache-version'].index\n\nconst appendFileAsync = BB.promisify(fs.appendFile)\nconst readFileAsync = BB.promisify(fs.readFile)\nconst readdirAsync = BB.promisify(fs.readdir)\nconst concat = ms.concat\nconst from = ms.from\n\nmodule.exports.NotFoundError = class NotFoundError extends Error {\n  constructor (cache, key) {\n    super(Y`No cache entry for \\`${key}\\` found in \\`${cache}\\``)\n    this.code = 'ENOENT'\n    this.cache = cache\n    this.key = key\n  }\n}\n\nmodule.exports.insert = insert\nfunction insert (cache, key, integrity, opts) {\n  opts = opts || {}\n  const bucket = bucketPath(cache, key)\n  const entry = {\n    key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size: opts.size,\n    metadata: opts.metadata\n  }\n  return fixOwner.mkdirfix(\n    path.dirname(bucket), opts.uid, opts.gid\n  ).then(() => {\n    const stringified = JSON.stringify(entry)\n    // NOTE - Cleverness ahoy!\n    //\n    // This works because it's tremendously unlikely for an entry to corrupt\n    // another while still preserving the string length of the JSON in\n    // question. So, we just slap the length in there and verify it on read.\n    //\n    // Thanks to @isaacs for the whiteboarding session that ended up with this.\n    return appendFileAsync(\n      bucket, `\\n${hashEntry(stringified)}\\t${stringified}`\n    )\n  }).then(\n    () => fixOwner.chownr(bucket, opts.uid, opts.gid)\n  ).catch({code: 'ENOENT'}, () => {\n    // There's a class of race conditions that happen when things get deleted\n    // during fixOwner, or between the two mkdirfix/chownr calls.\n    //\n    // It's perfectly fine to just not bother in those cases and lie\n    // that the index entry was written. Because it's a cache.\n  }).then(() => {\n    return formatEntry(cache, entry)\n  })\n}\n\nmodule.exports.find = find\nfunction find (cache, key) {\n  const bucket = bucketPath(cache, key)\n  return bucketEntries(cache, bucket).then(entries => {\n    return entries.reduce((latest, next) => {\n      if (next && next.key === key) {\n        return formatEntry(cache, next)\n      } else {\n        return latest\n      }\n    }, null)\n  }).catch(err => {\n    if (err.code === 'ENOENT') {\n      return null\n    } else {\n      throw err\n    }\n  })\n}\n\nmodule.exports.delete = del\nfunction del (cache, key, opts) {\n  return insert(cache, key, null, opts)\n}\n\nmodule.exports.lsStream = lsStream\nfunction lsStream (cache) {\n  const indexDir = bucketDir(cache)\n  const stream = from.obj()\n\n  // \"/cachename/*\"\n  readdirOrEmpty(indexDir).map(bucket => {\n    const bucketPath = path.join(indexDir, bucket)\n\n    // \"/cachename/<bucket 0xFF>/*\"\n    return readdirOrEmpty(bucketPath).map(subbucket => {\n      const subbucketPath = path.join(bucketPath, subbucket)\n\n      // \"/cachename/<bucket 0xFF>/<bucket 0xFF>/*\"\n      return readdirOrEmpty(subbucketPath).map(entry => {\n        const getKeyToEntry = bucketEntries(\n          cache,\n          path.join(subbucketPath, entry)\n        ).reduce((acc, entry) => {\n          acc.set(entry.key, entry)\n          return acc\n        }, new Map())\n\n        return getKeyToEntry.then(reduced => {\n          for (let entry of reduced.values()) {\n            const formatted = formatEntry(cache, entry)\n            formatted && stream.push(formatted)\n          }\n        }).catch({code: 'ENOENT'}, nop)\n      })\n    })\n  }).then(() => {\n    stream.push(null)\n  }, err => {\n    stream.emit('error', err)\n  })\n\n  return stream\n}\n\nmodule.exports.ls = ls\nfunction ls (cache) {\n  return BB.fromNode(cb => {\n    lsStream(cache).on('error', cb).pipe(concat(entries => {\n      cb(null, entries.reduce((acc, xs) => {\n        acc[xs.key] = xs\n        return acc\n      }, {}))\n    }))\n  })\n}\n\nfunction bucketEntries (cache, bucket, filter) {\n  return readFileAsync(\n    bucket, 'utf8'\n  ).then(data => {\n    let entries = []\n    data.split('\\n').forEach(entry => {\n      if (!entry) { return }\n      const pieces = entry.split('\\t')\n      if (!pieces[1] || hashEntry(pieces[1]) !== pieces[0]) {\n        // Hash is no good! Corruption or malice? Doesn't matter!\n        // EJECT EJECT\n        return\n      }\n      let obj\n      try {\n        obj = JSON.parse(pieces[1])\n      } catch (e) {\n        // Entry is corrupted!\n        return\n      }\n      if (obj) {\n        entries.push(obj)\n      }\n    })\n    return entries\n  })\n}\n\nmodule.exports._bucketDir = bucketDir\nfunction bucketDir (cache) {\n  return path.join(cache, `index-v${indexV}`)\n}\n\nmodule.exports._bucketPath = bucketPath\nfunction bucketPath (cache, key) {\n  const hashed = hashKey(key)\n  return path.join.apply(path, [bucketDir(cache)].concat(\n    hashToSegments(hashed)\n  ))\n}\n\nmodule.exports._hashKey = hashKey\nfunction hashKey (key) {\n  return hash(key, 'sha256')\n}\n\nmodule.exports._hashEntry = hashEntry\nfunction hashEntry (str) {\n  return hash(str, 'sha1')\n}\n\nfunction hash (str, digest) {\n  return crypto\n  .createHash(digest)\n  .update(str)\n  .digest('hex')\n}\n\nfunction formatEntry (cache, entry) {\n  // Treat null digests as deletions. They'll shadow any previous entries.\n  if (!entry.integrity) { return null }\n  return {\n    key: entry.key,\n    integrity: entry.integrity,\n    path: contentPath(cache, entry.integrity),\n    size: entry.size,\n    time: entry.time,\n    metadata: entry.metadata\n  }\n}\n\nfunction readdirOrEmpty (dir) {\n  return readdirAsync(dir)\n  .catch({code: 'ENOENT'}, () => [])\n  .catch({code: 'ENOTDIR'}, () => [])\n}\n\nfunction nop () {\n}\n"]}