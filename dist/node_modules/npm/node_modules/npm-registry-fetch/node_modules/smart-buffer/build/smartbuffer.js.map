{"version":3,"sources":["../../../../../../../../node_modules/npm/node_modules/npm-registry-fetch/node_modules/smart-buffer/build/smartbuffer.js"],"names":["DEFAULT_SMARTBUFFER_SIZE","DEFAULT_SMARTBUFFER_ENCODING","SmartBuffer","arg1","arg2","length","encoding","writeOffset","readOffset","Number","isFinite","isInteger","buff","Buffer","allocUnsafe","Error","isEncoding","isSmartBufferOptions","size","minLength","offset","offsetVal","ensureCapacity","copy","Math","max","oldLength","data","newLength","func","byteSize","value","call","ensureWriteable","readNumberValue","prototype","readUInt8","readUInt16BE","readUInt16LE","readUInt32BE","readUInt32LE","writeNumberValue","writeInt8","writeInt16BE","writeInt16LE","writeInt32BE","writeInt32LE","writeUInt8","writeUInt16BE","writeUInt16LE","writeUInt32BE","writeUInt32LE","readFloatBE","readFloatLE","writeFloatBE","writeFloatLE","readDoubleBE","readDoubleLE","writeDoubleBE","writeDoubleLE","lengthVal","min","slice","toString","encodingVal","byteLength","write","nullPos","i","writeString","endPoint","writeBuffer","amount","position","moveTo","clear","options","castOptions","undefined","module","exports"],"mappings":"AAAA;AACA;;;;;;;;AACA,IAAMA,2BAA2B,IAAjC;AACA;AACA,IAAMC,+BAA+B,MAArC;;IACMC,W;AACF;;;;;;AAMA,yBAAYC,IAAZ,EAAkBC,IAAlB,EAAwB;AAAA;;AACpB,aAAKC,MAAL,GAAc,CAAd;AACA,aAAKC,QAAL,GAAgBL,4BAAhB;AACA,aAAKM,WAAL,GAAmB,CAAnB;AACA,aAAKC,UAAL,GAAkB,CAAlB;AACA;AACA,YAAI,OAAOL,IAAP,KAAgB,QAApB,EAA8B;AAC1B,gBAAIM,OAAOC,QAAP,CAAgBP,IAAhB,KAAyBM,OAAOE,SAAP,CAAiBR,IAAjB,CAAzB,IAAmDA,OAAO,CAA9D,EAAiE;AAC7D,qBAAKS,IAAL,GAAYC,OAAOC,WAAP,CAAmBX,IAAnB,CAAZ;AACH,aAFD,MAGK;AACD,sBAAM,IAAIY,KAAJ,CAAU,wEAAV,CAAN;AACH;AACJ,SAPD,MAQK,IAAI,OAAOZ,IAAP,KAAgB,QAApB,EAA8B;AAC/B,gBAAIU,OAAOG,UAAP,CAAkBb,IAAlB,CAAJ,EAA6B;AACzB,qBAAKS,IAAL,GAAYC,OAAOC,WAAP,CAAmBd,wBAAnB,CAAZ;AACA,qBAAKM,QAAL,GAAgBH,IAAhB;AACH,aAHD,MAIK;AACD,sBAAM,IAAIY,KAAJ,CAAU,kGAAV,CAAN;AACH;AACJ,SARI,MASA,IAAIZ,gBAAgBU,MAApB,EAA4B;AAC7B,iBAAKD,IAAL,GAAYT,IAAZ;AACA,iBAAKE,MAAL,GAAcF,KAAKE,MAAnB;AACH,SAHI,MAIA,IAAIH,YAAYe,oBAAZ,CAAiCd,IAAjC,CAAJ,EAA4C;AAC7C;AACA,gBAAIA,KAAKG,QAAT,EAAmB;AACf,oBAAIO,OAAOG,UAAP,CAAkBb,KAAKG,QAAvB,CAAJ,EAAsC;AAClC,yBAAKA,QAAL,GAAgBH,KAAKG,QAArB;AACH,iBAFD,MAGK;AACD,0BAAM,IAAIS,KAAJ,CAAU,kGAAV,CAAN;AACH;AACJ;AACD;AACA,gBAAIZ,KAAKe,IAAT,EAAe;AACX,oBAAIT,OAAOC,QAAP,CAAgBP,KAAKe,IAArB,KAA8BT,OAAOE,SAAP,CAAiBR,KAAKe,IAAtB,CAA9B,IAA6Df,KAAKe,IAAL,GAAY,CAA7E,EAAgF;AAC5E,yBAAKN,IAAL,GAAYC,OAAOC,WAAP,CAAmBX,KAAKe,IAAxB,CAAZ;AACH,iBAFD,MAGK;AACD,0BAAM,IAAIH,KAAJ,CAAU,wEAAV,CAAN;AACH;AACJ,aAPD,MAQK,IAAIZ,KAAKS,IAAT,EAAe;AAChB,oBAAIT,KAAKS,IAAL,YAAqBC,MAAzB,EAAiC;AAC7B,yBAAKD,IAAL,GAAYT,KAAKS,IAAjB;AACA,yBAAKP,MAAL,GAAcF,KAAKS,IAAL,CAAUP,MAAxB;AACH,iBAHD,MAIK;AACD,0BAAM,IAAIU,KAAJ,CAAU,gDAAV,CAAN;AACH;AACJ,aARI,MASA;AACD,qBAAKH,IAAL,GAAYC,OAAOC,WAAP,CAAmBd,wBAAnB,CAAZ;AACH;AACJ,SA/BI,MAgCA,IAAI,QAAOG,IAAP,yCAAOA,IAAP,OAAgB,QAApB,EAA8B;AAC/B,kBAAM,IAAIY,KAAJ,CAAU,qDAAV,CAAN;AACH,SAFI,MAGA;AACD,iBAAKH,IAAL,GAAYC,OAAOC,WAAP,CAAmBd,wBAAnB,CAAZ;AACH;AACD;AACA,YAAI,OAAOI,IAAP,KAAgB,QAApB,EAA8B;AAC1B,gBAAIS,OAAOG,UAAP,CAAkBZ,IAAlB,CAAJ,EAA6B;AACzB,qBAAKE,QAAL,GAAgBF,IAAhB;AACH,aAFD,MAGK;AACD,sBAAM,IAAIW,KAAJ,CAAU,kGAAV,CAAN;AACH;AACJ;AACJ;AACD;;;;;;;;;;;;;AAoCA;;;;;;wCAMgBI,S,EAAWC,M,EAAQ;AAC/B,gBAAMC,YAAY,OAAOD,MAAP,KAAkB,QAAlB,GAA6BA,MAA7B,GAAsC,CAAxD;AACA;AACA,iBAAKE,cAAL,CAAoB,KAAKjB,MAAL,GAAcc,SAAd,GAA0BE,SAA9C;AACA;AACA,gBAAI,OAAOD,MAAP,KAAkB,QAAtB,EAAgC;AAC5B,qBAAKR,IAAL,CAAUW,IAAV,CAAe,KAAKX,IAApB,EAA0BS,YAAYF,SAAtC,EAAiDE,SAAjD,EAA4D,KAAKT,IAAL,CAAUP,MAAtE;AACH;AACD;AACA,iBAAKA,MAAL,GAAcmB,KAAKC,GAAL,CAAS,KAAKpB,MAAL,GAAcc,SAAvB,EAAkCE,YAAYF,SAA9C,CAAd;AACH;AACD;;;;;;;;uCAKeA,S,EAAW;AACtB,gBAAMO,YAAY,KAAKd,IAAL,CAAUP,MAA5B;AACA,gBAAIc,YAAYO,SAAhB,EAA2B;AACvB,oBAAIC,OAAO,KAAKf,IAAhB;AACA,oBAAIgB,YAAaF,YAAY,CAAb,GAAkB,CAAlB,GAAsB,CAAtC;AACA,oBAAIE,YAAYT,SAAhB,EAA2B;AACvBS,gCAAYT,SAAZ;AACH;AACD,qBAAKP,IAAL,GAAYC,OAAOC,WAAP,CAAmBc,SAAnB,CAAZ;AACAD,qBAAKJ,IAAL,CAAU,KAAKX,IAAf,EAAqB,CAArB,EAAwB,CAAxB,EAA2Bc,SAA3B;AACH;AACJ;AACD;;;;;;;;;;;wCAQgBG,I,EAAMC,Q,EAAU;AAC5B;AACA,gBAAMC,QAAQF,KAAKG,IAAL,CAAU,KAAKpB,IAAf,EAAqB,KAAKJ,UAA1B,CAAd;AACA;AACA,iBAAKA,UAAL,IAAmBsB,QAAnB;AACA,mBAAOC,KAAP;AACH;AACD;;;;;;;;;;;;yCASiBF,I,EAAMC,Q,EAAUC,K,EAAOX,M,EAAQ;AAC5C,gBAAMC,YAAY,OAAOD,MAAP,KAAkB,QAAlB,GAA6BA,MAA7B,GAAsC,KAAKb,WAA7D;AACA;AACA,iBAAK0B,eAAL,CAAqBH,QAArB,EAA+BV,MAA/B;AACA;AACAS,iBAAKG,IAAL,CAAU,KAAKpB,IAAf,EAAqBmB,KAArB,EAA4BV,SAA5B;AACA;AACA,iBAAKd,WAAL,IAAoBuB,QAApB;AACH;AACD;AACA;;;;;;;;mCAKW;AACP,mBAAO,KAAKI,eAAL,CAAqBrB,OAAOsB,SAAP,CAAiBC,SAAtC,EAAiD,CAAjD,CAAP;AACH;AACD;;;;;;;;sCAKc;AACV,mBAAO,KAAKF,eAAL,CAAqBrB,OAAOsB,SAAP,CAAiBE,YAAtC,EAAoD,CAApD,CAAP;AACH;AACD;;;;;;;;sCAKc;AACV,mBAAO,KAAKH,eAAL,CAAqBrB,OAAOsB,SAAP,CAAiBG,YAAtC,EAAoD,CAApD,CAAP;AACH;AACD;;;;;;;;sCAKc;AACV,mBAAO,KAAKJ,eAAL,CAAqBrB,OAAOsB,SAAP,CAAiBI,YAAtC,EAAoD,CAApD,CAAP;AACH;AACD;;;;;;;;sCAKc;AACV,mBAAO,KAAKL,eAAL,CAAqBrB,OAAOsB,SAAP,CAAiBK,YAAtC,EAAoD,CAApD,CAAP;AACH;AACD;;;;;;;;;;;kCAQUT,K,EAAOX,M,EAAQ;AACrB,iBAAKqB,gBAAL,CAAsB5B,OAAOsB,SAAP,CAAiBO,SAAvC,EAAkD,CAAlD,EAAqDX,KAArD,EAA4DX,MAA5D;AACA,mBAAO,IAAP;AACH;AACD;;;;;;;;;;;qCAQaW,K,EAAOX,M,EAAQ;AACxB,iBAAKqB,gBAAL,CAAsB5B,OAAOsB,SAAP,CAAiBQ,YAAvC,EAAqD,CAArD,EAAwDZ,KAAxD,EAA+DX,MAA/D;AACA,mBAAO,IAAP;AACH;AACD;;;;;;;;;;;qCAQaW,K,EAAOX,M,EAAQ;AACxB,iBAAKqB,gBAAL,CAAsB5B,OAAOsB,SAAP,CAAiBS,YAAvC,EAAqD,CAArD,EAAwDb,KAAxD,EAA+DX,MAA/D;AACA,mBAAO,IAAP;AACH;AACD;;;;;;;;;;;qCAQaW,K,EAAOX,M,EAAQ;AACxB,iBAAKqB,gBAAL,CAAsB5B,OAAOsB,SAAP,CAAiBU,YAAvC,EAAqD,CAArD,EAAwDd,KAAxD,EAA+DX,MAA/D;AACA,mBAAO,IAAP;AACH;AACD;;;;;;;;;;;qCAQaW,K,EAAOX,M,EAAQ;AACxB,iBAAKqB,gBAAL,CAAsB5B,OAAOsB,SAAP,CAAiBW,YAAvC,EAAqD,CAArD,EAAwDf,KAAxD,EAA+DX,MAA/D;AACA,mBAAO,IAAP;AACH;AACD;AACA;;;;;;;;oCAKY;AACR,mBAAO,KAAKc,eAAL,CAAqBrB,OAAOsB,SAAP,CAAiBC,SAAtC,EAAiD,CAAjD,CAAP;AACH;AACD;;;;;;;;uCAKe;AACX,mBAAO,KAAKF,eAAL,CAAqBrB,OAAOsB,SAAP,CAAiBE,YAAtC,EAAoD,CAApD,CAAP;AACH;AACD;;;;;;;;uCAKe;AACX,mBAAO,KAAKH,eAAL,CAAqBrB,OAAOsB,SAAP,CAAiBG,YAAtC,EAAoD,CAApD,CAAP;AACH;AACD;;;;;;;;uCAKe;AACX,mBAAO,KAAKJ,eAAL,CAAqBrB,OAAOsB,SAAP,CAAiBI,YAAtC,EAAoD,CAApD,CAAP;AACH;AACD;;;;;;;;uCAKe;AACX,mBAAO,KAAKL,eAAL,CAAqBrB,OAAOsB,SAAP,CAAiBK,YAAtC,EAAoD,CAApD,CAAP;AACH;AACD;;;;;;;;;;;mCAQWT,K,EAAOX,M,EAAQ;AACtB,iBAAKqB,gBAAL,CAAsB5B,OAAOsB,SAAP,CAAiBY,UAAvC,EAAmD,CAAnD,EAAsDhB,KAAtD,EAA6DX,MAA7D;AACA,mBAAO,IAAP;AACH;AACD;;;;;;;;;;;sCAQcW,K,EAAOX,M,EAAQ;AACzB,iBAAKqB,gBAAL,CAAsB5B,OAAOsB,SAAP,CAAiBa,aAAvC,EAAsD,CAAtD,EAAyDjB,KAAzD,EAAgEX,MAAhE;AACA,mBAAO,IAAP;AACH;AACD;;;;;;;;;;;sCAQcW,K,EAAOX,M,EAAQ;AACzB,iBAAKqB,gBAAL,CAAsB5B,OAAOsB,SAAP,CAAiBc,aAAvC,EAAsD,CAAtD,EAAyDlB,KAAzD,EAAgEX,MAAhE;AACA,mBAAO,IAAP;AACH;AACD;;;;;;;;;;;sCAQcW,K,EAAOX,M,EAAQ;AACzB,iBAAKqB,gBAAL,CAAsB5B,OAAOsB,SAAP,CAAiBe,aAAvC,EAAsD,CAAtD,EAAyDnB,KAAzD,EAAgEX,MAAhE;AACA,mBAAO,IAAP;AACH;AACD;;;;;;;;;;;sCAQcW,K,EAAOX,M,EAAQ;AACzB,iBAAKqB,gBAAL,CAAsB5B,OAAOsB,SAAP,CAAiBgB,aAAvC,EAAsD,CAAtD,EAAyDpB,KAAzD,EAAgEX,MAAhE;AACA,mBAAO,IAAP;AACH;AACD;AACA;;;;;;;;sCAKc;AACV,mBAAO,KAAKc,eAAL,CAAqBrB,OAAOsB,SAAP,CAAiBiB,WAAtC,EAAmD,CAAnD,CAAP;AACH;AACD;;;;;;;;sCAKc;AACV,mBAAO,KAAKlB,eAAL,CAAqBrB,OAAOsB,SAAP,CAAiBkB,WAAtC,EAAmD,CAAnD,CAAP;AACH;AACD;;;;;;;;;;;qCAQatB,K,EAAOX,M,EAAQ;AACxB,iBAAKqB,gBAAL,CAAsB5B,OAAOsB,SAAP,CAAiBmB,YAAvC,EAAqD,CAArD,EAAwDvB,KAAxD,EAA+DX,MAA/D;AACA,mBAAO,IAAP;AACH;AACD;;;;;;;;;;;qCAQaW,K,EAAOX,M,EAAQ;AACxB,iBAAKqB,gBAAL,CAAsB5B,OAAOsB,SAAP,CAAiBoB,YAAvC,EAAqD,CAArD,EAAwDxB,KAAxD,EAA+DX,MAA/D;AACA,mBAAO,IAAP;AACH;AACD;AACA;;;;;;;;uCAKe;AACX,mBAAO,KAAKc,eAAL,CAAqBrB,OAAOsB,SAAP,CAAiBqB,YAAtC,EAAoD,CAApD,CAAP;AACH;AACD;;;;;;;;uCAKe;AACX,mBAAO,KAAKtB,eAAL,CAAqBrB,OAAOsB,SAAP,CAAiBsB,YAAtC,EAAoD,CAApD,CAAP;AACH;AACD;;;;;;;;;;;sCAQc1B,K,EAAOX,M,EAAQ;AACzB,iBAAKqB,gBAAL,CAAsB5B,OAAOsB,SAAP,CAAiBuB,aAAvC,EAAsD,CAAtD,EAAyD3B,KAAzD,EAAgEX,MAAhE;AACA,mBAAO,IAAP;AACH;AACD;;;;;;;;;;;sCAQcW,K,EAAOX,M,EAAQ;AACzB,iBAAKqB,gBAAL,CAAsB5B,OAAOsB,SAAP,CAAiBwB,aAAvC,EAAsD,CAAtD,EAAyD5B,KAAzD,EAAgEX,MAAhE;AACA,mBAAO,IAAP;AACH;AACD;AACA;;;;;;;;;;;mCAQWf,M,EAAQC,Q,EAAU;AACzB,gBAAMsD,YAAYpC,KAAKqC,GAAL,CAASxD,MAAT,EAAiB,KAAKA,MAAL,GAAc,KAAKG,UAApC,KAAmD,KAAKH,MAAL,GAAc,KAAKG,UAAxF;AACA,gBAAMuB,QAAQ,KAAKnB,IAAL,CAAUkD,KAAV,CAAgB,KAAKtD,UAArB,EAAiC,KAAKA,UAAL,GAAkBoD,SAAnD,EAA8DG,QAA9D,CAAuEzD,YAAY,KAAKA,QAAxF,CAAd;AACA,iBAAKE,UAAL,IAAmBoD,SAAnB;AACA,mBAAO7B,KAAP;AACH;AACD;;;;;;;;;;oCAOYA,K,EAAO3B,I,EAAME,Q,EAAU;AAC/B,gBAAIe,YAAY,KAAKd,WAArB;AACA,gBAAIyD,cAAc,KAAK1D,QAAvB;AACA;AACA,gBAAI,OAAOF,IAAP,KAAgB,QAApB,EAA8B;AAC1BiB,4BAAYjB,IAAZ;AACH,aAFD,MAGK,IAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC/B,oBAAIS,OAAOG,UAAP,CAAkBZ,IAAlB,CAAJ,EAA6B;AACzB4D,kCAAc5D,IAAd;AACH,iBAFD,MAGK;AACD,0BAAM,IAAIW,KAAJ,CAAU,kGAAV,CAAN;AACH;AACJ;AACD;AACA,gBAAI,OAAOT,QAAP,KAAoB,QAAxB,EAAkC;AAC9B,oBAAIO,OAAOG,UAAP,CAAkBV,QAAlB,CAAJ,EAAiC;AAC7B0D,kCAAc1D,QAAd;AACH,iBAFD,MAGK;AACD,0BAAM,IAAIS,KAAJ,CAAU,kGAAV,CAAN;AACH;AACJ;AACD;AACA,gBAAMkD,aAAapD,OAAOoD,UAAP,CAAkBlC,KAAlB,EAAyBiC,WAAzB,CAAnB;AACA;AACA,iBAAK/B,eAAL,CAAqBgC,UAArB,EAAiC5C,SAAjC;AACA;AACA,iBAAKT,IAAL,CAAUsD,KAAV,CAAgBnC,KAAhB,EAAuBV,SAAvB,EAAkC4C,UAAlC,EAA8CD,WAA9C;AACA;AACA,iBAAKzD,WAAL,IAAoB0D,UAApB;AACA,mBAAO,IAAP;AACH;AACD;;;;;;;;;;qCAOa3D,Q,EAAU;AACnB;AACA,gBAAI6D,UAAU,KAAK9D,MAAnB;AACA;AACA,iBAAK,IAAI+D,IAAI,KAAK5D,UAAlB,EAA8B4D,IAAI,KAAK/D,MAAvC,EAA+C+D,GAA/C,EAAoD;AAChD,oBAAI,KAAKxD,IAAL,CAAUwD,CAAV,MAAiB,IAArB,EAA2B;AACvBD,8BAAUC,CAAV;AACA;AACH;AACJ;AACD;AACA,gBAAMrC,QAAQ,KAAKnB,IAAL,CAAUkD,KAAV,CAAgB,KAAKtD,UAArB,EAAiC2D,OAAjC,CAAd;AACA;AACA,iBAAK3D,UAAL,GAAkB2D,UAAU,CAA5B;AACA,mBAAOpC,MAAMgC,QAAN,CAAezD,YAAY,KAAKA,QAAhC,CAAP;AACH;AACD;;;;;;;;;;sCAOcyB,K,EAAOX,M,EAAQd,Q,EAAU;AACnC;AACA,iBAAK+D,WAAL,CAAiBtC,KAAjB,EAAwBX,MAAxB,EAAgCd,QAAhC;AACA,iBAAKyC,UAAL,CAAgB,IAAhB,EAAuB,OAAO3B,MAAP,KAAkB,QAAlB,GAA6BA,SAASW,MAAM1B,MAA5C,GAAqD,KAAKE,WAAjF;AACH;AACD;AACA;;;;;;;;;;mCAOWF,M,EAAQ;AACf,gBAAMuD,YAAY,OAAOvD,MAAP,KAAkB,QAAlB,GAA6BA,MAA7B,GAAsC,KAAKA,MAA7D;AACA,gBAAMiE,WAAW9C,KAAKqC,GAAL,CAAS,KAAKxD,MAAd,EAAsB,KAAKG,UAAL,GAAkBoD,SAAxC,CAAjB;AACA;AACA,gBAAM7B,QAAQ,KAAKnB,IAAL,CAAUkD,KAAV,CAAgB,KAAKtD,UAArB,EAAiC8D,QAAjC,CAAd;AACA;AACA,iBAAK9D,UAAL,GAAkB8D,QAAlB;AACA,mBAAOvC,KAAP;AACH;AACD;;;;;;;;;oCAMYA,K,EAAOX,M,EAAQ;AACvB,gBAAMC,YAAY,OAAOD,MAAP,KAAkB,QAAlB,GAA6BA,MAA7B,GAAsC,KAAKb,WAA7D;AACA;AACA,iBAAK0B,eAAL,CAAqBF,MAAM1B,MAA3B,EAAmCgB,SAAnC;AACA;AACAU,kBAAMR,IAAN,CAAW,KAAKX,IAAhB,EAAsBS,SAAtB;AACA;AACA,iBAAKd,WAAL,IAAoBwB,MAAM1B,MAA1B;AACA,mBAAO,IAAP;AACH;AACD;;;;;;;;uCAKe;AACX;AACA,gBAAI8D,UAAU,KAAK9D,MAAnB;AACA;AACA,iBAAK,IAAI+D,IAAI,KAAK5D,UAAlB,EAA8B4D,IAAI,KAAK/D,MAAvC,EAA+C+D,GAA/C,EAAoD;AAChD,oBAAI,KAAKxD,IAAL,CAAUwD,CAAV,MAAiB,IAArB,EAA2B;AACvBD,8BAAUC,CAAV;AACA;AACH;AACJ;AACD;AACA,gBAAMrC,QAAQ,KAAKnB,IAAL,CAAUkD,KAAV,CAAgB,KAAKtD,UAArB,EAAiC2D,OAAjC,CAAd;AACA;AACA,iBAAK3D,UAAL,GAAkB2D,UAAU,CAA5B;AACA,mBAAOpC,KAAP;AACH;AACD;;;;;;;;;sCAMcA,K,EAAOX,M,EAAQ;AACzB;AACA,iBAAKmD,WAAL,CAAiBxC,KAAjB,EAAwBX,MAAxB;AACA,iBAAK2B,UAAL,CAAgB,CAAhB,EAAoB,OAAO3B,MAAP,KAAkB,QAAlB,GAA6BA,SAASW,MAAM1B,MAA5C,GAAqD,KAAKE,WAA9E;AACA,mBAAO,IAAP;AACH;AACD;;;;;;gCAGQ;AACJ,iBAAKA,WAAL,GAAmB,CAAnB;AACA,iBAAKC,UAAL,GAAkB,CAAlB;AACA,iBAAKH,MAAL,GAAc,CAAd;AACH;AACD;;;;;;;;oCAKY;AACR,mBAAO,KAAKA,MAAL,GAAc,KAAKG,UAA1B;AACH;AACD;;;;;;;;6BAKKgE,M,EAAQ;AACT,gBAAI,KAAKhE,UAAL,GAAkBgE,MAAlB,GAA2B,KAAKnE,MAApC,EAA4C;AACxC,sBAAM,IAAIU,KAAJ,CAAU,+DAAV,CAAN;AACH;AACD,iBAAKP,UAAL,IAAmBgE,MAAnB;AACH;AACD;;;;;;;;+BAKOA,M,EAAQ;AACX,gBAAI,KAAKhE,UAAL,GAAkBgE,MAAlB,GAA2B,CAA/B,EAAkC;AAC9B,sBAAM,IAAIzD,KAAJ,CAAU,+DAAV,CAAN;AACH;AACD,iBAAKP,UAAL,IAAmBgE,MAAnB;AACH;AACD;;;;;;;;+BAKOC,Q,EAAU;AACb,iBAAKC,MAAL,CAAYD,QAAZ;AACH;AACD;;;;;;;;+BAKOA,Q,EAAU;AACb,gBAAIA,WAAW,KAAKpE,MAApB,EAA4B;AACxB,sBAAM,IAAIU,KAAJ,CAAU,+DAAV,CAAN;AACH;AACD,iBAAKP,UAAL,GAAkBiE,QAAlB;AACH;AACD;;;;;;;;mCAKW;AACP,mBAAO,KAAK7D,IAAL,CAAUkD,KAAV,CAAgB,CAAhB,EAAmB,KAAKzD,MAAxB,CAAP;AACH;AACD;;;;;;;;iCAKSC,Q,EAAU;AACf,gBAAM0D,cAAc,OAAO1D,QAAP,KAAoB,QAApB,GAA+BA,QAA/B,GAA0C,KAAKA,QAAnE;AACA,gBAAIO,OAAOG,UAAP,CAAkBgD,WAAlB,CAAJ,EAAoC;AAChC,uBAAO,KAAKpD,IAAL,CAAUmD,QAAV,CAAmBC,WAAnB,EAAgC,CAAhC,EAAmC,KAAK3D,MAAxC,CAAP;AACH,aAFD,MAGK;AACD,sBAAM,IAAIU,KAAJ,CAAU,kGAAV,CAAN;AACH;AACJ;AACD;;;;;;kCAGU;AACN,iBAAK4D,KAAL;AACH;AACD;;;;;;iCA7mBgBzD,I,EAAMZ,Q,EAAU;AAC5B,mBAAO,IAAI,IAAJ,CAAS;AACZY,sBAAMA,IADM;AAEZZ,0BAAUA;AAFE,aAAT,CAAP;AAIH;AACD;;;;;;;;;;;mCAQkBM,I,EAAMN,Q,EAAU;AAC9B,mBAAO,IAAI,IAAJ,CAAS;AACZM,sBAAMA,IADM;AAEZN,0BAAUA;AAFE,aAAT,CAAP;AAIH;AACD;;;;;;;;oCAKmBsE,O,EAAS;AACxB,mBAAO,IAAI,IAAJ,CAASA,OAAT,CAAP;AACH;;;6CAqlB2BA,O,EAAS;AACjC,gBAAMC,cAAcD,OAApB;AACA,mBAAOC,gBAAgBA,YAAYvE,QAAZ,KAAyBwE,SAAzB,IAAsCD,YAAY3D,IAAZ,KAAqB4D,SAA3D,IAAwED,YAAYjE,IAAZ,KAAqBkE,SAA7G,CAAP;AACH;;;;;;AAELC,OAAOC,OAAP,GAAiB9E,WAAjB;AACA","file":"smartbuffer.js","sourcesContent":["\"use strict\";\n// The default Buffer size if one is not provided.\nconst DEFAULT_SMARTBUFFER_SIZE = 4096;\n// The default string encoding to use for reading/writing strings. \nconst DEFAULT_SMARTBUFFER_ENCODING = 'utf8';\nclass SmartBuffer {\n    /**\n     * Creates a new SmartBuffer instance.\n     *\n     * @param arg1 { Number | BufferEncoding | Buffer | SmartBufferOptions }\n     * @param arg2 { BufferEncoding }\n     */\n    constructor(arg1, arg2) {\n        this.length = 0;\n        this.encoding = DEFAULT_SMARTBUFFER_ENCODING;\n        this.writeOffset = 0;\n        this.readOffset = 0;\n        // Initial buffer size provided\n        if (typeof arg1 === 'number') {\n            if (Number.isFinite(arg1) && Number.isInteger(arg1) && arg1 > 0) {\n                this.buff = Buffer.allocUnsafe(arg1);\n            }\n            else {\n                throw new Error('Invalid size provided. Size must be a valid integer greater than zero.');\n            }\n        }\n        else if (typeof arg1 === 'string') {\n            if (Buffer.isEncoding(arg1)) {\n                this.buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n                this.encoding = arg1;\n            }\n            else {\n                throw new Error('Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.');\n            }\n        }\n        else if (arg1 instanceof Buffer) {\n            this.buff = arg1;\n            this.length = arg1.length;\n        }\n        else if (SmartBuffer.isSmartBufferOptions(arg1)) {\n            // Checks for encoding\n            if (arg1.encoding) {\n                if (Buffer.isEncoding(arg1.encoding)) {\n                    this.encoding = arg1.encoding;\n                }\n                else {\n                    throw new Error('Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.');\n                }\n            }\n            // Checks for initial size length\n            if (arg1.size) {\n                if (Number.isFinite(arg1.size) && Number.isInteger(arg1.size) && arg1.size > 0) {\n                    this.buff = Buffer.allocUnsafe(arg1.size);\n                }\n                else {\n                    throw new Error('Invalid size provided. Size must be a valid integer greater than zero.');\n                }\n            }\n            else if (arg1.buff) {\n                if (arg1.buff instanceof Buffer) {\n                    this.buff = arg1.buff;\n                    this.length = arg1.buff.length;\n                }\n                else {\n                    throw new Error('Invalid buffer provided in SmartBufferOptions.');\n                }\n            }\n            else {\n                this.buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n            }\n        }\n        else if (typeof arg1 === 'object') {\n            throw new Error('Invalid object supplied to SmartBuffer constructor.');\n        }\n        else {\n            this.buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n        }\n        // Check for encoding (Buffer, Encoding) constructor.\n        if (typeof arg2 === 'string') {\n            if (Buffer.isEncoding(arg2)) {\n                this.encoding = arg2;\n            }\n            else {\n                throw new Error('Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.');\n            }\n        }\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.\n     *\n     * @param size { Number } The size of the internal Buffer.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */\n    static fromSize(size, encoding) {\n        return new this({\n            size: size,\n            encoding: encoding\n        });\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.\n     *\n     * @param buffer { Buffer } The Buffer to use as the internal Buffer value.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */\n    static fromBuffer(buff, encoding) {\n        return new this({\n            buff: buff,\n            encoding: encoding\n        });\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.\n     *\n     * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.\n     */\n    static fromOptions(options) {\n        return new this(options);\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to write data.\n     *\n     * @param minLength { Number } The minimum length of the data that needs to be written.\n     * @param offset { Number } The offset of the data to be written.\n     */\n    ensureWriteable(minLength, offset) {\n        const offsetVal = typeof offset === 'number' ? offset : 0;\n        // Ensure there is enough internal Buffer capacity.\n        this.ensureCapacity(this.length + minLength + offsetVal);\n        // If offset is provided, copy data into appropriate location in regards to the offset.\n        if (typeof offset === 'number') {\n            this.buff.copy(this.buff, offsetVal + minLength, offsetVal, this.buff.length);\n        }\n        // Adjust instance length.\n        this.length = Math.max(this.length + minLength, offsetVal + minLength);\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to write at least the given amount of data.\n     *\n     * @param minLength { Number } The minimum length of the data needs to be written.\n     */\n    ensureCapacity(minLength) {\n        const oldLength = this.buff.length;\n        if (minLength > oldLength) {\n            let data = this.buff;\n            let newLength = (oldLength * 3) / 2 + 1;\n            if (newLength < minLength) {\n                newLength = minLength;\n            }\n            this.buff = Buffer.allocUnsafe(newLength);\n            data.copy(this.buff, 0, 0, oldLength);\n        }\n    }\n    /**\n     * Reads a numeric number value using the provided function.\n     *\n     * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes read.\n     *\n     * @param { Number }\n     */\n    readNumberValue(func, byteSize) {\n        // Call Buffer.readXXXX();\n        const value = func.call(this.buff, this.readOffset);\n        // Adjust internal read offset\n        this.readOffset += byteSize;\n        return value;\n    }\n    /**\n     * Writes a numeric number value using the provided function.\n     *\n     * @param func { Function(offset: number, offset?) => number} The function to write data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes written.\n     * @param value { Number } The number value to write.\n     * @param offset { Number } the offset to write the number at.\n     *\n     */\n    writeNumberValue(func, byteSize, value, offset) {\n        const offsetVal = typeof offset === 'number' ? offset : this.writeOffset;\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this.ensureWriteable(byteSize, offset);\n        // Call buffer.writeXXXX();\n        func.call(this.buff, value, offsetVal);\n        // Adjusts internal write offset\n        this.writeOffset += byteSize;\n    }\n    // Signed integers\n    /**\n     * Reads an Int8 value from the current read position.\n     *\n     * @return { Number }\n     */\n    readInt8() {\n        return this.readNumberValue(Buffer.prototype.readUInt8, 1);\n    }\n    /**\n     * Reads an Int16BE value from the current read position.\n     *\n     * @return { Number }\n     */\n    readInt16BE() {\n        return this.readNumberValue(Buffer.prototype.readUInt16BE, 2);\n    }\n    /**\n     * Reads an Int16LE value from the current read position.\n     *\n     * @return { Number }\n     */\n    readInt16LE() {\n        return this.readNumberValue(Buffer.prototype.readUInt16LE, 2);\n    }\n    /**\n     * Reads an Int32BE value from the current read position.\n     *\n     * @return { Number }\n     */\n    readInt32BE() {\n        return this.readNumberValue(Buffer.prototype.readUInt32BE, 4);\n    }\n    /**\n     * Reads an Int32LE value from the current read position.\n     *\n     * @return { Number }\n     */\n    readInt32LE() {\n        return this.readNumberValue(Buffer.prototype.readUInt32LE, 4);\n    }\n    /**\n     * Writes an Int8 value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt8(value, offset) {\n        this.writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n        return this;\n    }\n    /**\n     * Writes an Int16BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt16BE(value, offset) {\n        this.writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n        return this;\n    }\n    /**\n     * Writes an Int16LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt16LE(value, offset) {\n        this.writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n        return this;\n    }\n    /**\n     * Writes an Int32BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt32BE(value, offset) {\n        this.writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n        return this;\n    }\n    /**\n     * Writes an Int32LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt32LE(value, offset) {\n        this.writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n        return this;\n    }\n    // Unsigned Integers\n    /**\n     * Reads an UInt8 value from the current read position.\n     *\n     * @return { Number }\n     */\n    readUInt8() {\n        return this.readNumberValue(Buffer.prototype.readUInt8, 1);\n    }\n    /**\n     * Reads an UInt16BE value from the current read position.\n     *\n     * @return { Number }\n     */\n    readUInt16BE() {\n        return this.readNumberValue(Buffer.prototype.readUInt16BE, 2);\n    }\n    /**\n     * Reads an UInt16LE value from the current read position.\n     *\n     * @return { Number }\n     */\n    readUInt16LE() {\n        return this.readNumberValue(Buffer.prototype.readUInt16LE, 2);\n    }\n    /**\n     * Reads an UInt32BE value from the current read position.\n     *\n     * @return { Number }\n     */\n    readUInt32BE() {\n        return this.readNumberValue(Buffer.prototype.readUInt32BE, 4);\n    }\n    /**\n     * Reads an UInt32LE value from the current read position.\n     *\n     * @return { Number }\n     */\n    readUInt32LE() {\n        return this.readNumberValue(Buffer.prototype.readUInt32LE, 4);\n    }\n    /**\n     * Writes an UInt8 value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt8(value, offset) {\n        this.writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n        return this;\n    }\n    /**\n     * Writes an UInt16BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt16BE(value, offset) {\n        this.writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n        return this;\n    }\n    /**\n     * Writes an UInt16LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt16LE(value, offset) {\n        this.writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n        return this;\n    }\n    /**\n     * Writes an UInt32BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt32BE(value, offset) {\n        this.writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n        return this;\n    }\n    /**\n     * Writes an UInt32LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt32LE(value, offset) {\n        this.writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n        return this;\n    }\n    // Floating Point\n    /**\n     * Reads an FloatBE value from the current read position.\n     *\n     * @return { Number }\n     */\n    readFloatBE() {\n        return this.readNumberValue(Buffer.prototype.readFloatBE, 4);\n    }\n    /**\n     * Reads an FloatLE value from the current read position.\n     *\n     * @return { Number }\n     */\n    readFloatLE() {\n        return this.readNumberValue(Buffer.prototype.readFloatLE, 4);\n    }\n    /**\n     * Writes a FloatBE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeFloatBE(value, offset) {\n        this.writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n        return this;\n    }\n    /**\n     * Writes a FloatLE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeFloatLE(value, offset) {\n        this.writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n        return this;\n    }\n    // Double Floating Point\n    /**\n     * Reads an DoublEBE value from the current read position.\n     *\n     * @return { Number }\n     */\n    readDoubleBE() {\n        return this.readNumberValue(Buffer.prototype.readDoubleBE, 8);\n    }\n    /**\n     * Reads an DoubleLE value from the current read position.\n     *\n     * @return { Number }\n     */\n    readDoubleLE() {\n        return this.readNumberValue(Buffer.prototype.readDoubleLE, 8);\n    }\n    /**\n     * Writes a DoubleBE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeDoubleBE(value, offset) {\n        this.writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n        return this;\n    }\n    /**\n     * Writes a DoubleLE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeDoubleLE(value, offset) {\n        this.writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n        return this;\n    }\n    // Strings\n    /**\n     * Reads a String from the current read position.\n     *\n     * @param length { Number } The number of bytes to read as a String.\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n     *\n     * @return { String }\n     */\n    readString(length, encoding) {\n        const lengthVal = Math.min(length, this.length - this.readOffset) || this.length - this.readOffset;\n        const value = this.buff.slice(this.readOffset, this.readOffset + lengthVal).toString(encoding || this.encoding);\n        this.readOffset += lengthVal;\n        return value;\n    }\n    /**\n     * Writes a String to the current write position.\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     */\n    writeString(value, arg2, encoding) {\n        let offsetVal = this.writeOffset;\n        let encodingVal = this.encoding;\n        // Check for offset\n        if (typeof arg2 === 'number') {\n            offsetVal = arg2;\n        }\n        else if (typeof arg2 === 'string') {\n            if (Buffer.isEncoding(arg2)) {\n                encodingVal = arg2;\n            }\n            else {\n                throw new Error('Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.');\n            }\n        }\n        // Check for encoding (third param)\n        if (typeof encoding === 'string') {\n            if (Buffer.isEncoding(encoding)) {\n                encodingVal = encoding;\n            }\n            else {\n                throw new Error('Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.');\n            }\n        }\n        // Calculate bytelength of string.\n        const byteLength = Buffer.byteLength(value, encodingVal);\n        // Ensure there is enough internal Buffer capacity.\n        this.ensureWriteable(byteLength, offsetVal);\n        // Write value\n        this.buff.write(value, offsetVal, byteLength, encodingVal);\n        // Increment internal Buffer write offset;\n        this.writeOffset += byteLength;\n        return this;\n    }\n    /**\n     * Reads a null-terminated String from the current read position.\n     *\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n     *\n     * @return { String }\n     */\n    readStringNT(encoding) {\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for (let i = this.readOffset; i < this.length; i++) {\n            if (this.buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read string value\n        const value = this.buff.slice(this.readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this.readOffset = nullPos + 1;\n        return value.toString(encoding || this.encoding);\n    }\n    /**\n     * Writes a null-terminated String to the current write position.\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     */\n    writeStringNT(value, offset, encoding) {\n        // Write Values\n        this.writeString(value, offset, encoding);\n        this.writeUInt8(0x00, (typeof offset === 'number' ? offset + value.length : this.writeOffset));\n    }\n    // Buffers\n    /**\n     * Reads a Buffer from the internal read position.\n     *\n     * @param length { Number } The length of data to read as a Buffer.\n     *\n     * @return { Buffer }\n     */\n    readBuffer(length) {\n        const lengthVal = typeof length === 'number' ? length : this.length;\n        const endPoint = Math.min(this.length, this.readOffset + lengthVal);\n        // Read buffer value\n        const value = this.buff.slice(this.readOffset, endPoint);\n        // Increment internal Buffer read offset\n        this.readOffset = endPoint;\n        return value;\n    }\n    /**\n     * Writes a Buffer to the current write position.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     */\n    writeBuffer(value, offset) {\n        const offsetVal = typeof offset === 'number' ? offset : this.writeOffset;\n        // Ensure there is enough internal Buffer capacity.\n        this.ensureWriteable(value.length, offsetVal);\n        // Write buffer value\n        value.copy(this.buff, offsetVal);\n        // Increment internal Buffer write offset\n        this.writeOffset += value.length;\n        return this;\n    }\n    /**\n     * Reads a null-terminated Buffer from the current read poisiton.\n     *\n     * @return { Buffer }\n     */\n    readBufferNT() {\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for (let i = this.readOffset; i < this.length; i++) {\n            if (this.buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read value\n        const value = this.buff.slice(this.readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this.readOffset = nullPos + 1;\n        return value;\n    }\n    /**\n     * Writes a null-terminated Buffer to the current write position.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     */\n    writeBufferNT(value, offset) {\n        // Write Values\n        this.writeBuffer(value, offset);\n        this.writeUInt8(0, (typeof offset === 'number' ? offset + value.length : this.writeOffset));\n        return this;\n    }\n    /**\n     * Clears the SmartBuffer instance to its original empty state.\n     */\n    clear() {\n        this.writeOffset = 0;\n        this.readOffset = 0;\n        this.length = 0;\n    }\n    /**\n     * Gets the remaining data left to be read from the SmartBuffer instance.\n     *\n     * @return { Number }\n     */\n    remaining() {\n        return this.length - this.readOffset;\n    }\n    /**\n     * Moves the read offset forward.\n     *\n     * @param amount { Number } The amount to move the read offset forward by.\n     */\n    skip(amount) {\n        if (this.readOffset + amount > this.length) {\n            throw new Error('Target position is beyond the bounds of the SmartBuffer size.');\n        }\n        this.readOffset += amount;\n    }\n    /**\n     * Moves the read offset backwards.\n     *\n     * @param amount { Number } The amount to move the read offset backwards by.\n     */\n    rewind(amount) {\n        if (this.readOffset - amount < 0) {\n            throw new Error('Target position is beyond the bounds of the SmartBuffer size.');\n        }\n        this.readOffset -= amount;\n    }\n    /**\n     * Moves the read offset to a specific position.\n     *\n     * @param position { Number } The position to move the read offset to.\n     */\n    skipTo(position) {\n        this.moveTo(position);\n    }\n    /**\n     * Moves the read offset to a specific position.\n     *\n     * @param position { Number } The position to move the read offset to.\n     */\n    moveTo(position) {\n        if (position > this.length) {\n            throw new Error('Target position is beyond the bounds of the SmartBuffer size.');\n        }\n        this.readOffset = position;\n    }\n    /**\n     * Gets the value of the internal managed Buffer\n     *\n     * @param { Buffer }\n     */\n    toBuffer() {\n        return this.buff.slice(0, this.length);\n    }\n    /**\n     * Gets the String value of the internal managed Buffer\n     *\n     * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).\n     */\n    toString(encoding) {\n        const encodingVal = typeof encoding === 'string' ? encoding : this.encoding;\n        if (Buffer.isEncoding(encodingVal)) {\n            return this.buff.toString(encodingVal, 0, this.length);\n        }\n        else {\n            throw new Error('Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.');\n        }\n    }\n    /**\n     * Destroys the SmartBuffer instance.\n     */\n    destroy() {\n        this.clear();\n    }\n    /**\n     * Type checking function that determines if an object is a SmartBufferOptions object.\n     */\n    static isSmartBufferOptions(options) {\n        const castOptions = options;\n        return castOptions && (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined);\n    }\n}\nmodule.exports = SmartBuffer;\n//# sourceMappingURL=smartbuffer.js.map"]}