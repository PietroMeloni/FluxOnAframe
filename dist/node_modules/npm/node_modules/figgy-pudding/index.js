'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FiggyPudding = function () {
  function FiggyPudding(specs, opts, providers) {
    _classCallCheck(this, FiggyPudding);

    this.__specs = specs || {};
    this.__opts = opts || function () {
      return false;
    };
    this.__providers = reverse((providers || []).filter(function (x) {
      return x != null && (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object';
    }));
    this.__isFiggyPudding = true;
  }

  _createClass(FiggyPudding, [{
    key: 'get',
    value: function get(key) {
      return pudGet(this, key, true);
    }
  }, {
    key: 'concat',
    value: function concat() {
      for (var _len = arguments.length, moreConfig = Array(_len), _key = 0; _key < _len; _key++) {
        moreConfig[_key] = arguments[_key];
      }

      return new FiggyPudding(this.__specs, this.__opts, reverse(this.__providers).concat(moreConfig));
    }
  }]);

  return FiggyPudding;
}();

function pudGet(pud, key, validate) {
  var spec = pud.__specs[key];
  if (typeof spec === 'string') {
    key = spec;
    spec = pud.__specs[key];
  }
  if (validate && !spec && (!pud.__opts.other || !pud.__opts.other(key))) {
    throw new Error('invalid config key requested: ' + key);
  } else {
    if (!spec) {
      spec = {};
    }
    var ret = void 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = pud.__providers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var p = _step.value;

        if (p.__isFiggyPudding) {
          ret = pudGet(p, key, false);
        } else if (typeof p.get === 'function') {
          ret = p.get(key);
        } else {
          ret = p[key];
        }
        if (ret !== undefined) {
          break;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (ret === undefined && spec.default !== undefined) {
      if (typeof spec.default === 'function') {
        return spec.default();
      } else {
        return spec.default;
      }
    } else {
      return ret;
    }
  }
}

var proxyHandler = {
  has: function has(obj, prop) {
    return pudGet(obj, prop, false) !== undefined;
  },
  get: function get(obj, prop) {
    if (prop === 'concat' || prop === 'get' || prop.slice(0, 2) === '__') {
      return obj[prop];
    }
    return obj.get(prop);
  },
  set: function set(obj, prop, value) {
    if (prop.slice(0, 2) === '__') {
      obj[prop] = value;
    } else {
      throw new Error('figgyPudding options cannot be modified. Use .concat() instead.');
    }
  },
  delete: function _delete() {
    throw new Error('figgyPudding options cannot be deleted. Use .concat() and shadow them instead.');
  }
};

module.exports = figgyPudding;
function figgyPudding(specs, opts) {
  function factory() {
    for (var _len2 = arguments.length, providers = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      providers[_key2] = arguments[_key2];
    }

    return new Proxy(new FiggyPudding(specs, opts, providers), proxyHandler);
  }
  return factory;
}

function reverse(arr) {
  var ret = [];
  arr.forEach(function (x) {
    return ret.unshift(x);
  });
  return ret;
}
//# sourceMappingURL=index.js.map