'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var fetch = require('make-fetch-happen').defaults({ retry: false });
var validate = require('aproba');
var url = require('url');
var os = require('os');

exports.adduserCouch = adduserCouch;
exports.loginCouch = loginCouch;
exports.adduserWeb = adduserWeb;
exports.loginWeb = loginWeb;
exports.login = login;
exports.adduser = adduser;
exports.get = get;
exports.set = set;
exports.listTokens = listTokens;
exports.removeToken = removeToken;
exports.createToken = createToken;

// try loginWeb, catch the "not supported" message and fall back to couch
function login(opener, prompter, conf) {
  validate('FFO', arguments);
  return loginWeb(opener, conf).catch(function (er) {
    if (er instanceof WebLoginNotSupported) {
      process.emit('log', 'verbose', 'web login not supported, trying couch');
      return prompter(conf.creds).then(function (data) {
        return loginCouch(data.username, data.password, conf);
      });
    } else {
      throw er;
    }
  });
}

function adduser(opener, prompter, conf) {
  validate('FFO', arguments);
  return adduserWeb(opener, conf).catch(function (er) {
    if (er instanceof WebLoginNotSupported) {
      process.emit('log', 'verbose', 'web adduser not supported, trying couch');
      return prompter(conf.creds).then(function (data) {
        return adduserCouch(data.username, data.email, data.password, conf);
      });
    } else {
      throw er;
    }
  });
}

function adduserWeb(opener, conf) {
  validate('FO', arguments);
  var body = { create: true };
  process.emit('log', 'verbose', 'web adduser', 'before first POST');
  return webAuth(opener, conf, body);
}

function loginWeb(opener, conf) {
  validate('FO', arguments);
  process.emit('log', 'verbose', 'web login', 'before first POST');
  return webAuth(opener, conf, {});
}

function webAuth(opener, conf, body) {
  if (!conf.opts) conf.opts = {};
  var target = url.resolve(conf.registry, '-/v1/login');
  body.hostname = conf.hostname || os.hostname();
  return fetchJSON({
    target: target,
    method: 'POST',
    body: body,
    opts: conf.opts,
    saveResponse: true
  }).then(function (result) {
    var res = result[0];
    var content = result[1];
    process.emit('log', 'verbose', 'web auth', 'got response', content);
    var doneUrl = content.doneUrl;
    var loginUrl = content.loginUrl;
    if (typeof doneUrl !== 'string' || typeof loginUrl !== 'string' || !doneUrl || !loginUrl) {
      throw new WebLoginInvalidResponse('POST', target, res, content);
    }
    process.emit('log', 'verbose', 'web auth', 'opening url pair');
    var doneConf = {
      target: doneUrl,
      method: 'GET',
      opts: conf.opts,
      saveResponse: true
    };
    return opener(loginUrl).then(function () {
      return fetchJSON(doneConf);
    }).then(onDone);
    function onDone(result) {
      var res = result[0];
      var content = result[1];
      if (res.status === 200) {
        if (!content.token) {
          throw new WebLoginInvalidResponse('GET', doneUrl, res, content);
        } else {
          return content;
        }
      } else if (res.status === 202) {
        var retry = +res.headers.get('retry-after');
        if (retry > 0) {
          return new Promise(function (resolve) {
            return setTimeout(resolve, 1000 * retry);
          }).then(function () {
            return fetchJSON(doneConf);
          }).then(onDone);
        } else {
          return fetchJSON(doneConf).then(onDone);
        }
      } else {
        throw new WebLoginInvalidResponse('GET', doneUrl, res, content);
      }
    }
  }).catch(function (er) {
    if (er.statusCode >= 400 && er.statusCode <= 499 || er.statusCode === 500) {
      throw new WebLoginNotSupported('POST', target, {
        status: er.statusCode,
        headers: { raw: function raw() {
            return er.headers;
          } }
      }, er.body);
    } else {
      throw er;
    }
  });
}

function adduserCouch(username, email, password, conf) {
  validate('SSSO', arguments);
  if (!conf.opts) conf.opts = {};
  var userobj = {
    _id: 'org.couchdb.user:' + username,
    name: username,
    password: password,
    email: email,
    type: 'user',
    roles: [],
    date: new Date().toISOString()
  };
  var logObj = {};
  Object.keys(userobj).forEach(function (k) {
    logObj[k] = k === 'password' ? 'XXXXX' : userobj[k];
  });
  process.emit('log', 'verbose', 'adduser', 'before first PUT', logObj);

  var target = url.resolve(conf.registry, '-/user/org.couchdb.user:' + encodeURIComponent(username));

  return fetchJSON({ target: target, method: 'PUT', body: userobj, opts: conf.opts }).then(function (result) {
    result.username = username;
    return result;
  });
}

function loginCouch(username, password, conf) {
  validate('SSO', arguments);
  var userobj = {
    _id: 'org.couchdb.user:' + username,
    name: username,
    password: password,
    type: 'user',
    roles: [],
    date: new Date().toISOString()
  };
  var logObj = {};
  Object.keys(userobj).forEach(function (k) {
    logObj[k] = k === 'password' ? 'XXXXX' : userobj[k];
  });
  process.emit('log', 'verbose', 'login', 'before first PUT', logObj);

  var target = url.resolve(conf.registry, '-/user/org.couchdb.user:' + encodeURIComponent(username));
  return fetchJSON(Object.assign({ method: 'PUT', target: target, body: userobj }, conf)).catch(function (err) {
    if (err.code === 'E400') {
      err.message = 'There is no user with the username "' + username + '".';
      throw err;
    }
    if (err.code !== 'E409') throw err;
    return fetchJSON(Object.assign({ method: 'GET', target: target + '?write=true' }, conf)).then(function (result) {
      Object.keys(result).forEach(function (k) {
        if (!userobj[k] || k === 'roles') {
          userobj[k] = result[k];
        }
      });
      var req = {
        method: 'PUT',
        target: target + '/-rev/' + userobj._rev,
        body: userobj,
        auth: {
          basic: {
            username: username,
            password: password
          }
        }
      };
      return fetchJSON(Object.assign({}, conf, req));
    });
  }).then(function (result) {
    result.username = username;
    return result;
  });
}

function get(conf) {
  validate('O', arguments);
  var target = url.resolve(conf.registry, '-/npm/v1/user');
  return fetchJSON(Object.assign({ target: target }, conf));
}

function set(profile, conf) {
  validate('OO', arguments);
  var target = url.resolve(conf.registry, '-/npm/v1/user');
  Object.keys(profile).forEach(function (key) {
    // profile keys can't be empty strings, but they CAN be null
    if (profile[key] === '') profile[key] = null;
  });
  return fetchJSON(Object.assign({ target: target, method: 'POST', body: profile }, conf));
}

function listTokens(conf) {
  validate('O', arguments);

  return untilLastPage('-/npm/v1/tokens');

  function untilLastPage(href, objects) {
    return fetchJSON(Object.assign({ target: url.resolve(conf.registry, href) }, conf)).then(function (result) {
      objects = objects ? objects.concat(result.objects) : result.objects;
      if (result.urls.next) {
        return untilLastPage(result.urls.next, objects);
      } else {
        return objects;
      }
    });
  }
}

function removeToken(tokenKey, conf) {
  validate('SO', arguments);
  var target = url.resolve(conf.registry, '-/npm/v1/tokens/token/' + tokenKey);
  return fetchJSON(Object.assign({ target: target, method: 'DELETE' }, conf));
}

function createToken(password, readonly, cidrs, conf) {
  validate('SBAO', arguments);
  var target = url.resolve(conf.registry, '-/npm/v1/tokens');
  var props = {
    password: password,
    readonly: readonly,
    cidr_whitelist: cidrs
  };
  return fetchJSON(Object.assign({ target: target, method: 'POST', body: props }, conf));
}

function FetchError(err, method, target) {
  err.method = method;
  err.href = target;
  return err;
}

var HttpErrorBase = function (_Error) {
  _inherits(HttpErrorBase, _Error);

  function HttpErrorBase(method, target, res, body) {
    _classCallCheck(this, HttpErrorBase);

    var _this = _possibleConstructorReturn(this, (HttpErrorBase.__proto__ || Object.getPrototypeOf(HttpErrorBase)).call(this));

    _this.headers = res.headers.raw();
    _this.statusCode = res.status;
    _this.code = 'E' + res.status;
    _this.method = method;
    _this.target = target;
    _this.body = body;
    _this.pkgid = packageName(target);
    return _this;
  }

  return HttpErrorBase;
}(Error);

var HttpErrorGeneral = function (_HttpErrorBase) {
  _inherits(HttpErrorGeneral, _HttpErrorBase);

  function HttpErrorGeneral(method, target, res, body) {
    _classCallCheck(this, HttpErrorGeneral);

    var _this2 = _possibleConstructorReturn(this, (HttpErrorGeneral.__proto__ || Object.getPrototypeOf(HttpErrorGeneral)).call(this, method, target, res, body));

    if (body && body.error) {
      _this2.message = 'Registry returned ' + _this2.statusCode + ' for ' + _this2.method + ' on ' + _this2.target + ': ' + body.error;
    } else {
      _this2.message = 'Registry returned ' + _this2.statusCode + ' for ' + _this2.method + ' on ' + _this2.target;
    }
    Error.captureStackTrace(_this2, HttpErrorGeneral);
    return _this2;
  }

  return HttpErrorGeneral;
}(HttpErrorBase);

var WebLoginInvalidResponse = function (_HttpErrorBase2) {
  _inherits(WebLoginInvalidResponse, _HttpErrorBase2);

  function WebLoginInvalidResponse(method, target, res, body) {
    _classCallCheck(this, WebLoginInvalidResponse);

    var _this3 = _possibleConstructorReturn(this, (WebLoginInvalidResponse.__proto__ || Object.getPrototypeOf(WebLoginInvalidResponse)).call(this, method, target, res, body));

    _this3.message = 'Invalid response from web login endpoint';
    Error.captureStackTrace(_this3, WebLoginInvalidResponse);
    return _this3;
  }

  return WebLoginInvalidResponse;
}(HttpErrorBase);

var WebLoginNotSupported = function (_HttpErrorBase3) {
  _inherits(WebLoginNotSupported, _HttpErrorBase3);

  function WebLoginNotSupported(method, target, res, body) {
    _classCallCheck(this, WebLoginNotSupported);

    var _this4 = _possibleConstructorReturn(this, (WebLoginNotSupported.__proto__ || Object.getPrototypeOf(WebLoginNotSupported)).call(this, method, target, res, body));

    _this4.message = 'Web login not supported';
    _this4.code = 'ENYI';
    Error.captureStackTrace(_this4, WebLoginNotSupported);
    return _this4;
  }

  return WebLoginNotSupported;
}(HttpErrorBase);

var HttpErrorAuthOTP = function (_HttpErrorBase4) {
  _inherits(HttpErrorAuthOTP, _HttpErrorBase4);

  function HttpErrorAuthOTP(method, target, res, body) {
    _classCallCheck(this, HttpErrorAuthOTP);

    var _this5 = _possibleConstructorReturn(this, (HttpErrorAuthOTP.__proto__ || Object.getPrototypeOf(HttpErrorAuthOTP)).call(this, method, target, res, body));

    _this5.message = 'OTP required for authentication';
    _this5.code = 'EOTP';
    Error.captureStackTrace(_this5, HttpErrorAuthOTP);
    return _this5;
  }

  return HttpErrorAuthOTP;
}(HttpErrorBase);

var HttpErrorAuthIPAddress = function (_HttpErrorBase5) {
  _inherits(HttpErrorAuthIPAddress, _HttpErrorBase5);

  function HttpErrorAuthIPAddress(method, target, res, body) {
    _classCallCheck(this, HttpErrorAuthIPAddress);

    var _this6 = _possibleConstructorReturn(this, (HttpErrorAuthIPAddress.__proto__ || Object.getPrototypeOf(HttpErrorAuthIPAddress)).call(this, method, target, res, body));

    _this6.message = 'Login is not allowed from your IP address';
    _this6.code = 'EAUTHIP';
    Error.captureStackTrace(_this6, HttpErrorAuthIPAddress);
    return _this6;
  }

  return HttpErrorAuthIPAddress;
}(HttpErrorBase);

var HttpErrorAuthUnknown = function (_HttpErrorBase6) {
  _inherits(HttpErrorAuthUnknown, _HttpErrorBase6);

  function HttpErrorAuthUnknown(method, target, res, body) {
    _classCallCheck(this, HttpErrorAuthUnknown);

    var _this7 = _possibleConstructorReturn(this, (HttpErrorAuthUnknown.__proto__ || Object.getPrototypeOf(HttpErrorAuthUnknown)).call(this, method, target, res, body));

    _this7.message = 'Unable to authenticate, need: ' + res.headers.get('www-authenticate');
    _this7.code = 'EAUTHUNKNOWN';
    Error.captureStackTrace(_this7, HttpErrorAuthUnknown);
    return _this7;
  }

  return HttpErrorAuthUnknown;
}(HttpErrorBase);

function authHeaders(auth) {
  var headers = {};
  if (!auth) return headers;
  if (auth.otp) headers['npm-otp'] = auth.otp;
  if (auth.token) {
    headers['Authorization'] = 'Bearer ' + auth.token;
  } else if (auth.basic) {
    var basic = auth.basic.username + ':' + auth.basic.password;
    headers['Authorization'] = 'Basic ' + Buffer.from(basic).toString('base64');
  }
  return headers;
}

function fetchJSON(conf) {
  var fetchOpts = {
    method: conf.method,
    headers: Object.assign({}, conf.headers || conf.auth && authHeaders(conf.auth) || {})
  };
  if (conf.body != null) {
    fetchOpts.headers['Content-Type'] = 'application/json';
    fetchOpts.body = JSON.stringify(conf.body);
  }
  process.emit('log', 'http', 'request', '→', conf.method || 'GET', conf.target);
  return fetch.defaults(conf.opts || {})(conf.target, fetchOpts).catch(function (err) {
    throw new FetchError(err, conf.method, conf.target);
  }).then(function (res) {
    if (res.headers.has('npm-notice')) {
      process.emit('warn', 'notice', res.headers.get('npm-notice'));
    }
    if (res.headers.get('content-type') === 'application/json') {
      return res.json().then(function (content) {
        return [res, content];
      });
    } else {
      return res.buffer().then(function (content) {
        try {
          return [res, JSON.parse(content)];
        } catch (_) {
          return [res, content];
        }
      });
    }
  }).then(function (result) {
    var res = result[0];
    var content = result[1];
    var retVal = conf.saveResponse ? result : content;
    process.emit('log', 'http', res.status, '\u2190 ' + res.statusText + ' (' + conf.target + ')');
    if (res.status === 401 && res.headers.get('www-authenticate')) {
      var auth = res.headers.get('www-authenticate').split(/,\s*/).map(function (s) {
        return s.toLowerCase();
      });
      if (auth.indexOf('ipaddress') !== -1) {
        throw new HttpErrorAuthIPAddress(conf.method, conf.target, res, content);
      } else if (auth.indexOf('otp') !== -1) {
        throw new HttpErrorAuthOTP(conf.method, conf.target, res, content);
      } else {
        throw new HttpErrorAuthUnknown(conf.method, conf.target, res, content);
      }
    } else if (res.status < 200 || res.status >= 300) {
      throw new HttpErrorGeneral(conf.method, conf.target, res, content);
    } else {
      return retVal;
    }
  });
}

function packageName(href) {
  try {
    var basePath = url.parse(href).pathname.substr(1);
    if (!basePath.match(/^-/)) {
      basePath = basePath.split('/');
      var index = basePath.indexOf('_rewrite');
      if (index === -1) {
        index = basePath.length - 1;
      } else {
        index++;
      }
      return decodeURIComponent(basePath[index]);
    }
  } catch (_) {
    // this is ok
  }
}
//# sourceMappingURL=index.js.map