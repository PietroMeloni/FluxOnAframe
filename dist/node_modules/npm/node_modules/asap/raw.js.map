{"version":3,"sources":["../../../../../node_modules/npm/node_modules/asap/raw.js"],"names":["domain","hasSetImmediate","setImmediate","module","exports","rawAsap","task","queue","length","requestFlush","flushing","index","capacity","flush","currentIndex","call","scan","newLength","parentDomain","process","require","active","nextTick"],"mappings":"AAAA;;AAEA,IAAIA,MAAJ,C,CAAY;AACZ,IAAIC,kBAAkB,OAAOC,YAAP,KAAwB,UAA9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,OAAOC,OAAP,GAAiBC,OAAjB;AACA,SAASA,OAAT,CAAiBC,IAAjB,EAAuB;AACnB,QAAI,CAACC,MAAMC,MAAX,EAAmB;AACfC;AACAC,mBAAW,IAAX;AACH;AACD;AACAH,UAAMA,MAAMC,MAAZ,IAAsBF,IAAtB;AACH;;AAED,IAAIC,QAAQ,EAAZ;AACA;AACA;AACA,IAAIG,WAAW,KAAf;AACA;AACA;AACA;AACA,IAAIC,QAAQ,CAAZ;AACA;AACA;AACA;AACA,IAAIC,WAAW,IAAf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,KAAT,GAAiB;AACb,WAAOF,QAAQJ,MAAMC,MAArB,EAA6B;AACzB,YAAIM,eAAeH,KAAnB;AACA;AACA;AACAA,gBAAQA,QAAQ,CAAhB;AACAJ,cAAMO,YAAN,EAAoBC,IAApB;AACA;AACA;AACA;AACA;AACA;AACA,YAAIJ,QAAQC,QAAZ,EAAsB;AAClB;AACA;AACA,iBAAK,IAAII,OAAO,CAAX,EAAcC,YAAYV,MAAMC,MAAN,GAAeG,KAA9C,EAAqDK,OAAOC,SAA5D,EAAuED,MAAvE,EAA+E;AAC3ET,sBAAMS,IAAN,IAAcT,MAAMS,OAAOL,KAAb,CAAd;AACH;AACDJ,kBAAMC,MAAN,IAAgBG,KAAhB;AACAA,oBAAQ,CAAR;AACH;AACJ;AACDJ,UAAMC,MAAN,GAAe,CAAf;AACAG,YAAQ,CAAR;AACAD,eAAW,KAAX;AACH;;AAEDL,QAAQI,YAAR,GAAuBA,YAAvB;AACA,SAASA,YAAT,GAAwB;AACpB;AACA;AACA;AACA,QAAIS,eAAeC,QAAQnB,MAA3B;AACA,QAAIkB,YAAJ,EAAkB;AACd,YAAI,CAAClB,MAAL,EAAa;AACT;AACA;AACAA,qBAASoB,QAAQ,QAAR,CAAT;AACH;AACDpB,eAAOqB,MAAP,GAAgBF,QAAQnB,MAAR,GAAiB,IAAjC;AACH;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,QAAIU,YAAYT,eAAhB,EAAiC;AAC7BC,qBAAaW,KAAb;AACH,KAFD,MAEO;AACHM,gBAAQG,QAAR,CAAiBT,KAAjB;AACH;;AAED,QAAIK,YAAJ,EAAkB;AACdlB,eAAOqB,MAAP,GAAgBF,QAAQnB,MAAR,GAAiBkB,YAAjC;AACH;AACJ","file":"raw.js","sourcesContent":["\"use strict\";\n\nvar domain; // The domain module is executed on demand\nvar hasSetImmediate = typeof setImmediate === \"function\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including network IO events in Node.js.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Avoids a function call\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory excaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\nrawAsap.requestFlush = requestFlush;\nfunction requestFlush() {\n    // Ensure flushing is not bound to any domain.\n    // It is not sufficient to exit the domain, because domains exist on a stack.\n    // To execute code outside of any domain, the following dance is necessary.\n    var parentDomain = process.domain;\n    if (parentDomain) {\n        if (!domain) {\n            // Lazy execute the domain module.\n            // Only employed if the user elects to use domains.\n            domain = require(\"domain\");\n        }\n        domain.active = process.domain = null;\n    }\n\n    // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`\n    // cannot handle recursion.\n    // `requestFlush` will only be called recursively from `asap.js`, to resume\n    // flushing after an error is thrown into a domain.\n    // Conveniently, `setImmediate` was introduced in the same version\n    // `process.nextTick` started throwing recursion errors.\n    if (flushing && hasSetImmediate) {\n        setImmediate(flush);\n    } else {\n        process.nextTick(flush);\n    }\n\n    if (parentDomain) {\n        domain.active = process.domain = parentDomain;\n    }\n}\n"]}