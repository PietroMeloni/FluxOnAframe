'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = deprecate;

var assert = require('assert');
var semver = require('semver');

function deprecate(uri, params, cb) {
  assert(typeof uri === 'string', 'must pass registry URI to deprecate');
  assert(params && (typeof params === 'undefined' ? 'undefined' : _typeof(params)) === 'object', 'must pass params to deprecate');
  assert(typeof cb === 'function', 'must pass callback to deprecate');

  assert(typeof params.version === 'string', 'must pass version to deprecate');
  assert(typeof params.message === 'string', 'must pass message to deprecate');
  assert(params.auth && _typeof(params.auth) === 'object', 'must pass auth to deprecate');

  var version = params.version;
  var message = params.message;
  var auth = params.auth;

  if (semver.validRange(version) === null) {
    return cb(new Error('invalid version range: ' + version));
  }

  this.get(uri + '?write=true', { auth: auth }, function (er, data) {
    if (er) return cb(er);
    // filter all the versions that match
    Object.keys(data.versions).filter(function (v) {
      return semver.satisfies(v, version);
    }).forEach(function (v) {
      data.versions[v].deprecated = message;
    });
    // now update the doc on the registry
    var options = {
      method: 'PUT',
      body: data,
      auth: auth
    };
    this.request(uri, options, cb);
  }.bind(this));
}
//# sourceMappingURL=deprecate.js.map