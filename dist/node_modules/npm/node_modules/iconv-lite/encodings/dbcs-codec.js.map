{"version":3,"sources":["../../../../../../node_modules/npm/node_modules/iconv-lite/encodings/dbcs-codec.js"],"names":["Buffer","require","exports","_dbcs","DBCSCodec","UNASSIGNED","GB18030_CODE","SEQ_START","NODE_START","UNASSIGNED_NODE","Array","DEF_CHAR","i","codecOptions","iconv","encodingName","Error","table","mappingTable","decodeTables","slice","decodeTableSeq","length","_addDecodeChunk","defaultCharUnicode","encodeTable","encodeTableSeq","skipEncodeChars","encodeSkipVals","val","j","from","to","_fillEncodeTable","encodeAdd","uChar","Object","prototype","hasOwnProperty","call","_setEncodeChar","charCodeAt","defCharSB","defaultCharSingleByte","gb18030","thirdByteNodeIdx","thirdByteNode","fourthByteNodeIdx","fourthByteNode","secondByteNodeIdx","secondByteNode","encoder","DBCSEncoder","decoder","DBCSDecoder","_getDecodeTrieNode","addr","bytes","push","node","toString","chunk","curAddr","parseInt","writeTable","k","part","l","code","codeTrail","len","seq","m","charCode","_getEncodeBucket","uCode","high","undefined","dbcsCode","bucket","low","_setEncodeSequence","oldVal","nodeIdx","prefix","mbCode","options","codec","leadSurrogate","seqObj","write","str","newBuf","alloc","nextChar","resCode","subtable","idx","findIdx","uChars","gbChars","Math","floor","end","prevBuf","buf","prevBufOffset","seqStart","concat","curByte","curSeq","ptr","uCodeLead","ret","r","mid"],"mappings":"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","file":"dbcs-codec.js","sourcesContent":["\"use strict\";\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.\n// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.\n// To save memory and loading time, we read table files only when requested.\n\nexports._dbcs = DBCSCodec;\n\nvar UNASSIGNED = -1,\n    GB18030_CODE = -2,\n    SEQ_START  = -10,\n    NODE_START = -1000,\n    UNASSIGNED_NODE = new Array(0x100),\n    DEF_CHAR = -1;\n\nfor (var i = 0; i < 0x100; i++)\n    UNASSIGNED_NODE[i] = UNASSIGNED;\n\n\n// Class DBCSCodec reads and initializes mapping tables.\nfunction DBCSCodec(codecOptions, iconv) {\n    this.encodingName = codecOptions.encodingName;\n    if (!codecOptions)\n        throw new Error(\"DBCS codec is called without the data.\")\n    if (!codecOptions.table)\n        throw new Error(\"Encoding '\" + this.encodingName + \"' has no data.\");\n\n    // Load tables.\n    var mappingTable = codecOptions.table();\n\n\n    // Decode tables: MBCS -> Unicode.\n\n    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.\n    // Trie root is decodeTables[0].\n    // Values: >=  0 -> unicode character code. can be > 0xFFFF\n    //         == UNASSIGNED -> unknown/unassigned sequence.\n    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.\n    //         <= NODE_START -> index of the next node in our trie to process next byte.\n    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.\n    this.decodeTables = [];\n    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.\n\n    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. \n    this.decodeTableSeq = [];\n\n    // Actual mapping tables consist of chunks. Use them to fill up decode tables.\n    for (var i = 0; i < mappingTable.length; i++)\n        this._addDecodeChunk(mappingTable[i]);\n\n    this.defaultCharUnicode = iconv.defaultCharUnicode;\n\n    \n    // Encode tables: Unicode -> DBCS.\n\n    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.\n    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.\n    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).\n    //         == UNASSIGNED -> no conversion found. Output a default char.\n    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.\n    this.encodeTable = [];\n    \n    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of\n    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key\n    // means end of sequence (needed when one sequence is a strict subsequence of another).\n    // Objects are kept separately from encodeTable to increase performance.\n    this.encodeTableSeq = [];\n\n    // Some chars can be decoded, but need not be encoded.\n    var skipEncodeChars = {};\n    if (codecOptions.encodeSkipVals)\n        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {\n            var val = codecOptions.encodeSkipVals[i];\n            if (typeof val === 'number')\n                skipEncodeChars[val] = true;\n            else\n                for (var j = val.from; j <= val.to; j++)\n                    skipEncodeChars[j] = true;\n        }\n        \n    // Use decode trie to recursively fill out encode tables.\n    this._fillEncodeTable(0, 0, skipEncodeChars);\n\n    // Add more encoding pairs when needed.\n    if (codecOptions.encodeAdd) {\n        for (var uChar in codecOptions.encodeAdd)\n            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))\n                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);\n    }\n\n    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];\n    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];\n    if (this.defCharSB === UNASSIGNED) this.defCharSB = \"?\".charCodeAt(0);\n\n\n    // Load & create GB18030 tables when needed.\n    if (typeof codecOptions.gb18030 === 'function') {\n        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.\n\n        // Add GB18030 decode tables.\n        var thirdByteNodeIdx = this.decodeTables.length;\n        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n\n        var fourthByteNodeIdx = this.decodeTables.length;\n        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n\n        for (var i = 0x81; i <= 0xFE; i++) {\n            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];\n            var secondByteNode = this.decodeTables[secondByteNodeIdx];\n            for (var j = 0x30; j <= 0x39; j++)\n                secondByteNode[j] = NODE_START - thirdByteNodeIdx;\n        }\n        for (var i = 0x81; i <= 0xFE; i++)\n            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;\n        for (var i = 0x30; i <= 0x39; i++)\n            fourthByteNode[i] = GB18030_CODE\n    }        \n}\n\nDBCSCodec.prototype.encoder = DBCSEncoder;\nDBCSCodec.prototype.decoder = DBCSDecoder;\n\n// Decoder helpers\nDBCSCodec.prototype._getDecodeTrieNode = function(addr) {\n    var bytes = [];\n    for (; addr > 0; addr >>= 8)\n        bytes.push(addr & 0xFF);\n    if (bytes.length == 0)\n        bytes.push(0);\n\n    var node = this.decodeTables[0];\n    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.\n        var val = node[bytes[i]];\n\n        if (val == UNASSIGNED) { // Create new node.\n            node[bytes[i]] = NODE_START - this.decodeTables.length;\n            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));\n        }\n        else if (val <= NODE_START) { // Existing node.\n            node = this.decodeTables[NODE_START - val];\n        }\n        else\n            throw new Error(\"Overwrite byte in \" + this.encodingName + \", addr: \" + addr.toString(16));\n    }\n    return node;\n}\n\n\nDBCSCodec.prototype._addDecodeChunk = function(chunk) {\n    // First element of chunk is the hex mbcs code where we start.\n    var curAddr = parseInt(chunk[0], 16);\n\n    // Choose the decoding node where we'll write our chars.\n    var writeTable = this._getDecodeTrieNode(curAddr);\n    curAddr = curAddr & 0xFF;\n\n    // Write all other elements of the chunk to the table.\n    for (var k = 1; k < chunk.length; k++) {\n        var part = chunk[k];\n        if (typeof part === \"string\") { // String, write as-is.\n            for (var l = 0; l < part.length;) {\n                var code = part.charCodeAt(l++);\n                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate\n                    var codeTrail = part.charCodeAt(l++);\n                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)\n                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);\n                    else\n                        throw new Error(\"Incorrect surrogate pair in \"  + this.encodingName + \" at chunk \" + chunk[0]);\n                }\n                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)\n                    var len = 0xFFF - code + 2;\n                    var seq = [];\n                    for (var m = 0; m < len; m++)\n                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.\n\n                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;\n                    this.decodeTableSeq.push(seq);\n                }\n                else\n                    writeTable[curAddr++] = code; // Basic char\n            }\n        } \n        else if (typeof part === \"number\") { // Integer, meaning increasing sequence starting with prev character.\n            var charCode = writeTable[curAddr - 1] + 1;\n            for (var l = 0; l < part; l++)\n                writeTable[curAddr++] = charCode++;\n        }\n        else\n            throw new Error(\"Incorrect type '\" + typeof part + \"' given in \"  + this.encodingName + \" at chunk \" + chunk[0]);\n    }\n    if (curAddr > 0xFF)\n        throw new Error(\"Incorrect chunk in \"  + this.encodingName + \" at addr \" + chunk[0] + \": too long\" + curAddr);\n}\n\n// Encoder helpers\nDBCSCodec.prototype._getEncodeBucket = function(uCode) {\n    var high = uCode >> 8; // This could be > 0xFF because of astral characters.\n    if (this.encodeTable[high] === undefined)\n        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.\n    return this.encodeTable[high];\n}\n\nDBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {\n    var bucket = this._getEncodeBucket(uCode);\n    var low = uCode & 0xFF;\n    if (bucket[low] <= SEQ_START)\n        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.\n    else if (bucket[low] == UNASSIGNED)\n        bucket[low] = dbcsCode;\n}\n\nDBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {\n    \n    // Get the root of character tree according to first character of the sequence.\n    var uCode = seq[0];\n    var bucket = this._getEncodeBucket(uCode);\n    var low = uCode & 0xFF;\n\n    var node;\n    if (bucket[low] <= SEQ_START) {\n        // There's already a sequence with  - use it.\n        node = this.encodeTableSeq[SEQ_START-bucket[low]];\n    }\n    else {\n        // There was no sequence object - allocate a new one.\n        node = {};\n        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.\n        bucket[low] = SEQ_START - this.encodeTableSeq.length;\n        this.encodeTableSeq.push(node);\n    }\n\n    // Traverse the character tree, allocating new nodes as needed.\n    for (var j = 1; j < seq.length-1; j++) {\n        var oldVal = node[uCode];\n        if (typeof oldVal === 'object')\n            node = oldVal;\n        else {\n            node = node[uCode] = {}\n            if (oldVal !== undefined)\n                node[DEF_CHAR] = oldVal\n        }\n    }\n\n    // Set the leaf to given dbcsCode.\n    uCode = seq[seq.length-1];\n    node[uCode] = dbcsCode;\n}\n\nDBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {\n    var node = this.decodeTables[nodeIdx];\n    for (var i = 0; i < 0x100; i++) {\n        var uCode = node[i];\n        var mbCode = prefix + i;\n        if (skipEncodeChars[mbCode])\n            continue;\n\n        if (uCode >= 0)\n            this._setEncodeChar(uCode, mbCode);\n        else if (uCode <= NODE_START)\n            this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);\n        else if (uCode <= SEQ_START)\n            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);\n    }\n}\n\n\n\n// == Encoder ==================================================================\n\nfunction DBCSEncoder(options, codec) {\n    // Encoder state\n    this.leadSurrogate = -1;\n    this.seqObj = undefined;\n    \n    // Static data\n    this.encodeTable = codec.encodeTable;\n    this.encodeTableSeq = codec.encodeTableSeq;\n    this.defaultCharSingleByte = codec.defCharSB;\n    this.gb18030 = codec.gb18030;\n}\n\nDBCSEncoder.prototype.write = function(str) {\n    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),\n        leadSurrogate = this.leadSurrogate,\n        seqObj = this.seqObj, nextChar = -1,\n        i = 0, j = 0;\n\n    while (true) {\n        // 0. Get next character.\n        if (nextChar === -1) {\n            if (i == str.length) break;\n            var uCode = str.charCodeAt(i++);\n        }\n        else {\n            var uCode = nextChar;\n            nextChar = -1;    \n        }\n\n        // 1. Handle surrogates.\n        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.\n            if (uCode < 0xDC00) { // We've got lead surrogate.\n                if (leadSurrogate === -1) {\n                    leadSurrogate = uCode;\n                    continue;\n                } else {\n                    leadSurrogate = uCode;\n                    // Double lead surrogate found.\n                    uCode = UNASSIGNED;\n                }\n            } else { // We've got trail surrogate.\n                if (leadSurrogate !== -1) {\n                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);\n                    leadSurrogate = -1;\n                } else {\n                    // Incomplete surrogate pair - only trail surrogate found.\n                    uCode = UNASSIGNED;\n                }\n                \n            }\n        }\n        else if (leadSurrogate !== -1) {\n            // Incomplete surrogate pair - only lead surrogate found.\n            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.\n            leadSurrogate = -1;\n        }\n\n        // 2. Convert uCode character.\n        var dbcsCode = UNASSIGNED;\n        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence\n            var resCode = seqObj[uCode];\n            if (typeof resCode === 'object') { // Sequence continues.\n                seqObj = resCode;\n                continue;\n\n            } else if (typeof resCode == 'number') { // Sequence finished. Write it.\n                dbcsCode = resCode;\n\n            } else if (resCode == undefined) { // Current character is not part of the sequence.\n\n                // Try default character for this sequence\n                resCode = seqObj[DEF_CHAR];\n                if (resCode !== undefined) {\n                    dbcsCode = resCode; // Found. Write it.\n                    nextChar = uCode; // Current character will be written too in the next iteration.\n\n                } else {\n                    // TODO: What if we have no default? (resCode == undefined)\n                    // Then, we should write first char of the sequence as-is and try the rest recursively.\n                    // Didn't do it for now because no encoding has this situation yet.\n                    // Currently, just skip the sequence and write current char.\n                }\n            }\n            seqObj = undefined;\n        }\n        else if (uCode >= 0) {  // Regular character\n            var subtable = this.encodeTable[uCode >> 8];\n            if (subtable !== undefined)\n                dbcsCode = subtable[uCode & 0xFF];\n            \n            if (dbcsCode <= SEQ_START) { // Sequence start\n                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];\n                continue;\n            }\n\n            if (dbcsCode == UNASSIGNED && this.gb18030) {\n                // Use GB18030 algorithm to find character(s) to write.\n                var idx = findIdx(this.gb18030.uChars, uCode);\n                if (idx != -1) {\n                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);\n                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;\n                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;\n                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;\n                    newBuf[j++] = 0x30 + dbcsCode;\n                    continue;\n                }\n            }\n        }\n\n        // 3. Write dbcsCode character.\n        if (dbcsCode === UNASSIGNED)\n            dbcsCode = this.defaultCharSingleByte;\n        \n        if (dbcsCode < 0x100) {\n            newBuf[j++] = dbcsCode;\n        }\n        else if (dbcsCode < 0x10000) {\n            newBuf[j++] = dbcsCode >> 8;   // high byte\n            newBuf[j++] = dbcsCode & 0xFF; // low byte\n        }\n        else {\n            newBuf[j++] = dbcsCode >> 16;\n            newBuf[j++] = (dbcsCode >> 8) & 0xFF;\n            newBuf[j++] = dbcsCode & 0xFF;\n        }\n    }\n\n    this.seqObj = seqObj;\n    this.leadSurrogate = leadSurrogate;\n    return newBuf.slice(0, j);\n}\n\nDBCSEncoder.prototype.end = function() {\n    if (this.leadSurrogate === -1 && this.seqObj === undefined)\n        return; // All clean. Most often case.\n\n    var newBuf = Buffer.alloc(10), j = 0;\n\n    if (this.seqObj) { // We're in the sequence.\n        var dbcsCode = this.seqObj[DEF_CHAR];\n        if (dbcsCode !== undefined) { // Write beginning of the sequence.\n            if (dbcsCode < 0x100) {\n                newBuf[j++] = dbcsCode;\n            }\n            else {\n                newBuf[j++] = dbcsCode >> 8;   // high byte\n                newBuf[j++] = dbcsCode & 0xFF; // low byte\n            }\n        } else {\n            // See todo above.\n        }\n        this.seqObj = undefined;\n    }\n\n    if (this.leadSurrogate !== -1) {\n        // Incomplete surrogate pair - only lead surrogate found.\n        newBuf[j++] = this.defaultCharSingleByte;\n        this.leadSurrogate = -1;\n    }\n    \n    return newBuf.slice(0, j);\n}\n\n// Export for testing\nDBCSEncoder.prototype.findIdx = findIdx;\n\n\n// == Decoder ==================================================================\n\nfunction DBCSDecoder(options, codec) {\n    // Decoder state\n    this.nodeIdx = 0;\n    this.prevBuf = Buffer.alloc(0);\n\n    // Static data\n    this.decodeTables = codec.decodeTables;\n    this.decodeTableSeq = codec.decodeTableSeq;\n    this.defaultCharUnicode = codec.defaultCharUnicode;\n    this.gb18030 = codec.gb18030;\n}\n\nDBCSDecoder.prototype.write = function(buf) {\n    var newBuf = Buffer.alloc(buf.length*2),\n        nodeIdx = this.nodeIdx, \n        prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,\n        seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.\n        uCode;\n\n    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.\n        prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);\n    \n    for (var i = 0, j = 0; i < buf.length; i++) {\n        var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];\n\n        // Lookup in current trie node.\n        var uCode = this.decodeTables[nodeIdx][curByte];\n\n        if (uCode >= 0) { \n            // Normal character, just use it.\n        }\n        else if (uCode === UNASSIGNED) { // Unknown char.\n            // TODO: Callback with seq.\n            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);\n            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).\n            uCode = this.defaultCharUnicode.charCodeAt(0);\n        }\n        else if (uCode === GB18030_CODE) {\n            var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);\n            var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);\n            var idx = findIdx(this.gb18030.gbChars, ptr);\n            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];\n        }\n        else if (uCode <= NODE_START) { // Go to next trie node.\n            nodeIdx = NODE_START - uCode;\n            continue;\n        }\n        else if (uCode <= SEQ_START) { // Output a sequence of chars.\n            var seq = this.decodeTableSeq[SEQ_START - uCode];\n            for (var k = 0; k < seq.length - 1; k++) {\n                uCode = seq[k];\n                newBuf[j++] = uCode & 0xFF;\n                newBuf[j++] = uCode >> 8;\n            }\n            uCode = seq[seq.length-1];\n        }\n        else\n            throw new Error(\"iconv-lite internal error: invalid decoding table value \" + uCode + \" at \" + nodeIdx + \"/\" + curByte);\n\n        // Write the character to buffer, handling higher planes using surrogate pair.\n        if (uCode > 0xFFFF) { \n            uCode -= 0x10000;\n            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);\n            newBuf[j++] = uCodeLead & 0xFF;\n            newBuf[j++] = uCodeLead >> 8;\n\n            uCode = 0xDC00 + uCode % 0x400;\n        }\n        newBuf[j++] = uCode & 0xFF;\n        newBuf[j++] = uCode >> 8;\n\n        // Reset trie node.\n        nodeIdx = 0; seqStart = i+1;\n    }\n\n    this.nodeIdx = nodeIdx;\n    this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);\n    return newBuf.slice(0, j).toString('ucs2');\n}\n\nDBCSDecoder.prototype.end = function() {\n    var ret = '';\n\n    // Try to parse all remaining chars.\n    while (this.prevBuf.length > 0) {\n        // Skip 1 character in the buffer.\n        ret += this.defaultCharUnicode;\n        var buf = this.prevBuf.slice(1);\n\n        // Parse remaining as usual.\n        this.prevBuf = Buffer.alloc(0);\n        this.nodeIdx = 0;\n        if (buf.length > 0)\n            ret += this.write(buf);\n    }\n\n    this.nodeIdx = 0;\n    return ret;\n}\n\n// Binary search for GB18030. Returns largest i such that table[i] <= val.\nfunction findIdx(table, val) {\n    if (table[0] > val)\n        return -1;\n\n    var l = 0, r = table.length;\n    while (l < r-1) { // always table[l] <= val < table[r]\n        var mid = l + Math.floor((r-l+1)/2);\n        if (table[mid] <= val)\n            l = mid;\n        else\n            r = mid;\n    }\n    return l;\n}\n\n"]}