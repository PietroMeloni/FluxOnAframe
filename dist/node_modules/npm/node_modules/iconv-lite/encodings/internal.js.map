{"version":3,"sources":["../../../../../../node_modules/npm/node_modules/iconv-lite/encodings/internal.js"],"names":["Buffer","require","module","exports","utf8","type","bomAware","cesu8","unicode11utf8","ucs2","utf16le","binary","base64","hex","_internal","InternalCodec","codecOptions","iconv","enc","encodingName","encoder","InternalEncoderBase64","InternalEncoderCesu8","from","toString","decoder","InternalDecoderCesu8","defaultCharUnicode","prototype","InternalEncoder","InternalDecoder","StringDecoder","end","options","codec","call","write","str","prevStr","completeQuads","length","slice","buf","alloc","bufIdx","i","charCode","charCodeAt","acc","contBytes","accBytes","res","curByte","String","fromCharCode"],"mappings":"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","file":"internal.js","sourcesContent":["\"use strict\";\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// Export Node.js internal encodings.\n\nmodule.exports = {\n    // Encodings\n    utf8:   { type: \"_internal\", bomAware: true},\n    cesu8:  { type: \"_internal\", bomAware: true},\n    unicode11utf8: \"utf8\",\n\n    ucs2:   { type: \"_internal\", bomAware: true},\n    utf16le: \"ucs2\",\n\n    binary: { type: \"_internal\" },\n    base64: { type: \"_internal\" },\n    hex:    { type: \"_internal\" },\n\n    // Codec.\n    _internal: InternalCodec,\n};\n\n//------------------------------------------------------------------------------\n\nfunction InternalCodec(codecOptions, iconv) {\n    this.enc = codecOptions.encodingName;\n    this.bomAware = codecOptions.bomAware;\n\n    if (this.enc === \"base64\")\n        this.encoder = InternalEncoderBase64;\n    else if (this.enc === \"cesu8\") {\n        this.enc = \"utf8\"; // Use utf8 for decoding.\n        this.encoder = InternalEncoderCesu8;\n\n        // Add decoder for versions of Node not supporting CESU-8\n        if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== 'ðŸ’©') {\n            this.decoder = InternalDecoderCesu8;\n            this.defaultCharUnicode = iconv.defaultCharUnicode;\n        }\n    }\n}\n\nInternalCodec.prototype.encoder = InternalEncoder;\nInternalCodec.prototype.decoder = InternalDecoder;\n\n//------------------------------------------------------------------------------\n\n// We use node.js internal decoder. Its signature is the same as ours.\nvar StringDecoder = require('string_decoder').StringDecoder;\n\nif (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.\n    StringDecoder.prototype.end = function() {};\n\n\nfunction InternalDecoder(options, codec) {\n    StringDecoder.call(this, codec.enc);\n}\n\nInternalDecoder.prototype = StringDecoder.prototype;\n\n\n//------------------------------------------------------------------------------\n// Encoder is mostly trivial\n\nfunction InternalEncoder(options, codec) {\n    this.enc = codec.enc;\n}\n\nInternalEncoder.prototype.write = function(str) {\n    return Buffer.from(str, this.enc);\n}\n\nInternalEncoder.prototype.end = function() {\n}\n\n\n//------------------------------------------------------------------------------\n// Except base64 encoder, which must keep its state.\n\nfunction InternalEncoderBase64(options, codec) {\n    this.prevStr = '';\n}\n\nInternalEncoderBase64.prototype.write = function(str) {\n    str = this.prevStr + str;\n    var completeQuads = str.length - (str.length % 4);\n    this.prevStr = str.slice(completeQuads);\n    str = str.slice(0, completeQuads);\n\n    return Buffer.from(str, \"base64\");\n}\n\nInternalEncoderBase64.prototype.end = function() {\n    return Buffer.from(this.prevStr, \"base64\");\n}\n\n\n//------------------------------------------------------------------------------\n// CESU-8 encoder is also special.\n\nfunction InternalEncoderCesu8(options, codec) {\n}\n\nInternalEncoderCesu8.prototype.write = function(str) {\n    var buf = Buffer.alloc(str.length * 3), bufIdx = 0;\n    for (var i = 0; i < str.length; i++) {\n        var charCode = str.charCodeAt(i);\n        // Naive implementation, but it works because CESU-8 is especially easy\n        // to convert from UTF-16 (which all JS strings are encoded in).\n        if (charCode < 0x80)\n            buf[bufIdx++] = charCode;\n        else if (charCode < 0x800) {\n            buf[bufIdx++] = 0xC0 + (charCode >>> 6);\n            buf[bufIdx++] = 0x80 + (charCode & 0x3f);\n        }\n        else { // charCode will always be < 0x10000 in javascript.\n            buf[bufIdx++] = 0xE0 + (charCode >>> 12);\n            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);\n            buf[bufIdx++] = 0x80 + (charCode & 0x3f);\n        }\n    }\n    return buf.slice(0, bufIdx);\n}\n\nInternalEncoderCesu8.prototype.end = function() {\n}\n\n//------------------------------------------------------------------------------\n// CESU-8 decoder is not implemented in Node v4.0+\n\nfunction InternalDecoderCesu8(options, codec) {\n    this.acc = 0;\n    this.contBytes = 0;\n    this.accBytes = 0;\n    this.defaultCharUnicode = codec.defaultCharUnicode;\n}\n\nInternalDecoderCesu8.prototype.write = function(buf) {\n    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, \n        res = '';\n    for (var i = 0; i < buf.length; i++) {\n        var curByte = buf[i];\n        if ((curByte & 0xC0) !== 0x80) { // Leading byte\n            if (contBytes > 0) { // Previous code is invalid\n                res += this.defaultCharUnicode;\n                contBytes = 0;\n            }\n\n            if (curByte < 0x80) { // Single-byte code\n                res += String.fromCharCode(curByte);\n            } else if (curByte < 0xE0) { // Two-byte code\n                acc = curByte & 0x1F;\n                contBytes = 1; accBytes = 1;\n            } else if (curByte < 0xF0) { // Three-byte code\n                acc = curByte & 0x0F;\n                contBytes = 2; accBytes = 1;\n            } else { // Four or more are not supported for CESU-8.\n                res += this.defaultCharUnicode;\n            }\n        } else { // Continuation byte\n            if (contBytes > 0) { // We're waiting for it.\n                acc = (acc << 6) | (curByte & 0x3f);\n                contBytes--; accBytes++;\n                if (contBytes === 0) {\n                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)\n                    if (accBytes === 2 && acc < 0x80 && acc > 0)\n                        res += this.defaultCharUnicode;\n                    else if (accBytes === 3 && acc < 0x800)\n                        res += this.defaultCharUnicode;\n                    else\n                        // Actually add character.\n                        res += String.fromCharCode(acc);\n                }\n            } else { // Unexpected continuation byte\n                res += this.defaultCharUnicode;\n            }\n        }\n    }\n    this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;\n    return res;\n}\n\nInternalDecoderCesu8.prototype.end = function() {\n    var res = 0;\n    if (this.contBytes > 0)\n        res += this.defaultCharUnicode;\n    return res;\n}\n"]}