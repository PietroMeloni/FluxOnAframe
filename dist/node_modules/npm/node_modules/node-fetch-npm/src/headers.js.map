{"version":3,"sources":["../../../../../../node_modules/npm/node_modules/node-fetch-npm/src/headers.js"],"names":["common","require","checkInvalidHeaderChar","checkIsHttpToken","sanitizeName","name","TypeError","toLowerCase","sanitizeValue","value","MAP","Symbol","Headers","init","Object","create","rawHeaders","raw","headerNames","keys","headerName","append","method","iterator","pairs","pair","push","Array","from","length","key","defineProperty","toStringTag","writable","enumerable","configurable","list","join","callback","thisArg","getHeaderPairs","i","call","has","set","createHeadersIterator","prototype","entries","headers","kind","sort","map","k","get","INTERNAL","target","HeadersIteratorPrototype","index","setPrototypeOf","next","getPrototypeOf","values","len","undefined","done","result","module","exports"],"mappings":"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","file":"headers.js","sourcesContent":["'use strict'\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst common = require('./common.js')\nconst checkInvalidHeaderChar = common.checkInvalidHeaderChar\nconst checkIsHttpToken = common.checkIsHttpToken\n\nfunction sanitizeName (name) {\n  name += ''\n  if (!checkIsHttpToken(name)) {\n    throw new TypeError(`${name} is not a legal HTTP header name`)\n  }\n  return name.toLowerCase()\n}\n\nfunction sanitizeValue (value) {\n  value += ''\n  if (checkInvalidHeaderChar(value)) {\n    throw new TypeError(`${value} is not a legal HTTP header value`)\n  }\n  return value\n}\n\nconst MAP = Symbol('map')\nclass Headers {\n  /**\n   * Headers class\n   *\n   * @param   Object  headers  Response headers\n   * @return  Void\n   */\n  constructor (init) {\n    this[MAP] = Object.create(null)\n\n    if (init instanceof Headers) {\n      const rawHeaders = init.raw()\n      const headerNames = Object.keys(rawHeaders)\n\n      for (const headerName of headerNames) {\n        for (const value of rawHeaders[headerName]) {\n          this.append(headerName, value)\n        }\n      }\n\n      return\n    }\n\n    // We don't worry about converting prop to ByteString here as append()\n    // will handle it.\n    if (init == null) {\n      // no op\n    } else if (typeof init === 'object') {\n      const method = init[Symbol.iterator]\n      if (method != null) {\n        if (typeof method !== 'function') {\n          throw new TypeError('Header pairs must be iterable')\n        }\n\n        // sequence<sequence<ByteString>>\n        // Note: per spec we have to first exhaust the lists then process them\n        const pairs = []\n        for (const pair of init) {\n          if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n            throw new TypeError('Each header pair must be iterable')\n          }\n          pairs.push(Array.from(pair))\n        }\n\n        for (const pair of pairs) {\n          if (pair.length !== 2) {\n            throw new TypeError('Each header pair must be a name/value tuple')\n          }\n          this.append(pair[0], pair[1])\n        }\n      } else {\n        // record<ByteString, ByteString>\n        for (const key of Object.keys(init)) {\n          const value = init[key]\n          this.append(key, value)\n        }\n      }\n    } else {\n      throw new TypeError('Provided initializer must be an object')\n    }\n\n    Object.defineProperty(this, Symbol.toStringTag, {\n      value: 'Headers',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    })\n  }\n\n  /**\n   * Return first header value given name\n   *\n   * @param   String  name  Header name\n   * @return  Mixed\n   */\n  get (name) {\n    const list = this[MAP][sanitizeName(name)]\n    if (!list) {\n      return null\n    }\n\n    return list.join(', ')\n  }\n\n  /**\n   * Iterate over all headers\n   *\n   * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n   * @param   Boolean   thisArg   `this` context for callback function\n   * @return  Void\n   */\n  forEach (callback, thisArg) {\n    let pairs = getHeaderPairs(this)\n    let i = 0\n    while (i < pairs.length) {\n      const name = pairs[i][0]\n      const value = pairs[i][1]\n      callback.call(thisArg, value, name, this)\n      pairs = getHeaderPairs(this)\n      i++\n    }\n  }\n\n  /**\n   * Overwrite header values given name\n   *\n   * @param   String  name   Header name\n   * @param   String  value  Header value\n   * @return  Void\n   */\n  set (name, value) {\n    this[MAP][sanitizeName(name)] = [sanitizeValue(value)]\n  }\n\n  /**\n   * Append a value onto existing header\n   *\n   * @param   String  name   Header name\n   * @param   String  value  Header value\n   * @return  Void\n   */\n  append (name, value) {\n    if (!this.has(name)) {\n      this.set(name, value)\n      return\n    }\n\n    this[MAP][sanitizeName(name)].push(sanitizeValue(value))\n  }\n\n  /**\n   * Check for header name existence\n   *\n   * @param   String   name  Header name\n   * @return  Boolean\n   */\n  has (name) {\n    return !!this[MAP][sanitizeName(name)]\n  }\n\n  /**\n   * Delete all header values given name\n   *\n   * @param   String  name  Header name\n   * @return  Void\n   */\n  delete (name) {\n    delete this[MAP][sanitizeName(name)]\n  };\n\n  /**\n   * Return raw headers (non-spec api)\n   *\n   * @return  Object\n   */\n  raw () {\n    return this[MAP]\n  }\n\n  /**\n   * Get an iterator on keys.\n   *\n   * @return  Iterator\n   */\n  keys () {\n    return createHeadersIterator(this, 'key')\n  }\n\n  /**\n   * Get an iterator on values.\n   *\n   * @return  Iterator\n   */\n  values () {\n    return createHeadersIterator(this, 'value')\n  }\n\n  /**\n   * Get an iterator on entries.\n   *\n   * This is the default iterator of the Headers object.\n   *\n   * @return  Iterator\n   */\n  [Symbol.iterator] () {\n    return createHeadersIterator(this, 'key+value')\n  }\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator]\n\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n  value: 'HeadersPrototype',\n  writable: false,\n  enumerable: false,\n  configurable: true\n})\n\nfunction getHeaderPairs (headers, kind) {\n  const keys = Object.keys(headers[MAP]).sort()\n  return keys.map(\n    kind === 'key'\n      ? k => [k]\n      : k => [k, headers.get(k)]\n  )\n}\n\nconst INTERNAL = Symbol('internal')\n\nfunction createHeadersIterator (target, kind) {\n  const iterator = Object.create(HeadersIteratorPrototype)\n  iterator[INTERNAL] = {\n    target,\n    kind,\n    index: 0\n  }\n  return iterator\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n  next () {\n    // istanbul ignore if\n    if (!this ||\n      Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n      throw new TypeError('Value of `this` is not a HeadersIterator')\n    }\n\n    const target = this[INTERNAL].target\n    const kind = this[INTERNAL].kind\n    const index = this[INTERNAL].index\n    const values = getHeaderPairs(target, kind)\n    const len = values.length\n    if (index >= len) {\n      return {\n        value: undefined,\n        done: true\n      }\n    }\n\n    const pair = values[index]\n    this[INTERNAL].index = index + 1\n\n    let result\n    if (kind === 'key') {\n      result = pair[0]\n    } else if (kind === 'value') {\n      result = pair[1]\n    } else {\n      result = pair\n    }\n\n    return {\n      value: result,\n      done: false\n    }\n  }\n}, Object.getPrototypeOf(\n  Object.getPrototypeOf([][Symbol.iterator]())\n))\n\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n  value: 'HeadersIterator',\n  writable: false,\n  enumerable: false,\n  configurable: true\n})\n\nmodule.exports = Headers\n"]}