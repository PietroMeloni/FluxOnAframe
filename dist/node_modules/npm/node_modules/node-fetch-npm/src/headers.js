'use strict';

/**
 * headers.js
 *
 * Headers class offers convenient helpers
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var common = require('./common.js');
var checkInvalidHeaderChar = common.checkInvalidHeaderChar;
var checkIsHttpToken = common.checkIsHttpToken;

function sanitizeName(name) {
  name += '';
  if (!checkIsHttpToken(name)) {
    throw new TypeError(name + ' is not a legal HTTP header name');
  }
  return name.toLowerCase();
}

function sanitizeValue(value) {
  value += '';
  if (checkInvalidHeaderChar(value)) {
    throw new TypeError(value + ' is not a legal HTTP header value');
  }
  return value;
}

var MAP = Symbol('map');

var Headers = function () {
  /**
   * Headers class
   *
   * @param   Object  headers  Response headers
   * @return  Void
   */
  function Headers(init) {
    _classCallCheck(this, Headers);

    this[MAP] = Object.create(null);

    if (init instanceof Headers) {
      var rawHeaders = init.raw();
      var headerNames = Object.keys(rawHeaders);

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = headerNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var headerName = _step.value;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = rawHeaders[headerName][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var value = _step2.value;

              this.append(headerName, value);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return;
    }

    // We don't worry about converting prop to ByteString here as append()
    // will handle it.
    if (init == null) {
      // no op
    } else if ((typeof init === 'undefined' ? 'undefined' : _typeof(init)) === 'object') {
      var method = init[Symbol.iterator];
      if (method != null) {
        if (typeof method !== 'function') {
          throw new TypeError('Header pairs must be iterable');
        }

        // sequence<sequence<ByteString>>
        // Note: per spec we have to first exhaust the lists then process them
        var pairs = [];
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = init[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var pair = _step3.value;

            if ((typeof pair === 'undefined' ? 'undefined' : _typeof(pair)) !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
              throw new TypeError('Each header pair must be iterable');
            }
            pairs.push(Array.from(pair));
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = pairs[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var _pair = _step4.value;

            if (_pair.length !== 2) {
              throw new TypeError('Each header pair must be a name/value tuple');
            }
            this.append(_pair[0], _pair[1]);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      } else {
        // record<ByteString, ByteString>
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = Object.keys(init)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var key = _step5.value;

            var _value = init[key];
            this.append(key, _value);
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5.return) {
              _iterator5.return();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }
      }
    } else {
      throw new TypeError('Provided initializer must be an object');
    }

    Object.defineProperty(this, Symbol.toStringTag, {
      value: 'Headers',
      writable: false,
      enumerable: false,
      configurable: true
    });
  }

  /**
   * Return first header value given name
   *
   * @param   String  name  Header name
   * @return  Mixed
   */


  _createClass(Headers, [{
    key: 'get',
    value: function get(name) {
      var list = this[MAP][sanitizeName(name)];
      if (!list) {
        return null;
      }

      return list.join(', ');
    }

    /**
     * Iterate over all headers
     *
     * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
     * @param   Boolean   thisArg   `this` context for callback function
     * @return  Void
     */

  }, {
    key: 'forEach',
    value: function forEach(callback, thisArg) {
      var pairs = getHeaderPairs(this);
      var i = 0;
      while (i < pairs.length) {
        var name = pairs[i][0];
        var value = pairs[i][1];
        callback.call(thisArg, value, name, this);
        pairs = getHeaderPairs(this);
        i++;
      }
    }

    /**
     * Overwrite header values given name
     *
     * @param   String  name   Header name
     * @param   String  value  Header value
     * @return  Void
     */

  }, {
    key: 'set',
    value: function set(name, value) {
      this[MAP][sanitizeName(name)] = [sanitizeValue(value)];
    }

    /**
     * Append a value onto existing header
     *
     * @param   String  name   Header name
     * @param   String  value  Header value
     * @return  Void
     */

  }, {
    key: 'append',
    value: function append(name, value) {
      if (!this.has(name)) {
        this.set(name, value);
        return;
      }

      this[MAP][sanitizeName(name)].push(sanitizeValue(value));
    }

    /**
     * Check for header name existence
     *
     * @param   String   name  Header name
     * @return  Boolean
     */

  }, {
    key: 'has',
    value: function has(name) {
      return !!this[MAP][sanitizeName(name)];
    }

    /**
     * Delete all header values given name
     *
     * @param   String  name  Header name
     * @return  Void
     */

  }, {
    key: 'delete',
    value: function _delete(name) {
      delete this[MAP][sanitizeName(name)];
    }
  }, {
    key: 'raw',


    /**
     * Return raw headers (non-spec api)
     *
     * @return  Object
     */
    value: function raw() {
      return this[MAP];
    }

    /**
     * Get an iterator on keys.
     *
     * @return  Iterator
     */

  }, {
    key: 'keys',
    value: function keys() {
      return createHeadersIterator(this, 'key');
    }

    /**
     * Get an iterator on values.
     *
     * @return  Iterator
     */

  }, {
    key: 'values',
    value: function values() {
      return createHeadersIterator(this, 'value');
    }

    /**
     * Get an iterator on entries.
     *
     * This is the default iterator of the Headers object.
     *
     * @return  Iterator
     */

  }, {
    key: Symbol.iterator,
    value: function value() {
      return createHeadersIterator(this, 'key+value');
    }
  }]);

  return Headers;
}();

Headers.prototype.entries = Headers.prototype[Symbol.iterator];

Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
  value: 'HeadersPrototype',
  writable: false,
  enumerable: false,
  configurable: true
});

function getHeaderPairs(headers, kind) {
  var keys = Object.keys(headers[MAP]).sort();
  return keys.map(kind === 'key' ? function (k) {
    return [k];
  } : function (k) {
    return [k, headers.get(k)];
  });
}

var INTERNAL = Symbol('internal');

function createHeadersIterator(target, kind) {
  var iterator = Object.create(HeadersIteratorPrototype);
  iterator[INTERNAL] = {
    target: target,
    kind: kind,
    index: 0
  };
  return iterator;
}

var HeadersIteratorPrototype = Object.setPrototypeOf({
  next: function next() {
    // istanbul ignore if
    if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
      throw new TypeError('Value of `this` is not a HeadersIterator');
    }

    var target = this[INTERNAL].target;
    var kind = this[INTERNAL].kind;
    var index = this[INTERNAL].index;
    var values = getHeaderPairs(target, kind);
    var len = values.length;
    if (index >= len) {
      return {
        value: undefined,
        done: true
      };
    }

    var pair = values[index];
    this[INTERNAL].index = index + 1;

    var result = void 0;
    if (kind === 'key') {
      result = pair[0];
    } else if (kind === 'value') {
      result = pair[1];
    } else {
      result = pair;
    }

    return {
      value: result,
      done: false
    };
  }
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));

Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
  value: 'HeadersIterator',
  writable: false,
  enumerable: false,
  configurable: true
});

module.exports = Headers;
//# sourceMappingURL=headers.js.map