'use strict';

/**
 * request.js
 *
 * Request class contains server only options
 */

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var url = require('url');
var Headers = require('./headers.js');
var Body = require('./body.js');
var clone = Body.clone;
var extractContentType = Body.extractContentType;
var getTotalBytes = Body.getTotalBytes;

var PARSED_URL = Symbol('url');

/**
 * Request class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */

var Request = function () {
  function Request(input, init) {
    _classCallCheck(this, Request);

    if (!init) init = {};
    var parsedURL = void 0;

    // normalize input
    if (!(input instanceof Request)) {
      if (input && input.href) {
        // in order to support Node.js' Url objects; though WHATWG's URL objects
        // will fall into this branch also (since their `toString()` will return
        // `href` property anyway)
        parsedURL = url.parse(input.href);
      } else {
        // coerce input to a string before attempting to parse
        parsedURL = url.parse('' + input);
      }
      input = {};
    } else {
      parsedURL = url.parse(input.url);
    }

    var method = init.method || input.method || 'GET';

    if ((init.body != null || input instanceof Request && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
      throw new TypeError('Request with GET/HEAD method cannot have body');
    }

    var inputBody = init.body != null ? init.body : input instanceof Request && input.body !== null ? clone(input) : null;

    Body.call(this, inputBody, {
      timeout: init.timeout || input.timeout || 0,
      size: init.size || input.size || 0
    });

    // fetch spec options
    this.method = method.toUpperCase();
    this.redirect = init.redirect || input.redirect || 'follow';
    this.headers = new Headers(init.headers || input.headers || {});

    if (init.body != null) {
      var contentType = extractContentType(this);
      if (contentType !== null && !this.headers.has('Content-Type')) {
        this.headers.append('Content-Type', contentType);
      }
    }

    // server only options
    this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
    this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
    this.counter = init.counter || input.counter || 0;
    this.agent = init.agent || input.agent;

    this[PARSED_URL] = parsedURL;
    Object.defineProperty(this, Symbol.toStringTag, {
      value: 'Request',
      writable: false,
      enumerable: false,
      configurable: true
    });
  }

  _createClass(Request, [{
    key: 'clone',


    /**
     * Clone this request
     *
     * @return  Request
     */
    value: function clone() {
      return new Request(this);
    }
  }, {
    key: 'url',
    get: function get() {
      return url.format(this[PARSED_URL]);
    }
  }]);

  return Request;
}();

Body.mixIn(Request.prototype);

Object.defineProperty(Request.prototype, Symbol.toStringTag, {
  value: 'RequestPrototype',
  writable: false,
  enumerable: false,
  configurable: true
});

exports = module.exports = Request;

exports.getNodeRequestOptions = function getNodeRequestOptions(request) {
  var parsedURL = request[PARSED_URL];
  var headers = new Headers(request.headers);

  // fetch step 3
  if (!headers.has('Accept')) {
    headers.set('Accept', '*/*');
  }

  // Basic fetch
  if (!parsedURL.protocol || !parsedURL.hostname) {
    throw new TypeError('Only absolute URLs are supported');
  }

  if (!/^https?:$/.test(parsedURL.protocol)) {
    throw new TypeError('Only HTTP(S) protocols are supported');
  }

  // HTTP-network-or-cache fetch steps 5-9
  var contentLengthValue = null;
  if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
    contentLengthValue = '0';
  }
  if (request.body != null) {
    var totalBytes = getTotalBytes(request);
    if (typeof totalBytes === 'number') {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set('Content-Length', contentLengthValue);
  }

  // HTTP-network-or-cache fetch step 12
  if (!headers.has('User-Agent')) {
    headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
  }

  // HTTP-network-or-cache fetch step 16
  if (request.compress) {
    headers.set('Accept-Encoding', 'gzip,deflate');
  }
  if (!headers.has('Connection') && !request.agent) {
    headers.set('Connection', 'close');
  }

  // HTTP-network fetch step 4
  // chunked encoding is handled by Node.js

  return Object.assign({}, parsedURL, {
    method: request.method,
    headers: headers.raw(),
    agent: request.agent
  });
};
//# sourceMappingURL=request.js.map