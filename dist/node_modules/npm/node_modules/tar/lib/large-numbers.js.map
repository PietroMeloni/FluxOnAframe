{"version":3,"sources":["../../../../../../node_modules/npm/node_modules/tar/lib/large-numbers.js"],"names":["encode","exports","num","buf","length","encodeNegative","encodePositive","i","Math","floor","flipped","byte","onesComp","twosComp","parse","post","pre","pos","slice","twos","len","sum","f","pow"],"mappings":"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","file":"large-numbers.js","sourcesContent":["'use strict'\n// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.  The trailing byte in the\n// section will always be 0x20, or in some implementations 0x00.\n// this module encodes and decodes these things.\n\nconst encode = exports.encode = (num, buf) => {\n  buf[buf.length - 1] = 0x20\n  if (num < 0)\n    encodeNegative(num, buf)\n  else\n    encodePositive(num, buf)\n  return buf\n}\n\nconst encodePositive = (num, buf) => {\n  buf[0] = 0x80\n  for (var i = buf.length - 2; i > 0; i--) {\n    if (num === 0)\n      buf[i] = 0\n    else {\n      buf[i] = num % 0x100\n      num = Math.floor(num / 0x100)\n    }\n  }\n}\n\nconst encodeNegative = (num, buf) => {\n  buf[0] = 0xff\n  var flipped = false\n  num = num * -1\n  for (var i = buf.length - 2; i > 0; i--) {\n    var byte\n    if (num === 0)\n      byte = 0\n    else {\n      byte = num % 0x100\n      num = Math.floor(num / 0x100)\n    }\n    if (flipped)\n      buf[i] = onesComp(byte)\n    else if (byte === 0)\n      buf[i] = 0\n    else {\n      flipped = true\n      buf[i] = twosComp(byte)\n    }\n  }\n}\n\nconst parse = exports.parse = (buf) => {\n  var post = buf[buf.length - 1]\n  var pre = buf[0]\n  return pre === 0x80 ? pos(buf.slice(1, buf.length - 1))\n   : twos(buf.slice(1, buf.length - 1))\n}\n\nconst twos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  var flipped = false\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    var f\n    if (flipped)\n      f = onesComp(byte)\n    else if (byte === 0)\n      f = byte\n    else {\n      flipped = true\n      f = twosComp(byte)\n    }\n    if (f !== 0)\n      sum += f * Math.pow(256, len - i - 1)\n  }\n  return sum * -1\n}\n\nconst pos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    if (byte !== 0)\n      sum += byte * Math.pow(256, len - i - 1)\n  }\n  return sum\n}\n\nconst onesComp = byte => (0xff ^ byte) & 0xff\n\nconst twosComp = byte => ((0xff ^ byte) + 1) & 0xff\n"]}