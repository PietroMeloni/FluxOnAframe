{"version":3,"sources":["../../../../../../node_modules/npm/node_modules/tar/lib/extract.js"],"names":["hlo","require","Unpack","fs","fsm","path","x","module","exports","opt_","files","cb","Array","isArray","from","opt","sync","TypeError","file","length","filesFilter","extractFileSync","extractFile","extractSync","extract","map","Map","f","replace","filter","mapHas","r","root","parse","ret","has","get","dirname","set","entry","u","Sync","threw","fd","stat","statSync","readSize","maxReadSize","stream","ReadStreamSync","size","pipe","p","Promise","resolve","reject","on","er","ReadStream","then"],"mappings":"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","file":"extract.js","sourcesContent":["'use strict'\n\n// tar -x\nconst hlo = require('./high-level-opt.js')\nconst Unpack = require('./unpack.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\n\nconst x = module.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function')\n    cb = opt_, files = null, opt_ = {}\n  else if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (typeof files === 'function')\n    cb = files, files = null\n\n  if (!files)\n    files = []\n  else\n    files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  if (files.length)\n    filesFilter(opt, files)\n\n  return opt.file && opt.sync ? extractFileSync(opt)\n    : opt.file ? extractFile(opt, cb)\n    : opt.sync ? extractSync(opt)\n    : extract(opt)\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [f.replace(/\\/+$/, ''), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\\/+$/, ''))\n    : file => mapHas(file.replace(/\\/+$/, ''))\n}\n\nconst extractFileSync = opt => {\n  const u = new Unpack.Sync(opt)\n\n  const file = opt.file\n  let threw = true\n  let fd\n  const stat = fs.statSync(file)\n  // This trades a zero-byte read() syscall for a stat\n  // However, it will usually result in less memory allocation\n  const readSize = opt.maxReadSize || 16*1024*1024\n  const stream = new fsm.ReadStreamSync(file, {\n    readSize: readSize,\n    size: stat.size\n  })\n  stream.pipe(u)\n}\n\nconst extractFile = (opt, cb) => {\n  const u = new Unpack(opt)\n  const readSize = opt.maxReadSize || 16*1024*1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    u.on('error', reject)\n    u.on('close', resolve)\n\n    // This trades a zero-byte read() syscall for a stat\n    // However, it will usually result in less memory allocation\n    fs.stat(file, (er, stat) => {\n      if (er)\n        reject(er)\n      else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size\n        })\n        stream.on('error', reject)\n        stream.pipe(u)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst extractSync = opt => {\n  return new Unpack.Sync(opt)\n}\n\nconst extract = opt => {\n  return new Unpack(opt)\n}\n"]}