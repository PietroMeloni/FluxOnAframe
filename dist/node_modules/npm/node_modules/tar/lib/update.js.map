{"version":3,"sources":["../../../../../../node_modules/npm/node_modules/tar/lib/update.js"],"names":["hlo","require","r","u","module","exports","opt_","files","cb","opt","file","TypeError","gzip","Array","isArray","length","from","mtimeFilter","filter","mtimeCache","Map","path","stat","get","mtime"],"mappings":"AAAA;;AAEA;;AAEA,IAAMA,MAAMC,QAAQ,qBAAR,CAAZ;AACA,IAAMC,IAAID,QAAQ,cAAR,CAAV;AACA;;AAEA,IAAME,IAAIC,OAAOC,OAAP,GAAiB,UAACC,IAAD,EAAOC,KAAP,EAAcC,EAAd,EAAqB;AAC9C,MAAMC,MAAMT,IAAIM,IAAJ,CAAZ;;AAEA,MAAI,CAACG,IAAIC,IAAT,EACE,MAAM,IAAIC,SAAJ,CAAc,kBAAd,CAAN;;AAEF,MAAIF,IAAIG,IAAR,EACE,MAAM,IAAID,SAAJ,CAAc,sCAAd,CAAN;;AAEF,MAAI,CAACJ,KAAD,IAAU,CAACM,MAAMC,OAAN,CAAcP,KAAd,CAAX,IAAmC,CAACA,MAAMQ,MAA9C,EACE,MAAM,IAAIJ,SAAJ,CAAc,mCAAd,CAAN;;AAEFJ,UAAQM,MAAMG,IAAN,CAAWT,KAAX,CAAR;;AAEAU,cAAYR,GAAZ;AACA,SAAOP,EAAEO,GAAF,EAAOF,KAAP,EAAcC,EAAd,CAAP;AACD,CAhBD;;AAkBA,IAAMS,cAAc,SAAdA,WAAc,MAAO;AACzB,MAAMC,SAAST,IAAIS,MAAnB;;AAEA,MAAI,CAACT,IAAIU,UAAT,EACEV,IAAIU,UAAJ,GAAiB,IAAIC,GAAJ,EAAjB;;AAEFX,MAAIS,MAAJ,GAAaA,SAAS,UAACG,IAAD,EAAOC,IAAP;AAAA,WACpBJ,OAAOG,IAAP,EAAaC,IAAb,KAAsB,EAAEb,IAAIU,UAAJ,CAAeI,GAAf,CAAmBF,IAAnB,IAA2BC,KAAKE,KAAlC,CADF;AAAA,GAAT,GAET,UAACH,IAAD,EAAOC,IAAP;AAAA,WAAgB,EAAEb,IAAIU,UAAJ,CAAeI,GAAf,CAAmBF,IAAnB,IAA2BC,KAAKE,KAAlC,CAAhB;AAAA,GAFJ;AAGD,CATD","file":"update.js","sourcesContent":["'use strict'\n\n// tar -u\n\nconst hlo = require('./high-level-opt.js')\nconst r = require('./replace.js')\n// just call tar.r with the filter and mtimeCache\n\nconst u = module.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file)\n    throw new TypeError('file is required')\n\n  if (opt.gzip)\n    throw new TypeError('cannot append to compressed archives')\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  mtimeFilter(opt)\n  return r(opt, files, cb)\n}\n\nconst mtimeFilter = opt => {\n  const filter = opt.filter\n\n  if (!opt.mtimeCache)\n    opt.mtimeCache = new Map()\n\n  opt.filter = filter ? (path, stat) =>\n    filter(path, stat) && !(opt.mtimeCache.get(path) > stat.mtime)\n    : (path, stat) => !(opt.mtimeCache.get(path) > stat.mtime)\n}\n"]}