{"version":3,"sources":["../../../../../../node_modules/npm/node_modules/tar/lib/parse.js"],"names":["warner","require","path","Header","EE","Yallist","maxMetaEntrySize","Entry","Pax","zlib","gzipHeader","Buffer","from","STATE","Symbol","WRITEENTRY","READENTRY","NEXTENTRY","PROCESSENTRY","EX","GEX","META","EMITMETA","BUFFER","QUEUE","ENDED","EMITTEDEND","EMIT","UNZIP","CONSUMECHUNK","CONSUMECHUNKSUB","CONSUMEBODY","CONSUMEMETA","CONSUMEHEADER","CONSUMING","BUFFERCONCAT","MAYBEEND","WRITING","ABORTED","DONE","noop","module","exports","opt","ondone","on","emit","strict","filter","writable","readable","onwarn","onentry","chunk","position","header","nullBlock","cksumValid","warn","type","test","linkpath","entry","meta","size","ignore","c","remain","end","push","go","Array","isArray","apply","emittedEnd","shift","length","re","drainNow","flowing","once","br","blockRemain","slice","write","ret","ev","data","extra","parse","Object","create","replace","Error","msg","error","concat","i","ended","Unzip","abort","er","message","have"],"mappings":"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","file":"parse.js","sourcesContent":["'use strict'\n\n// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\n\nconst warner = require('./warn-mixin.js')\nconst path = require('path')\nconst Header = require('./header.js')\nconst EE = require('events')\nconst Yallist = require('yallist')\nconst maxMetaEntrySize = 1024 * 1024\nconst Entry = require('./read-entry.js')\nconst Pax = require('./pax.js')\nconst zlib = require('minizlib')\n\nconst gzipHeader = Buffer.from([0x1f, 0x8b])\nconst STATE = Symbol('state')\nconst WRITEENTRY = Symbol('writeEntry')\nconst READENTRY = Symbol('readEntry')\nconst NEXTENTRY = Symbol('nextEntry')\nconst PROCESSENTRY = Symbol('processEntry')\nconst EX = Symbol('extendedHeader')\nconst GEX = Symbol('globalExtendedHeader')\nconst META = Symbol('meta')\nconst EMITMETA = Symbol('emitMeta')\nconst BUFFER = Symbol('buffer')\nconst QUEUE = Symbol('queue')\nconst ENDED = Symbol('ended')\nconst EMITTEDEND = Symbol('emittedEnd')\nconst EMIT = Symbol('emit')\nconst UNZIP = Symbol('unzip')\nconst CONSUMECHUNK = Symbol('consumeChunk')\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub')\nconst CONSUMEBODY = Symbol('consumeBody')\nconst CONSUMEMETA = Symbol('consumeMeta')\nconst CONSUMEHEADER = Symbol('consumeHeader')\nconst CONSUMING = Symbol('consuming')\nconst BUFFERCONCAT = Symbol('bufferConcat')\nconst MAYBEEND = Symbol('maybeEnd')\nconst WRITING = Symbol('writing')\nconst ABORTED = Symbol('aborted')\nconst DONE = Symbol('onDone')\n\nconst noop = _ => true\n\nmodule.exports = warner(class Parser extends EE {\n  constructor (opt) {\n    opt = opt || {}\n    super(opt)\n\n    if (opt.ondone)\n      this.on(DONE, opt.ondone)\n    else\n      this.on(DONE, _ => {\n        this.emit('prefinish')\n        this.emit('finish')\n        this.emit('end')\n        this.emit('close')\n      })\n\n    this.strict = !!opt.strict\n    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize\n    this.filter = typeof opt.filter === 'function' ? opt.filter : noop\n\n    // have to set this so that streams are ok piping into it\n    this.writable = true\n    this.readable = false\n\n    this[QUEUE] = new Yallist()\n    this[BUFFER] = null\n    this[READENTRY] = null\n    this[WRITEENTRY] = null\n    this[STATE] = 'begin'\n    this[META] = ''\n    this[EX] = null\n    this[GEX] = null\n    this[ENDED] = false\n    this[UNZIP] = null\n    this[ABORTED] = false\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n    if (typeof opt.onentry === 'function')\n      this.on('entry', opt.onentry)\n  }\n\n  [CONSUMEHEADER] (chunk, position) {\n    const header = new Header(chunk, position)\n\n    if (header.nullBlock)\n      this[EMIT]('nullBlock')\n    else if (!header.cksumValid)\n      this.warn('invalid entry', header)\n    else if (!header.path)\n      this.warn('invalid: path is required', header)\n    else {\n      const type = header.type\n      if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)\n        this.warn('invalid: linkpath required', header)\n      else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)\n        this.warn('invalid: linkpath forbidden', header)\n      else {\n        const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])\n\n        if (entry.meta) {\n          if (entry.size > this.maxMetaEntrySize) {\n            entry.ignore = true\n            this[EMIT]('ignoredEntry', entry)\n            this[STATE] = 'ignore'\n          } else if (entry.size > 0) {\n            this[META] = ''\n            entry.on('data', c => this[META] += c)\n            this[STATE] = 'meta'\n          }\n        } else {\n\n          this[EX] = null\n          entry.ignore = entry.ignore || !this.filter(entry.path, entry)\n          if (entry.ignore) {\n            this[EMIT]('ignoredEntry', entry)\n            this[STATE] = entry.remain ? 'ignore' : 'begin'\n          } else {\n            if (entry.remain)\n              this[STATE] = 'body'\n            else {\n              this[STATE] = 'begin'\n              entry.end()\n            }\n\n            if (!this[READENTRY]) {\n              this[QUEUE].push(entry)\n              this[NEXTENTRY]()\n            } else\n              this[QUEUE].push(entry)\n          }\n        }\n      }\n    }\n  }\n\n  [PROCESSENTRY] (entry) {\n    let go = true\n\n    if (!entry) {\n      this[READENTRY] = null\n      go = false\n    } else if (Array.isArray(entry))\n      this.emit.apply(this, entry)\n    else {\n      this[READENTRY] = entry\n      this.emit('entry', entry)\n      if (!entry.emittedEnd) {\n        entry.on('end', _ => this[NEXTENTRY]())\n        go = false\n      }\n    }\n\n    return go\n  }\n\n  [NEXTENTRY] () {\n    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))\n\n    if (!this[QUEUE].length) {\n      // At this point, there's nothing in the queue, but we may have an\n      // entry which is being consumed (readEntry).\n      // If we don't, then we definitely can handle more data.\n      // If we do, and either it's flowing, or it has never had any data\n      // written to it, then it needs more.\n      // The only other possibility is that it has returned false from a\n      // write() call, so we wait for the next drain to continue.\n      const re = this[READENTRY]\n      const drainNow = !re || re.flowing || re.size === re.remain\n      if (drainNow) {\n        if (!this[WRITING])\n          this.emit('drain')\n      } else\n        re.once('drain', _ => this.emit('drain'))\n     }\n  }\n\n  [CONSUMEBODY] (chunk, position) {\n    // write up to but no  more than writeEntry.blockRemain\n    const entry = this[WRITEENTRY]\n    const br = entry.blockRemain\n    const c = (br >= chunk.length && position === 0) ? chunk\n      : chunk.slice(position, position + br)\n\n    entry.write(c)\n\n    if (!entry.blockRemain) {\n      this[STATE] = 'begin'\n      this[WRITEENTRY] = null\n      entry.end()\n    }\n\n    return c.length\n  }\n\n  [CONSUMEMETA] (chunk, position) {\n    const entry = this[WRITEENTRY]\n    const ret = this[CONSUMEBODY](chunk, position)\n\n    // if we finished, then the entry is reset\n    if (!this[WRITEENTRY])\n      this[EMITMETA](entry)\n\n    return ret\n  }\n\n  [EMIT] (ev, data, extra) {\n    if (!this[QUEUE].length && !this[READENTRY])\n      this.emit(ev, data, extra)\n    else\n      this[QUEUE].push([ev, data, extra])\n  }\n\n  [EMITMETA] (entry) {\n    this[EMIT]('meta', this[META])\n    switch (entry.type) {\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this[EX] = Pax.parse(this[META], this[EX], false)\n        break\n\n      case 'GlobalExtendedHeader':\n        this[GEX] = Pax.parse(this[META], this[GEX], true)\n        break\n\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].path = this[META].replace(/\\0.*/, '')\n        break\n\n      case 'NextFileHasLongLinkpath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].linkpath = this[META].replace(/\\0.*/, '')\n        break\n\n      /* istanbul ignore next */\n      default: throw new Error('unknown meta: ' + entry.type)\n    }\n  }\n\n  abort (msg, error) {\n    this[ABORTED] = true\n    this.warn(msg, error)\n    this.emit('abort', error)\n    this.emit('error', error)\n  }\n\n  write (chunk) {\n    if (this[ABORTED])\n      return\n\n    // first write, might be gzipped\n    if (this[UNZIP] === null && chunk) {\n      if (this[BUFFER]) {\n        chunk = Buffer.concat([this[BUFFER], chunk])\n        this[BUFFER] = null\n      }\n      if (chunk.length < gzipHeader.length) {\n        this[BUFFER] = chunk\n        return true\n      }\n      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {\n        if (chunk[i] !== gzipHeader[i])\n          this[UNZIP] = false\n      }\n      if (this[UNZIP] === null) {\n        const ended = this[ENDED]\n        this[ENDED] = false\n        this[UNZIP] = new zlib.Unzip()\n        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))\n        this[UNZIP].on('error', er =>\n          this.abort(er.message, er))\n        this[UNZIP].on('end', _ => {\n          this[ENDED] = true\n          this[CONSUMECHUNK]()\n        })\n        this[WRITING] = true\n        const ret = this[UNZIP][ended ? 'end' : 'write' ](chunk)\n        this[WRITING] = false\n        return ret\n      }\n    }\n\n    this[WRITING] = true\n    if (this[UNZIP])\n      this[UNZIP].write(chunk)\n    else\n      this[CONSUMECHUNK](chunk)\n    this[WRITING] = false\n\n    // return false if there's a queue, or if the current entry isn't flowing\n    const ret =\n      this[QUEUE].length ? false :\n      this[READENTRY] ? this[READENTRY].flowing :\n      true\n\n    // if we have no queue, then that means a clogged READENTRY\n    if (!ret && !this[QUEUE].length)\n      this[READENTRY].once('drain', _ => this.emit('drain'))\n\n    return ret\n  }\n\n  [BUFFERCONCAT] (c) {\n    if (c && !this[ABORTED])\n      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c\n  }\n\n  [MAYBEEND] () {\n    if (this[ENDED] &&\n        !this[EMITTEDEND] &&\n        !this[ABORTED] &&\n        !this[CONSUMING]) {\n      this[EMITTEDEND] = true\n      const entry = this[WRITEENTRY]\n      if (entry && entry.blockRemain) {\n        const have = this[BUFFER] ? this[BUFFER].length : 0\n        this.warn('Truncated input (needed ' + entry.blockRemain +\n                  ' more bytes, only ' + have + ' available)', entry)\n        if (this[BUFFER])\n          entry.write(this[BUFFER])\n        entry.end()\n      }\n      this[EMIT](DONE)\n    }\n  }\n\n  [CONSUMECHUNK] (chunk) {\n    if (this[CONSUMING]) {\n      this[BUFFERCONCAT](chunk)\n    } else if (!chunk && !this[BUFFER]) {\n      this[MAYBEEND]()\n    } else {\n      this[CONSUMING] = true\n      if (this[BUFFER]) {\n        this[BUFFERCONCAT](chunk)\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      } else {\n        this[CONSUMECHUNKSUB](chunk)\n      }\n\n      while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED]) {\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      }\n      this[CONSUMING] = false\n    }\n\n    if (!this[BUFFER] || this[ENDED])\n      this[MAYBEEND]()\n  }\n\n  [CONSUMECHUNKSUB] (chunk) {\n    // we know that we are in CONSUMING mode, so anything written goes into\n    // the buffer.  Advance the position and put any remainder in the buffer.\n    let position = 0\n    let length = chunk.length\n    while (position + 512 <= length && !this[ABORTED]) {\n      switch (this[STATE]) {\n        case 'begin':\n          this[CONSUMEHEADER](chunk, position)\n          position += 512\n          break\n\n        case 'ignore':\n        case 'body':\n          position += this[CONSUMEBODY](chunk, position)\n          break\n\n        case 'meta':\n          position += this[CONSUMEMETA](chunk, position)\n          break\n\n        /* istanbul ignore next */\n        default:\n          throw new Error('invalid state: ' + this[STATE])\n      }\n    }\n\n    if (position < length) {\n      if (this[BUFFER])\n        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])\n      else\n        this[BUFFER] = chunk.slice(position)\n    }\n  }\n\n  end (chunk) {\n    if (!this[ABORTED]) {\n      if (this[UNZIP])\n        this[UNZIP].end(chunk)\n      else {\n        this[ENDED] = true\n        this.write(chunk)\n      }\n    }\n  }\n})\n"]}