'use strict';

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Buffer = require('./buffer.js');
var MiniPass = require('minipass');
var Pax = require('./pax.js');
var Header = require('./header.js');
var ReadEntry = require('./read-entry.js');
var fs = require('fs');
var path = require('path');

var types = require('./types.js');
var maxReadSize = 16 * 1024 * 1024;
var PROCESS = Symbol('process');
var FILE = Symbol('file');
var DIRECTORY = Symbol('directory');
var SYMLINK = Symbol('symlink');
var HARDLINK = Symbol('hardlink');
var HEADER = Symbol('header');
var READ = Symbol('read');
var LSTAT = Symbol('lstat');
var ONLSTAT = Symbol('onlstat');
var ONREAD = Symbol('onread');
var ONREADLINK = Symbol('onreadlink');
var OPENFILE = Symbol('openfile');
var ONOPENFILE = Symbol('onopenfile');
var CLOSE = Symbol('close');
var MODE = Symbol('mode');
var warner = require('./warn-mixin.js');
var winchars = require('./winchars.js');

var modeFix = require('./mode-fix.js');

var WriteEntry = warner(function (_MiniPass) {
  _inherits(WriteEntry, _MiniPass);

  function WriteEntry(p, opt) {
    _classCallCheck(this, WriteEntry);

    opt = opt || {};

    var _this = _possibleConstructorReturn(this, (WriteEntry.__proto__ || Object.getPrototypeOf(WriteEntry)).call(this, opt));

    if (typeof p !== 'string') throw new TypeError('path is required');
    _this.path = p;
    // suppress atime, ctime, uid, gid, uname, gname
    _this.portable = !!opt.portable;
    // until node has builtin pwnam functions, this'll have to do
    _this.myuid = process.getuid && process.getuid();
    _this.myuser = process.env.USER || '';
    _this.maxReadSize = opt.maxReadSize || maxReadSize;
    _this.linkCache = opt.linkCache || new Map();
    _this.statCache = opt.statCache || new Map();
    _this.preservePaths = !!opt.preservePaths;
    _this.cwd = opt.cwd || process.cwd();
    _this.strict = !!opt.strict;
    _this.noPax = !!opt.noPax;
    _this.noMtime = !!opt.noMtime;
    _this.mtime = opt.mtime || null;

    if (typeof opt.onwarn === 'function') _this.on('warn', opt.onwarn);

    if (!_this.preservePaths && path.win32.isAbsolute(p)) {
      // absolutes on posix are also absolutes on win32
      // so we only need to test this one to get both
      var parsed = path.win32.parse(p);
      _this.warn('stripping ' + parsed.root + ' from absolute path', p);
      _this.path = p.substr(parsed.root.length);
    }

    _this.win32 = !!opt.win32 || process.platform === 'win32';
    if (_this.win32) {
      _this.path = winchars.decode(_this.path.replace(/\\/g, '/'));
      p = p.replace(/\\/g, '/');
    }

    _this.absolute = opt.absolute || path.resolve(_this.cwd, p);

    if (_this.path === '') _this.path = './';

    if (_this.statCache.has(_this.absolute)) _this[ONLSTAT](_this.statCache.get(_this.absolute));else _this[LSTAT]();
    return _this;
  }

  _createClass(WriteEntry, [{
    key: LSTAT,
    value: function value() {
      var _this2 = this;

      fs.lstat(this.absolute, function (er, stat) {
        if (er) return _this2.emit('error', er);
        _this2[ONLSTAT](stat);
      });
    }
  }, {
    key: ONLSTAT,
    value: function value(stat) {
      this.statCache.set(this.absolute, stat);
      this.stat = stat;
      if (!stat.isFile()) stat.size = 0;
      this.type = getType(stat);
      this.emit('stat', stat);
      this[PROCESS]();
    }
  }, {
    key: PROCESS,
    value: function value() {
      switch (this.type) {
        case 'File':
          return this[FILE]();
        case 'Directory':
          return this[DIRECTORY]();
        case 'SymbolicLink':
          return this[SYMLINK]();
        // unsupported types are ignored.
        default:
          return this.end();
      }
    }
  }, {
    key: MODE,
    value: function value(mode) {
      return modeFix(mode, this.type === 'Directory');
    }
  }, {
    key: HEADER,
    value: function value() {
      if (this.type === 'Directory' && this.portable) this.noMtime = true;

      this.header = new Header({
        path: this.path,
        linkpath: this.linkpath,
        // only the permissions and setuid/setgid/sticky bitflags
        // not the higher-order bits that specify file type
        mode: this[MODE](this.stat.mode),
        uid: this.portable ? null : this.stat.uid,
        gid: this.portable ? null : this.stat.gid,
        size: this.stat.size,
        mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
        type: this.type,
        uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : '',
        atime: this.portable ? null : this.stat.atime,
        ctime: this.portable ? null : this.stat.ctime
      });

      if (this.header.encode() && !this.noPax) this.write(new Pax({
        atime: this.portable ? null : this.header.atime,
        ctime: this.portable ? null : this.header.ctime,
        gid: this.portable ? null : this.header.gid,
        mtime: this.noMtime ? null : this.mtime || this.header.mtime,
        path: this.path,
        linkpath: this.linkpath,
        size: this.header.size,
        uid: this.portable ? null : this.header.uid,
        uname: this.portable ? null : this.header.uname,
        dev: this.portable ? null : this.stat.dev,
        ino: this.portable ? null : this.stat.ino,
        nlink: this.portable ? null : this.stat.nlink
      }).encode());
      this.write(this.header.block);
    }
  }, {
    key: DIRECTORY,
    value: function value() {
      if (this.path.substr(-1) !== '/') this.path += '/';
      this.stat.size = 0;
      this[HEADER]();
      this.end();
    }
  }, {
    key: SYMLINK,
    value: function value() {
      var _this3 = this;

      fs.readlink(this.absolute, function (er, linkpath) {
        if (er) return _this3.emit('error', er);
        _this3[ONREADLINK](linkpath);
      });
    }
  }, {
    key: ONREADLINK,
    value: function value(linkpath) {
      this.linkpath = linkpath;
      this[HEADER]();
      this.end();
    }
  }, {
    key: HARDLINK,
    value: function value(linkpath) {
      this.type = 'Link';
      this.linkpath = path.relative(this.cwd, linkpath);
      this.stat.size = 0;
      this[HEADER]();
      this.end();
    }
  }, {
    key: FILE,
    value: function value() {
      if (this.stat.nlink > 1) {
        var linkKey = this.stat.dev + ':' + this.stat.ino;
        if (this.linkCache.has(linkKey)) {
          var linkpath = this.linkCache.get(linkKey);
          if (linkpath.indexOf(this.cwd) === 0) return this[HARDLINK](linkpath);
        }
        this.linkCache.set(linkKey, this.absolute);
      }

      this[HEADER]();
      if (this.stat.size === 0) return this.end();

      this[OPENFILE]();
    }
  }, {
    key: OPENFILE,
    value: function value() {
      var _this4 = this;

      fs.open(this.absolute, 'r', function (er, fd) {
        if (er) return _this4.emit('error', er);
        _this4[ONOPENFILE](fd);
      });
    }
  }, {
    key: ONOPENFILE,
    value: function value(fd) {
      var blockLen = 512 * Math.ceil(this.stat.size / 512);
      var bufLen = Math.min(blockLen, this.maxReadSize);
      var buf = Buffer.allocUnsafe(bufLen);
      this[READ](fd, buf, 0, buf.length, 0, this.stat.size, blockLen);
    }
  }, {
    key: READ,
    value: function value(fd, buf, offset, length, pos, remain, blockRemain) {
      var _this5 = this;

      fs.read(fd, buf, offset, length, pos, function (er, bytesRead) {
        if (er) return _this5[CLOSE](fd, function (_) {
          return _this5.emit('error', er);
        });
        _this5[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead);
      });
    }
  }, {
    key: CLOSE,
    value: function value(fd, cb) {
      fs.close(fd, cb);
    }
  }, {
    key: ONREAD,
    value: function value(fd, buf, offset, length, pos, remain, blockRemain, bytesRead) {
      if (bytesRead <= 0 && remain > 0) {
        var er = new Error('unexpected EOF');
        er.path = this.absolute;
        er.syscall = 'read';
        er.code = 'EOF';
        this.emit('error', er);
      }

      // null out the rest of the buffer, if we could fit the block padding
      if (bytesRead === remain) {
        for (var i = bytesRead; i < length && bytesRead < blockRemain; i++) {
          buf[i + offset] = 0;
          bytesRead++;
          remain++;
        }
      }

      var writeBuf = offset === 0 && bytesRead === buf.length ? buf : buf.slice(offset, offset + bytesRead);
      remain -= bytesRead;
      blockRemain -= bytesRead;
      pos += bytesRead;
      offset += bytesRead;

      this.write(writeBuf);

      if (!remain) {
        if (blockRemain) this.write(Buffer.alloc(blockRemain));
        this.end();
        this[CLOSE](fd, function (_) {
          return _;
        });
        return;
      }

      if (offset >= length) {
        buf = Buffer.allocUnsafe(length);
        offset = 0;
      }
      length = buf.length - offset;
      this[READ](fd, buf, offset, length, pos, remain, blockRemain);
    }
  }]);

  return WriteEntry;
}(MiniPass));

var WriteEntrySync = function (_WriteEntry) {
  _inherits(WriteEntrySync, _WriteEntry);

  function WriteEntrySync(path, opt) {
    _classCallCheck(this, WriteEntrySync);

    return _possibleConstructorReturn(this, (WriteEntrySync.__proto__ || Object.getPrototypeOf(WriteEntrySync)).call(this, path, opt));
  }

  _createClass(WriteEntrySync, [{
    key: LSTAT,
    value: function value() {
      this[ONLSTAT](fs.lstatSync(this.absolute));
    }
  }, {
    key: SYMLINK,
    value: function value() {
      this[ONREADLINK](fs.readlinkSync(this.absolute));
    }
  }, {
    key: OPENFILE,
    value: function value() {
      this[ONOPENFILE](fs.openSync(this.absolute, 'r'));
    }
  }, {
    key: READ,
    value: function value(fd, buf, offset, length, pos, remain, blockRemain) {
      var threw = true;
      try {
        var bytesRead = fs.readSync(fd, buf, offset, length, pos);
        this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead);
        threw = false;
      } finally {
        if (threw) try {
          this[CLOSE](fd);
        } catch (er) {}
      }
    }
  }, {
    key: CLOSE,
    value: function value(fd) {
      fs.closeSync(fd);
    }
  }]);

  return WriteEntrySync;
}(WriteEntry);

var WriteEntryTar = warner(function (_MiniPass2) {
  _inherits(WriteEntryTar, _MiniPass2);

  function WriteEntryTar(readEntry, opt) {
    _classCallCheck(this, WriteEntryTar);

    opt = opt || {};

    var _this7 = _possibleConstructorReturn(this, (WriteEntryTar.__proto__ || Object.getPrototypeOf(WriteEntryTar)).call(this, opt));

    _this7.preservePaths = !!opt.preservePaths;
    _this7.portable = !!opt.portable;
    _this7.strict = !!opt.strict;
    _this7.noPax = !!opt.noPax;
    _this7.noMtime = !!opt.noMtime;

    _this7.readEntry = readEntry;
    _this7.type = readEntry.type;
    if (_this7.type === 'Directory' && _this7.portable) _this7.noMtime = true;

    _this7.path = readEntry.path;
    _this7.mode = _this7[MODE](readEntry.mode);
    _this7.uid = _this7.portable ? null : readEntry.uid;
    _this7.gid = _this7.portable ? null : readEntry.gid;
    _this7.uname = _this7.portable ? null : readEntry.uname;
    _this7.gname = _this7.portable ? null : readEntry.gname;
    _this7.size = readEntry.size;
    _this7.mtime = _this7.noMtime ? null : opt.mtime || readEntry.mtime;
    _this7.atime = _this7.portable ? null : readEntry.atime;
    _this7.ctime = _this7.portable ? null : readEntry.ctime;
    _this7.linkpath = readEntry.linkpath;

    if (typeof opt.onwarn === 'function') _this7.on('warn', opt.onwarn);

    if (path.isAbsolute(_this7.path) && !_this7.preservePaths) {
      var parsed = path.parse(_this7.path);
      _this7.warn('stripping ' + parsed.root + ' from absolute path', _this7.path);
      _this7.path = _this7.path.substr(parsed.root.length);
    }

    _this7.remain = readEntry.size;
    _this7.blockRemain = readEntry.startBlockSize;

    _this7.header = new Header({
      path: _this7.path,
      linkpath: _this7.linkpath,
      // only the permissions and setuid/setgid/sticky bitflags
      // not the higher-order bits that specify file type
      mode: _this7.mode,
      uid: _this7.portable ? null : _this7.uid,
      gid: _this7.portable ? null : _this7.gid,
      size: _this7.size,
      mtime: _this7.noMtime ? null : _this7.mtime,
      type: _this7.type,
      uname: _this7.portable ? null : _this7.uname,
      atime: _this7.portable ? null : _this7.atime,
      ctime: _this7.portable ? null : _this7.ctime
    });

    if (_this7.header.encode() && !_this7.noPax) _get(WriteEntryTar.prototype.__proto__ || Object.getPrototypeOf(WriteEntryTar.prototype), 'write', _this7).call(_this7, new Pax({
      atime: _this7.portable ? null : _this7.atime,
      ctime: _this7.portable ? null : _this7.ctime,
      gid: _this7.portable ? null : _this7.gid,
      mtime: _this7.noMtime ? null : _this7.mtime,
      path: _this7.path,
      linkpath: _this7.linkpath,
      size: _this7.size,
      uid: _this7.portable ? null : _this7.uid,
      uname: _this7.portable ? null : _this7.uname,
      dev: _this7.portable ? null : _this7.readEntry.dev,
      ino: _this7.portable ? null : _this7.readEntry.ino,
      nlink: _this7.portable ? null : _this7.readEntry.nlink
    }).encode());

    _get(WriteEntryTar.prototype.__proto__ || Object.getPrototypeOf(WriteEntryTar.prototype), 'write', _this7).call(_this7, _this7.header.block);
    readEntry.pipe(_this7);
    return _this7;
  }

  _createClass(WriteEntryTar, [{
    key: MODE,
    value: function value(mode) {
      return modeFix(mode, this.type === 'Directory');
    }
  }, {
    key: 'write',
    value: function write(data) {
      var writeLen = data.length;
      if (writeLen > this.blockRemain) throw new Error('writing more to entry than is appropriate');
      this.blockRemain -= writeLen;
      return _get(WriteEntryTar.prototype.__proto__ || Object.getPrototypeOf(WriteEntryTar.prototype), 'write', this).call(this, data);
    }
  }, {
    key: 'end',
    value: function end() {
      if (this.blockRemain) this.write(Buffer.alloc(this.blockRemain));
      return _get(WriteEntryTar.prototype.__proto__ || Object.getPrototypeOf(WriteEntryTar.prototype), 'end', this).call(this);
    }
  }]);

  return WriteEntryTar;
}(MiniPass));

WriteEntry.Sync = WriteEntrySync;
WriteEntry.Tar = WriteEntryTar;

var getType = function getType(stat) {
  return stat.isFile() ? 'File' : stat.isDirectory() ? 'Directory' : stat.isSymbolicLink() ? 'SymbolicLink' : 'Unsupported';
};

module.exports = WriteEntry;
//# sourceMappingURL=write-entry.js.map