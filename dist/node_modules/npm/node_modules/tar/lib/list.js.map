{"version":3,"sources":["../../../../../../node_modules/npm/node_modules/tar/lib/list.js"],"names":["Buffer","require","hlo","Parser","fs","fsm","path","t","module","exports","opt_","files","cb","Array","isArray","from","opt","sync","TypeError","file","length","filesFilter","noResume","onentryFunction","listFileSync","listFile","list","onentry","e","resume","map","Map","f","replace","filter","mapHas","r","root","parse","ret","has","get","dirname","set","entry","p","threw","fd","stat","statSync","readSize","maxReadSize","size","end","readFileSync","pos","buf","allocUnsafe","openSync","bytesRead","readSync","write","slice","closeSync","er","Promise","resolve","reject","on","stream","ReadStream","pipe","then"],"mappings":"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","file":"list.js","sourcesContent":["'use strict'\n\nconst Buffer = require('./buffer.js')\n\n// XXX: This shares a lot in common with extract.js\n// maybe some DRY opportunity here?\n\n// tar -t\nconst hlo = require('./high-level-opt.js')\nconst Parser = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\n\nconst t = module.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function')\n    cb = opt_, files = null, opt_ = {}\n  else if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (typeof files === 'function')\n    cb = files, files = null\n\n  if (!files)\n    files = []\n  else\n    files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  if (files.length)\n    filesFilter(opt, files)\n\n  if (!opt.noResume)\n    onentryFunction(opt)\n\n  return opt.file && opt.sync ? listFileSync(opt)\n    : opt.file ? listFile(opt, cb)\n    : list(opt)\n}\n\nconst onentryFunction = opt => {\n  const onentry = opt.onentry\n  opt.onentry = onentry ? e => {\n    onentry(e)\n    e.resume()\n  } : e => e.resume()\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [f.replace(/\\/+$/, ''), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\\/+$/, ''))\n    : file => mapHas(file.replace(/\\/+$/, ''))\n}\n\nconst listFileSync = opt => {\n  const p = list(opt)\n  const file = opt.file\n  let threw = true\n  let fd\n  try {\n    const stat = fs.statSync(file)\n    const readSize = opt.maxReadSize || 16*1024*1024\n    if (stat.size < readSize) {\n      p.end(fs.readFileSync(file))\n    } else {\n      let pos = 0\n      const buf = Buffer.allocUnsafe(readSize)\n      fd = fs.openSync(file, 'r')\n      while (pos < stat.size) {\n        let bytesRead = fs.readSync(fd, buf, 0, readSize, pos)\n        pos += bytesRead\n        p.write(buf.slice(0, bytesRead))\n      }\n      p.end()\n    }\n    threw = false\n  } finally {\n    if (threw && fd)\n      try { fs.closeSync(fd) } catch (er) {}\n  }\n}\n\nconst listFile = (opt, cb) => {\n  const parse = new Parser(opt)\n  const readSize = opt.maxReadSize || 16*1024*1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    parse.on('error', reject)\n    parse.on('end', resolve)\n\n    fs.stat(file, (er, stat) => {\n      if (er)\n        reject(er)\n      else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size\n        })\n        stream.on('error', reject)\n        stream.pipe(parse)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst list = opt => new Parser(opt)\n"]}