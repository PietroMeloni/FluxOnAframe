{"version":3,"sources":["../../../../../../node_modules/npm/node_modules/tar/lib/pack.js"],"names":["Buffer","require","PackJob","path","absolute","entry","stat","readdir","pending","ignore","piped","MiniPass","zlib","ReadEntry","WriteEntry","WriteEntrySync","Sync","WriteEntryTar","Tar","Yallist","EOF","alloc","ONSTAT","Symbol","ENDED","QUEUE","CURRENT","PROCESS","PROCESSING","PROCESSJOB","JOBS","JOBDONE","ADDFSENTRY","ADDTARENTRY","STAT","READDIR","ONREADDIR","PIPE","ENTRY","ENTRYOPT","WRITEENTRYCLASS","WRITE","ONDRAIN","fs","warner","Pack","opt","Object","create","cwd","process","maxReadSize","preservePaths","strict","noPax","prefix","replace","linkCache","Map","statCache","readdirCache","onwarn","on","zip","gzip","Gzip","chunk","resume","portable","noDirRecurse","follow","noMtime","mtime","filter","jobs","write","Error","flowing","p","resolve","job","push","er","emit","set","entries","w","head","next","value","removeNode","length","end","shift","has","get","isDirectory","msg","data","warn","forEach","slice","base","source","pause","PackSync","readdirSync","module","exports"],"mappings":"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","file":"pack.js","sourcesContent":["'use strict'\n\nconst Buffer = require('./buffer.js')\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nclass PackJob {\n  constructor (path, absolute) {\n    this.path = path || './'\n    this.absolute = absolute\n    this.entry = null\n    this.stat = null\n    this.readdir = null\n    this.pending = false\n    this.ignore = false\n    this.piped = false\n  }\n}\n\nconst MiniPass = require('minipass')\nconst zlib = require('minizlib')\nconst ReadEntry = require('./read-entry.js')\nconst WriteEntry = require('./write-entry.js')\nconst WriteEntrySync = WriteEntry.Sync\nconst WriteEntryTar = WriteEntry.Tar\nconst Yallist = require('yallist')\nconst EOF = Buffer.alloc(1024)\nconst ONSTAT = Symbol('onStat')\nconst ENDED = Symbol('ended')\nconst QUEUE = Symbol('queue')\nconst CURRENT = Symbol('current')\nconst PROCESS = Symbol('process')\nconst PROCESSING = Symbol('processing')\nconst PROCESSJOB = Symbol('processJob')\nconst JOBS = Symbol('jobs')\nconst JOBDONE = Symbol('jobDone')\nconst ADDFSENTRY = Symbol('addFSEntry')\nconst ADDTARENTRY = Symbol('addTarEntry')\nconst STAT = Symbol('stat')\nconst READDIR = Symbol('readdir')\nconst ONREADDIR = Symbol('onreaddir')\nconst PIPE = Symbol('pipe')\nconst ENTRY = Symbol('entry')\nconst ENTRYOPT = Symbol('entryOpt')\nconst WRITEENTRYCLASS = Symbol('writeEntryClass')\nconst WRITE = Symbol('write')\nconst ONDRAIN = Symbol('ondrain')\n\nconst fs = require('fs')\nconst path = require('path')\nconst warner = require('./warn-mixin.js')\n\nconst Pack = warner(class Pack extends MiniPass {\n  constructor (opt) {\n    super(opt)\n    opt = opt || Object.create(null)\n    this.opt = opt\n    this.cwd = opt.cwd || process.cwd()\n    this.maxReadSize = opt.maxReadSize\n    this.preservePaths = !!opt.preservePaths\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.prefix = (opt.prefix || '').replace(/(\\\\|\\/)+$/, '')\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.readdirCache = opt.readdirCache || new Map()\n\n    this[WRITEENTRYCLASS] = WriteEntry\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    this.zip = null\n    if (opt.gzip) {\n      if (typeof opt.gzip !== 'object')\n        opt.gzip = {}\n      this.zip = new zlib.Gzip(opt.gzip)\n      this.zip.on('data', chunk => super.write(chunk))\n      this.zip.on('end', _ => super.end())\n      this.zip.on('drain', _ => this[ONDRAIN]())\n      this.on('resume', _ => this.zip.resume())\n    } else\n      this.on('drain', this[ONDRAIN])\n\n    this.portable = !!opt.portable\n    this.noDirRecurse = !!opt.noDirRecurse\n    this.follow = !!opt.follow\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true\n\n    this[QUEUE] = new Yallist\n    this[JOBS] = 0\n    this.jobs = +opt.jobs || 4\n    this[PROCESSING] = false\n    this[ENDED] = false\n  }\n\n  [WRITE] (chunk) {\n    return super.write(chunk)\n  }\n\n  add (path) {\n    this.write(path)\n    return this\n  }\n\n  end (path) {\n    if (path)\n      this.write(path)\n    this[ENDED] = true\n    this[PROCESS]()\n    return this\n  }\n\n  write (path) {\n    if (this[ENDED])\n      throw new Error('write after end')\n\n    if (path instanceof ReadEntry)\n      this[ADDTARENTRY](path)\n    else\n      this[ADDFSENTRY](path)\n    return this.flowing\n  }\n\n  [ADDTARENTRY] (p) {\n    const absolute = path.resolve(this.cwd, p.path)\n    if (this.prefix)\n      p.path = this.prefix + '/' + p.path.replace(/^\\.(\\/+|$)/, '')\n\n    // in this case, we don't have to wait for the stat\n    if (!this.filter(p.path, p))\n      p.resume()\n    else {\n      const job = new PackJob(p.path, absolute, false)\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))\n      job.entry.on('end', _ => this[JOBDONE](job))\n      this[JOBS] += 1\n      this[QUEUE].push(job)\n    }\n\n    this[PROCESS]()\n  }\n\n  [ADDFSENTRY] (p) {\n    const absolute = path.resolve(this.cwd, p)\n    if (this.prefix)\n      p = this.prefix + '/' + p.replace(/^\\.(\\/+|$)/, '')\n\n    this[QUEUE].push(new PackJob(p, absolute))\n    this[PROCESS]()\n  }\n\n  [STAT] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    const stat = this.follow ? 'stat' : 'lstat'\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er)\n        this.emit('error', er)\n      else\n        this[ONSTAT](job, stat)\n    })\n  }\n\n  [ONSTAT] (job, stat) {\n    this.statCache.set(job.absolute, stat)\n    job.stat = stat\n\n    // now we have the stat, we can filter it.\n    if (!this.filter(job.path, stat))\n      job.ignore = true\n\n    this[PROCESS]()\n  }\n\n  [READDIR] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er)\n        return this.emit('error', er)\n      this[ONREADDIR](job, entries)\n    })\n  }\n\n  [ONREADDIR] (job, entries) {\n    this.readdirCache.set(job.absolute, entries)\n    job.readdir = entries\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    if (this[PROCESSING])\n      return\n\n    this[PROCESSING] = true\n    for (let w = this[QUEUE].head;\n         w !== null && this[JOBS] < this.jobs;\n         w = w.next) {\n      this[PROCESSJOB](w.value)\n      if (w.value.ignore) {\n        const p = w.next\n        this[QUEUE].removeNode(w)\n        w.next = p\n      }\n    }\n\n    this[PROCESSING] = false\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip)\n        this.zip.end(EOF)\n      else {\n        super.write(EOF)\n        super.end()\n      }\n    }\n  }\n\n  get [CURRENT] () {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value\n  }\n\n  [JOBDONE] (job) {\n    this[QUEUE].shift()\n    this[JOBS] -= 1\n    this[PROCESS]()\n  }\n\n  [PROCESSJOB] (job) {\n    if (job.pending)\n      return\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped)\n        this[PIPE](job)\n      return\n    }\n\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute))\n        this[ONSTAT](job, this.statCache.get(job.absolute))\n      else\n        this[STAT](job)\n    }\n    if (!job.stat)\n      return\n\n    // filtered out!\n    if (job.ignore)\n      return\n\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute))\n        this[ONREADDIR](job, this.readdirCache.get(job.absolute))\n      else\n        this[READDIR](job)\n      if (!job.readdir)\n        return\n    }\n\n    // we know it doesn't have an entry, because that got checked above\n    job.entry = this[ENTRY](job)\n    if (!job.entry) {\n      job.ignore = true\n      return\n    }\n\n    if (job === this[CURRENT] && !job.piped)\n      this[PIPE](job)\n  }\n\n  [ENTRYOPT] (job) {\n    return {\n      onwarn: (msg, data) => {\n        this.warn(msg, data)\n      },\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime\n    }\n  }\n\n  [ENTRY] (job) {\n    this[JOBS] += 1\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))\n        .on('end', () => this[JOBDONE](job))\n        .on('error', er => this.emit('error', er))\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n\n  [ONDRAIN] () {\n    if (this[CURRENT] && this[CURRENT].entry)\n      this[CURRENT].entry.resume()\n  }\n\n  // like .pipe() but using super, because our write() is special\n  [PIPE] (job) {\n    job.piped = true\n\n    if (job.readdir)\n      job.readdir.forEach(entry => {\n        const p = this.prefix ?\n          job.path.slice(this.prefix.length + 1) || './'\n          : job.path\n\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n\n    const source = job.entry\n    const zip = this.zip\n\n    if (zip)\n      source.on('data', chunk => {\n        if (!zip.write(chunk))\n          source.pause()\n      })\n    else\n      source.on('data', chunk => {\n        if (!super.write(chunk))\n          source.pause()\n      })\n  }\n\n  pause () {\n    if (this.zip)\n      this.zip.pause()\n    return super.pause()\n  }\n})\n\nclass PackSync extends Pack {\n  constructor (opt) {\n    super(opt)\n    this[WRITEENTRYCLASS] = WriteEntrySync\n  }\n\n  // pause/resume are no-ops in sync streams.\n  pause () {}\n  resume () {}\n\n  [STAT] (job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync'\n    this[ONSTAT](job, fs[stat](job.absolute))\n  }\n\n  [READDIR] (job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute))\n  }\n\n  // gotta get it all in this tick\n  [PIPE] (job) {\n    const source = job.entry\n    const zip = this.zip\n\n    if (job.readdir)\n      job.readdir.forEach(entry => {\n        const p = this.prefix ?\n          job.path.slice(this.prefix.length + 1) || './'\n          : job.path\n\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n\n    if (zip)\n      source.on('data', chunk => {\n        zip.write(chunk)\n      })\n    else\n      source.on('data', chunk => {\n        super[WRITE](chunk)\n      })\n  }\n}\n\nPack.Sync = PackSync\n\nmodule.exports = Pack\n"]}