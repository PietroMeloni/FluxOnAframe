{"version":3,"sources":["../../../../../../node_modules/npm/node_modules/yargs/lib/argsert.js"],"names":["command","require","YError","positionName","module","exports","argsert","expected","callerArguments","length","position","parsed","demanded","optional","parseCommand","args","slice","call","undefined","pop","totalCommands","forEach","arg","shift","observedType","guessType","matchingTypes","cmd","filter","type","argumentTypeError","err","console","warn","stack","Array","isArray","allowedTypes","join"],"mappings":"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","file":"argsert.js","sourcesContent":["'use strict'\nconst command = require('./command')()\nconst YError = require('./yerror')\n\nconst positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']\n\nmodule.exports = function argsert (expected, callerArguments, length) {\n  // TODO: should this eventually raise an exception.\n  try {\n    // preface the argument description with \"cmd\", so\n    // that we can run it through yargs' command parser.\n    let position = 0\n    let parsed = {demanded: [], optional: []}\n    if (typeof expected === 'object') {\n      length = callerArguments\n      callerArguments = expected\n    } else {\n      parsed = command.parseCommand(`cmd ${expected}`)\n    }\n    const args = [].slice.call(callerArguments)\n\n    while (args.length && args[args.length - 1] === undefined) args.pop()\n    length = length || args.length\n\n    if (length < parsed.demanded.length) {\n      throw new YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`)\n    }\n\n    const totalCommands = parsed.demanded.length + parsed.optional.length\n    if (length > totalCommands) {\n      throw new YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`)\n    }\n\n    parsed.demanded.forEach((demanded) => {\n      const arg = args.shift()\n      const observedType = guessType(arg)\n      const matchingTypes = demanded.cmd.filter(type => type === observedType || type === '*')\n      if (matchingTypes.length === 0) argumentTypeError(observedType, demanded.cmd, position, false)\n      position += 1\n    })\n\n    parsed.optional.forEach((optional) => {\n      if (args.length === 0) return\n      const arg = args.shift()\n      const observedType = guessType(arg)\n      const matchingTypes = optional.cmd.filter(type => type === observedType || type === '*')\n      if (matchingTypes.length === 0) argumentTypeError(observedType, optional.cmd, position, true)\n      position += 1\n    })\n  } catch (err) {\n    console.warn(err.stack)\n  }\n}\n\nfunction guessType (arg) {\n  if (Array.isArray(arg)) {\n    return 'array'\n  } else if (arg === null) {\n    return 'null'\n  }\n  return typeof arg\n}\n\nfunction argumentTypeError (observedType, allowedTypes, position, optional) {\n  throw new YError(`Invalid ${positionName[position] || 'manyith'} argument. Expected ${allowedTypes.join(' or ')} but received ${observedType}.`)\n}\n"]}