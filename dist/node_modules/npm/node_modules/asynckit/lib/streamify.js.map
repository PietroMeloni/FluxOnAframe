{"version":3,"sources":["../../../../../../node_modules/npm/node_modules/asynckit/lib/streamify.js"],"names":["async","require","module","exports","iterator","wrapIterator","callback","wrapCallback","stream","item","key","cb","aborter","wrappedCb","wrapIteratorCallback","call","jobs","length","wrapped","error","result","finisher","output","streamer","value","pause","emit","push"],"mappings":";;AAAA,IAAIA,QAAQC,QAAQ,YAAR,CAAZ;;AAEA;AACAC,OAAOC,OAAP,GAAiB;AACfC,YAAUC,YADK;AAEfC,YAAUC;AAFK,CAAjB;;AAKA;;;;;;;AAOA,SAASF,YAAT,CAAsBD,QAAtB,EACA;AACE,MAAII,SAAS,IAAb;;AAEA,SAAO,UAASC,IAAT,EAAeC,GAAf,EAAoBC,EAApB,EACP;AACE,QAAIC,OAAJ;AAAA,QACIC,YAAYb,MAAMc,qBAAqBC,IAArB,CAA0BP,MAA1B,EAAkCG,EAAlC,EAAsCD,GAAtC,CAAN,CADhB;;AAIAF,WAAOQ,IAAP,CAAYN,GAAZ,IAAmBG,SAAnB;;AAEA;AACA,QAAIT,SAASa,MAAT,IAAmB,CAAvB,EACA;AACEL,gBAAUR,SAASK,IAAT,EAAeI,SAAf,CAAV;AACD;AACD;AAJA,SAMA;AACED,kBAAUR,SAASK,IAAT,EAAeC,GAAf,EAAoBG,SAApB,CAAV;AACD;;AAED,WAAOD,OAAP;AACD,GApBD;AAqBD;;AAED;;;;;;;;;AASA,SAASL,YAAT,CAAsBD,QAAtB,EACA;AACE,MAAIE,SAAS,IAAb;;AAEA,MAAIU,UAAU,SAAVA,OAAU,CAASC,KAAT,EAAgBC,MAAhB,EACd;AACE,WAAOC,SAASN,IAAT,CAAcP,MAAd,EAAsBW,KAAtB,EAA6BC,MAA7B,EAAqCd,QAArC,CAAP;AACD,GAHD;;AAKA,SAAOY,OAAP;AACD;;AAED;;;;;;;;;;AAUA,SAASJ,oBAAT,CAA8BR,QAA9B,EAAwCI,GAAxC,EACA;AACE,MAAIF,SAAS,IAAb;;AAEA,SAAO,UAASW,KAAT,EAAgBG,MAAhB,EACP;AACE;AACA,QAAI,EAAEZ,OAAOF,OAAOQ,IAAhB,CAAJ,EACA;AACEV,eAASa,KAAT,EAAgBG,MAAhB;AACA;AACD;;AAED;AACA,WAAOd,OAAOQ,IAAP,CAAYN,GAAZ,CAAP;;AAEA,WAAOa,SAASR,IAAT,CAAcP,MAAd,EAAsBW,KAAtB,EAA6B,EAACT,KAAKA,GAAN,EAAWc,OAAOF,MAAlB,EAA7B,EAAwDhB,QAAxD,CAAP;AACD,GAbD;AAcD;;AAED;;;;;;;;AAQA,SAASiB,QAAT,CAAkBJ,KAAlB,EAAyBG,MAAzB,EAAiChB,QAAjC,EACA;AACE,MAAIa,SAAS,CAAC,KAAKA,KAAnB,EACA;AACE,SAAKA,KAAL,GAAaA,KAAb;AACA,SAAKM,KAAL;AACA,SAAKC,IAAL,CAAU,OAAV,EAAmBP,KAAnB;AACA;AACAb,aAASa,KAAT,EAAgBG,UAAUA,OAAOE,KAAjC;AACA;AACD;;AAED;AACA,OAAKG,IAAL,CAAUL,MAAV;;AAEA;AACA;AACAhB,WAASa,KAAT,EAAgBG,UAAUA,OAAOE,KAAjC;AACD;;AAED;;;;;;;;AAQA,SAASH,QAAT,CAAkBF,KAAlB,EAAyBG,MAAzB,EAAiChB,QAAjC,EACA;AACE;AACA;AACA,MAAI,CAACa,KAAL,EACA;AACE,SAAKQ,IAAL,CAAU,IAAV;AACD;;AAED;AACArB,WAASa,KAAT,EAAgBG,MAAhB;AACD","file":"streamify.js","sourcesContent":["var async = require('./async.js');\n\n// API\nmodule.exports = {\n  iterator: wrapIterator,\n  callback: wrapCallback\n};\n\n/**\n * Wraps iterators with long signature\n *\n * @this    ReadableAsyncKit#\n * @param   {function} iterator - function to wrap\n * @returns {function} - wrapped function\n */\nfunction wrapIterator(iterator)\n{\n  var stream = this;\n\n  return function(item, key, cb)\n  {\n    var aborter\n      , wrappedCb = async(wrapIteratorCallback.call(stream, cb, key))\n      ;\n\n    stream.jobs[key] = wrappedCb;\n\n    // it's either shortcut (item, cb)\n    if (iterator.length == 2)\n    {\n      aborter = iterator(item, wrappedCb);\n    }\n    // or long format (item, key, cb)\n    else\n    {\n      aborter = iterator(item, key, wrappedCb);\n    }\n\n    return aborter;\n  };\n}\n\n/**\n * Wraps provided callback function\n * allowing to execute snitch function before\n * real callback\n *\n * @this    ReadableAsyncKit#\n * @param   {function} callback - function to wrap\n * @returns {function} - wrapped function\n */\nfunction wrapCallback(callback)\n{\n  var stream = this;\n\n  var wrapped = function(error, result)\n  {\n    return finisher.call(stream, error, result, callback);\n  };\n\n  return wrapped;\n}\n\n/**\n * Wraps provided iterator callback function\n * makes sure snitch only called once,\n * but passes secondary calls to the original callback\n *\n * @this    ReadableAsyncKit#\n * @param   {function} callback - callback to wrap\n * @param   {number|string} key - iteration key\n * @returns {function} wrapped callback\n */\nfunction wrapIteratorCallback(callback, key)\n{\n  var stream = this;\n\n  return function(error, output)\n  {\n    // don't repeat yourself\n    if (!(key in stream.jobs))\n    {\n      callback(error, output);\n      return;\n    }\n\n    // clean up jobs\n    delete stream.jobs[key];\n\n    return streamer.call(stream, error, {key: key, value: output}, callback);\n  };\n}\n\n/**\n * Stream wrapper for iterator callback\n *\n * @this  ReadableAsyncKit#\n * @param {mixed} error - error response\n * @param {mixed} output - iterator output\n * @param {function} callback - callback that expects iterator results\n */\nfunction streamer(error, output, callback)\n{\n  if (error && !this.error)\n  {\n    this.error = error;\n    this.pause();\n    this.emit('error', error);\n    // send back value only, as expected\n    callback(error, output && output.value);\n    return;\n  }\n\n  // stream stuff\n  this.push(output);\n\n  // back to original track\n  // send back value only, as expected\n  callback(error, output && output.value);\n}\n\n/**\n * Stream wrapper for finishing callback\n *\n * @this  ReadableAsyncKit#\n * @param {mixed} error - error response\n * @param {mixed} output - iterator output\n * @param {function} callback - callback that expects final results\n */\nfunction finisher(error, output, callback)\n{\n  // signal end of the stream\n  // only for successfully finished streams\n  if (!error)\n  {\n    this.push(null);\n  }\n\n  // back to original track\n  callback(error, output);\n}\n"]}