{"version":3,"sources":["../../../../../../node_modules/npm/node_modules/asynckit/lib/iterate.js"],"names":["async","require","abort","module","exports","iterate","list","iterator","state","callback","key","index","jobs","runJob","error","output","results","item","aborter","length"],"mappings":";;AAAA,IAAIA,QAAQC,QAAQ,YAAR,CAAZ;AAAA,IACIC,QAAQD,QAAQ,YAAR,CADZ;;AAIA;AACAE,OAAOC,OAAP,GAAiBC,OAAjB;;AAEA;;;;;;;;AAQA,SAASA,OAAT,CAAiBC,IAAjB,EAAuBC,QAAvB,EAAiCC,KAAjC,EAAwCC,QAAxC,EACA;AACE;AACA,MAAIC,MAAMF,MAAM,WAAN,IAAqBA,MAAM,WAAN,EAAmBA,MAAMG,KAAzB,CAArB,GAAuDH,MAAMG,KAAvE;;AAEAH,QAAMI,IAAN,CAAWF,GAAX,IAAkBG,OAAON,QAAP,EAAiBG,GAAjB,EAAsBJ,KAAKI,GAAL,CAAtB,EAAiC,UAASI,KAAT,EAAgBC,MAAhB,EACnD;AACE;AACA;AACA,QAAI,EAAEL,OAAOF,MAAMI,IAAf,CAAJ,EACA;AACE;AACD;;AAED;AACA,WAAOJ,MAAMI,IAAN,CAAWF,GAAX,CAAP;;AAEA,QAAII,KAAJ,EACA;AACE;AACA;AACA;AACAZ,YAAMM,KAAN;AACD,KAND,MAQA;AACEA,YAAMQ,OAAN,CAAcN,GAAd,IAAqBK,MAArB;AACD;;AAED;AACAN,aAASK,KAAT,EAAgBN,MAAMQ,OAAtB;AACD,GA1BiB,CAAlB;AA2BD;;AAED;;;;;;;;;AASA,SAASH,MAAT,CAAgBN,QAAhB,EAA0BG,GAA1B,EAA+BO,IAA/B,EAAqCR,QAArC,EACA;AACE,MAAIS,OAAJ;;AAEA;AACA,MAAIX,SAASY,MAAT,IAAmB,CAAvB,EACA;AACED,cAAUX,SAASU,IAAT,EAAejB,MAAMS,QAAN,CAAf,CAAV;AACD;AACD;AAJA,OAMA;AACES,gBAAUX,SAASU,IAAT,EAAeP,GAAf,EAAoBV,MAAMS,QAAN,CAApB,CAAV;AACD;;AAED,SAAOS,OAAP;AACD","file":"iterate.js","sourcesContent":["var async = require('./async.js')\n  , abort = require('./abort.js')\n  ;\n\n// API\nmodule.exports = iterate;\n\n/**\n * Iterates over each job object\n *\n * @param {array|object} list - array or object (named list) to iterate over\n * @param {function} iterator - iterator to run\n * @param {object} state - current job status\n * @param {function} callback - invoked when all elements processed\n */\nfunction iterate(list, iterator, state, callback)\n{\n  // store current index\n  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;\n\n  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)\n  {\n    // don't repeat yourself\n    // skip secondary callbacks\n    if (!(key in state.jobs))\n    {\n      return;\n    }\n\n    // clean up jobs\n    delete state.jobs[key];\n\n    if (error)\n    {\n      // don't process rest of the results\n      // stop still active jobs\n      // and reset the list\n      abort(state);\n    }\n    else\n    {\n      state.results[key] = output;\n    }\n\n    // return salvaged results\n    callback(error, state.results);\n  });\n}\n\n/**\n * Runs iterator over provided job element\n *\n * @param   {function} iterator - iterator to invoke\n * @param   {string|number} key - key/index of the element in the list of jobs\n * @param   {mixed} item - job description\n * @param   {function} callback - invoked after iterator is done with the job\n * @returns {function|mixed} - job abort function or something else\n */\nfunction runJob(iterator, key, item, callback)\n{\n  var aborter;\n\n  // allow shortcut if iterator expects only two arguments\n  if (iterator.length == 2)\n  {\n    aborter = iterator(item, async(callback));\n  }\n  // otherwise go with full three arguments\n  else\n  {\n    aborter = iterator(item, key, async(callback));\n  }\n\n  return aborter;\n}\n"]}