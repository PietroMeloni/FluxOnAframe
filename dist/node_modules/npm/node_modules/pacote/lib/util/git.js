'use strict';

var BB = require('bluebird');

var cp = require('child_process');
var execFileAsync = BB.promisify(cp.execFile, {
  multiArgs: true
});
var finished = require('./finished');
var LRU = require('lru-cache');
var optCheck = require('./opt-check');
var osenv = require('osenv');
var path = require('path');
var pinflight = require('promise-inflight');
var promiseRetry = require('promise-retry');
var uniqueFilename = require('unique-filename');
var which = BB.promisify(require('which'));
var semver = require('semver');

var GOOD_ENV_VARS = new Set(['GIT_ASKPASS', 'GIT_EXEC_PATH', 'GIT_PROXY_COMMAND', 'GIT_SSH', 'GIT_SSH_COMMAND', 'GIT_SSL_CAINFO', 'GIT_SSL_NO_VERIFY']);

var GIT_TRANSIENT_ERRORS = ['remote error: Internal Server Error', 'The remote end hung up unexpectedly', 'Connection timed out', 'Operation timed out', 'Failed to connect to .* Timed out', 'Connection reset by peer', 'SSL_ERROR_SYSCALL', 'The requested URL returned error: 503'].join('|');

var GIT_TRANSIENT_ERROR_RE = new RegExp(GIT_TRANSIENT_ERRORS);

function shouldRetry(error) {
  return GIT_TRANSIENT_ERROR_RE.test(error);
}

var GIT_ = 'GIT_';
var GITENV = void 0;
function gitEnv() {
  if (GITENV) {
    return GITENV;
  }
  var tmpDir = path.join(osenv.tmpdir(), 'pacote-git-template-tmp');
  var tmpName = uniqueFilename(tmpDir, 'git-clone');
  GITENV = {
    GIT_ASKPASS: 'echo',
    GIT_TEMPLATE_DIR: tmpName
  };
  Object.keys(process.env).forEach(function (k) {
    if (GOOD_ENV_VARS.has(k) || !k.startsWith(GIT_)) {
      GITENV[k] = process.env[k];
    }
  });
  return GITENV;
}

var GITPATH = void 0;
try {
  GITPATH = which.sync('git');
} catch (e) {}

module.exports.clone = fullClone;
function fullClone(repo, committish, target, opts) {
  opts = optCheck(opts);
  var gitArgs = ['clone', '--mirror', '-q', repo, path.join(target, '.git')];
  if (process.platform === 'win32') {
    gitArgs.push('--config', 'core.longpaths=true');
  }
  return execGit(gitArgs, { cwd: target }).then(function () {
    return execGit(['init'], { cwd: target });
  }).then(function () {
    return execGit(['checkout', committish || 'HEAD'], { cwd: target });
  }).then(function () {
    return updateSubmodules(target, opts);
  }).then(function () {
    return headSha(target, opts);
  });
}

module.exports.shallow = shallowClone;
function shallowClone(repo, branch, target, opts) {
  opts = optCheck(opts);
  var gitArgs = ['clone', '--depth=1', '-q'];
  if (branch) {
    gitArgs.push('-b', branch);
  }
  gitArgs.push(repo, target);
  if (process.platform === 'win32') {
    gitArgs.push('--config', 'core.longpaths=true');
  }
  return execGit(gitArgs, {
    cwd: target
  }, opts).then(function () {
    return updateSubmodules(target, opts);
  }).then(function () {
    return headSha(target, opts);
  });
}

function updateSubmodules(localRepo, opts) {
  var gitArgs = ['submodule', 'update', '-q', '--init', '--recursive'];
  return execGit(gitArgs, {
    cwd: localRepo
  }, opts);
}

function headSha(repo, opts) {
  opts = optCheck(opts);
  return execGit(['rev-parse', '--revs-only', 'HEAD'], { cwd: repo }, opts).spread(function (stdout) {
    return stdout.trim();
  });
}

var CARET_BRACES = '^{}';
var REVS = new LRU({
  max: 100,
  maxAge: 5 * 60 * 1000
});
module.exports.revs = revs;
function revs(repo, opts) {
  opts = optCheck(opts);
  var cached = REVS.get(repo);
  if (cached) {
    return BB.resolve(cached);
  }
  return pinflight('ls-remote:' + repo, function () {
    return spawnGit(['ls-remote', '-h', '-t', repo], {
      env: gitEnv()
    }, opts).then(function (stdout) {
      return stdout.split('\n').reduce(function (revs, line) {
        var split = line.split(/\s+/, 2);
        if (split.length < 2) {
          return revs;
        }
        var sha = split[0].trim();
        var ref = split[1].trim().match(/(?:refs\/[^/]+\/)?(.*)/)[1];
        if (!ref) {
          return revs;
        } // ???
        if (ref.endsWith(CARET_BRACES)) {
          return revs;
        } // refs/tags/x^{} crap
        var type = refType(line);
        var doc = { sha: sha, ref: ref, type: type };

        revs.refs[ref] = doc;
        // We can check out shallow clones on specific SHAs if we have a ref
        if (revs.shas[sha]) {
          revs.shas[sha].push(ref);
        } else {
          revs.shas[sha] = [ref];
        }

        if (type === 'tag') {
          var match = ref.match(/v?(\d+\.\d+\.\d+(?:[-+].+)?)$/);
          if (match && semver.valid(match[1], true)) {
            revs.versions[semver.clean(match[1], true)] = doc;
          }
        }

        return revs;
      }, { versions: {}, 'dist-tags': {}, refs: {}, shas: {} });
    }, function (err) {
      err.message = 'Error while executing:\n' + GITPATH + ' ls-remote -h -t ' + repo + '\n\n' + err.stderr + '\n' + err.message;
      throw err;
    }).then(function (revs) {
      if (revs.refs.HEAD) {
        var _HEAD = revs.refs.HEAD;
        Object.keys(revs.versions).forEach(function (v) {
          if (v.sha === _HEAD.sha) {
            revs['dist-tags'].HEAD = v;
            if (!revs.refs.latest) {
              revs['dist-tags'].latest = revs.refs.HEAD;
            }
          }
        });
      }
      REVS.set(repo, revs);
      return revs;
    });
  });
}

module.exports._exec = execGit;
function execGit(gitArgs, gitOpts, opts) {
  opts = optCheck(opts);
  return checkGit().then(function (gitPath) {
    return promiseRetry(function (retry, number) {
      if (number !== 1) {
        opts.log.silly('pacote', 'Retrying git command: ' + gitArgs.join(' ') + ' attempt # ' + number);
      }
      return execFileAsync(gitPath, gitArgs, mkOpts(gitOpts, opts)).catch(function (err) {
        if (shouldRetry(err)) {
          retry(err);
        } else {
          throw err;
        }
      });
    }, opts.retry);
  });
}

module.exports._spawn = spawnGit;
function spawnGit(gitArgs, gitOpts, opts) {
  opts = optCheck(opts);
  return checkGit().then(function (gitPath) {
    return promiseRetry(function (retry, number) {
      if (number !== 1) {
        opts.log.silly('pacote', 'Retrying git command: ' + gitArgs.join(' ') + ' attempt # ' + number);
      }
      var child = cp.spawn(gitPath, gitArgs, mkOpts(gitOpts, opts));

      var stdout = '';
      var stderr = '';
      child.stdout.on('data', function (d) {
        stdout += d;
      });
      child.stderr.on('data', function (d) {
        stderr += d;
      });

      return finished(child, true).catch(function (err) {
        if (shouldRetry(stderr)) {
          retry(err);
        } else {
          err.stderr = stderr;
          throw err;
        }
      }).then(function () {
        return stdout;
      });
    }, opts.retry);
  });
}

function mkOpts(_gitOpts, opts) {
  var gitOpts = {
    env: gitEnv()
  };
  if (+opts.uid && !isNaN(opts.uid)) {
    gitOpts.uid = +opts.uid;
  }
  if (+opts.gid && !isNaN(opts.gid)) {
    gitOpts.gid = +opts.gid;
  }
  Object.assign(gitOpts, _gitOpts);
  return gitOpts;
}

function checkGit() {
  if (!GITPATH) {
    var err = new Error('No git binary found in $PATH');
    err.code = 'ENOGIT';
    return BB.reject(err);
  } else {
    return BB.resolve(GITPATH);
  }
}

var REFS_TAGS = 'refs/tags/';
var REFS_HEADS = 'refs/heads/';
var HEAD = 'HEAD';
function refType(ref) {
  return ref.indexOf(REFS_TAGS) !== -1 ? 'tag' : ref.indexOf(REFS_HEADS) !== -1 ? 'branch' : ref.endsWith(HEAD) ? 'head' : 'other';
}
//# sourceMappingURL=git.js.map