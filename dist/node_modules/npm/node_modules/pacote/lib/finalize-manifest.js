'use strict';

var BB = require('bluebird');

var cacache = require('cacache');
var cacheKey = require('./util/cache-key');
var fetchFromManifest = require('./fetch').fromManifest;
var finished = require('./util/finished');
var minimatch = require('minimatch');
var normalize = require('normalize-package-data');
var optCheck = require('./util/opt-check');
var path = require('path');
var pipe = BB.promisify(require('mississippi').pipe);
var ssri = require('ssri');
var tar = require('tar');

// `finalizeManifest` takes as input the various kinds of manifests that
// manifest handlers ('lib/fetchers/*.js#manifest()') return, and makes sure
// they are:
//
// * filled out with any required data that the handler couldn't fill in
// * formatted consistently
// * cached so we don't have to repeat this work more than necessary
//
// The biggest thing this package might do is do a full tarball extraction in
// order to find missing bits of metadata required by the npm installer. For
// example, it will fill in `_shrinkwrap`, `_integrity`, and other details that
// the plain manifest handlers would require a tarball to fill out. If a
// handler returns everything necessary, this process is skipped.
//
// If we get to the tarball phase, the corresponding tarball handler for the
// requested type will be invoked and the entire tarball will be read from the
// stream.
//
module.exports = finalizeManifest;
function finalizeManifest(pkg, spec, opts) {
  var key = finalKey(pkg, spec);
  opts = optCheck(opts);

  var cachedManifest = opts.cache && key && !opts.preferOnline && !opts.fullMetadata ? cacache.get.info(opts.cache, key, opts) : BB.resolve(null);

  return cachedManifest.then(function (cached) {
    if (cached && cached.metadata.manifest) {
      return new Manifest(cached.metadata.manifest);
    } else {
      return tarballedProps(pkg, spec, opts).then(function (props) {
        return pkg && pkg.name ? new Manifest(pkg, props, opts.fullMetadata) : new Manifest(props, null, opts.fullMetadata);
      }).then(function (manifest) {
        var cacheKey = key || finalKey(manifest, spec);
        if (!opts.cache || !cacheKey) {
          return manifest;
        } else {
          opts.metadata = {
            id: manifest._id,
            manifest: manifest,
            type: 'finalized-manifest'
          };
          return cacache.put(opts.cache, cacheKey, '.', opts).then(function () {
            return manifest;
          });
        }
      });
    }
  });
}

module.exports.Manifest = Manifest;
function Manifest(pkg, fromTarball, fullMetadata) {
  fromTarball = fromTarball || {};
  if (fullMetadata) {
    Object.assign(this, pkg);
  }
  this.name = pkg.name;
  this.version = pkg.version;
  this.engines = pkg.engines || fromTarball.engines;
  this.cpu = pkg.cpu || fromTarball.cpu;
  this.os = pkg.os || fromTarball.os;
  this.dependencies = pkg.dependencies || {};
  this.optionalDependencies = pkg.optionalDependencies || {};
  this.devDependencies = pkg.devDependencies || {};
  var bundled = pkg.bundledDependencies || pkg.bundleDependencies || false;
  this.bundleDependencies = bundled;
  this.peerDependencies = pkg.peerDependencies || {};
  this.deprecated = pkg.deprecated || false;

  // These depend entirely on each handler
  this._resolved = pkg._resolved;

  // Not all handlers (or registries) provide these out of the box,
  // and if they don't, we need to extract and read the tarball ourselves.
  // These are details required by the installer.
  this._integrity = pkg._integrity || fromTarball._integrity || null;
  this._shasum = pkg._shasum || fromTarball._shasum || null;
  this._shrinkwrap = pkg._shrinkwrap || fromTarball._shrinkwrap || null;
  this.bin = pkg.bin || fromTarball.bin || null;

  if (this.bin && Array.isArray(this.bin)) {
    // Code yanked from read-package-json.
    var m = pkg.directories && pkg.directories.bin || '.';
    this.bin = this.bin.reduce(function (acc, mf) {
      if (mf && mf.charAt(0) !== '.') {
        var f = path.basename(mf);
        acc[f] = path.join(m, mf);
      }
      return acc;
    }, {});
  }

  this._id = null;

  // TODO - freezing and inextensibility pending npm changes. See test suite.
  // Object.preventExtensions(this)
  normalize(this);

  // I don't want this why did you give it to me. Go away. ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥
  delete this.readme;

  // Object.freeze(this)
}

// Some things aren't filled in by standard manifest fetching.
// If this function needs to do its work, it will grab the
// package tarball, extract it, and take whatever it needs
// from the stream.
function tarballedProps(pkg, spec, opts) {
  var needsShrinkwrap = !pkg || pkg._hasShrinkwrap !== false && !pkg._shrinkwrap;
  var needsBin = !!(!pkg || !pkg.bin && pkg.directories && pkg.directories.bin);
  var needsIntegrity = !pkg || !pkg._integrity && pkg._integrity !== false;
  var needsShasum = !pkg || !pkg._shasum && pkg._shasum !== false;
  var needsHash = needsIntegrity || needsShasum;
  var needsManifest = !pkg || !pkg.name;
  var needsExtract = needsShrinkwrap || needsBin || needsManifest;
  if (!needsShrinkwrap && !needsBin && !needsHash && !needsManifest) {
    return BB.resolve({});
  } else {
    opts = optCheck(opts);
    var tarStream = fetchFromManifest(pkg, spec, opts);
    var extracted = needsExtract && new tar.Parse();
    return BB.join(needsShrinkwrap && jsonFromStream('npm-shrinkwrap.json', extracted), needsManifest && jsonFromStream('package.json', extracted), needsBin && getPaths(extracted), needsHash && ssri.fromStream(tarStream, { algorithms: ['sha1', 'sha512'] }), needsExtract && pipe(tarStream, extracted), function (sr, mani, paths, hash) {
      if (needsManifest && !mani) {
        var err = new Error('Non-registry package missing package.json: ' + spec + '.');
        err.code = 'ENOPACKAGEJSON';
        throw err;
      }
      var extraProps = mani || {};
      delete extraProps._resolved;
      // drain out the rest of the tarball
      tarStream.resume();
      // if we have directories.bin, we need to collect any matching files
      // to add to bin
      if (paths && paths.length) {
        var dirBin = mani ? mani && mani.directories && mani.directories.bin : pkg && pkg.directories && pkg.directories.bin;
        if (dirBin) {
          extraProps.bin = {};
          paths.forEach(function (filePath) {
            if (minimatch(filePath, dirBin + '/**')) {
              var relative = path.relative(dirBin, filePath);
              if (relative && relative[0] !== '.') {
                extraProps.bin[path.basename(relative)] = path.join(dirBin, relative);
              }
            }
          });
        }
      }
      return Object.assign(extraProps, {
        _shrinkwrap: sr,
        _resolved: mani && mani._resolved || pkg && pkg._resolved || spec.fetchSpec,
        _integrity: needsIntegrity && hash && hash.sha512 && hash.sha512[0].toString(),
        _shasum: needsShasum && hash && hash.sha1 && hash.sha1[0].hexDigest()
      });
    });
  }
}

function jsonFromStream(filename, dataStream) {
  return BB.fromNode(function (cb) {
    dataStream.on('error', cb);
    dataStream.on('close', cb);
    dataStream.on('entry', function (entry) {
      var filePath = entry.header.path.replace(/[^/]+\//, '');
      if (filePath !== filename) {
        entry.resume();
      } else {
        var data = '';
        entry.on('error', cb);
        finished(entry).then(function () {
          try {
            cb(null, JSON.parse(data));
          } catch (err) {
            cb(err);
          }
        }, function (err) {
          cb(err);
        });
        entry.on('data', function (d) {
          data += d;
        });
      }
    });
  });
}

function getPaths(dataStream) {
  return BB.fromNode(function (cb) {
    var paths = [];
    dataStream.on('error', cb);
    dataStream.on('close', function () {
      return cb(null, paths);
    });
    dataStream.on('entry', function handler(entry) {
      var filePath = entry.header.path.replace(/[^/]+\//, '');
      entry.resume();
      paths.push(filePath);
    });
  });
}

function finalKey(pkg, spec) {
  if (pkg && pkg._uniqueResolved) {
    // git packages have a unique, identifiable id, but no tar sha
    return cacheKey(spec.type + '-manifest', pkg._uniqueResolved);
  } else {
    return pkg && pkg._integrity && cacheKey(spec.type + '-manifest', pkg._resolved + ':' + ssri.stringify(pkg._integrity));
  }
}
//# sourceMappingURL=finalize-manifest.js.map