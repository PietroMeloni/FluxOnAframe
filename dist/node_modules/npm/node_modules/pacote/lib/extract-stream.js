'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Minipass = require('minipass');
var path = require('path');
var tar = require('tar');

module.exports = extractStream;
module.exports._computeMode = computeMode;

var Transformer = function (_Minipass) {
  _inherits(Transformer, _Minipass);

  function Transformer(spec, opts) {
    _classCallCheck(this, Transformer);

    var _this = _possibleConstructorReturn(this, (Transformer.__proto__ || Object.getPrototypeOf(Transformer)).call(this));

    _this.spec = spec;
    _this.opts = opts;
    _this.str = '';
    return _this;
  }

  _createClass(Transformer, [{
    key: 'write',
    value: function write(data) {
      this.str += data;
      return true;
    }
  }, {
    key: 'end',
    value: function end() {
      var replaced = this.str.replace(/}\s*$/, '\n,"_resolved": ' + JSON.stringify(this.opts.resolved || '') + '\n,"_integrity": ' + JSON.stringify(this.opts.integrity || '') + '\n,"_from": ' + JSON.stringify(this.spec.toString()) + '\n}');
      _get(Transformer.prototype.__proto__ || Object.getPrototypeOf(Transformer.prototype), 'write', this).call(this, replaced);
      return _get(Transformer.prototype.__proto__ || Object.getPrototypeOf(Transformer.prototype), 'end', this).call(this);
    }
  }]);

  return Transformer;
}(Minipass);

function computeMode(fileMode, optMode, umask) {
  return (fileMode | optMode) & ~(umask || 0);
}

function pkgJsonTransform(spec, opts) {
  return function (entry) {
    if (entry.path === 'package.json') {
      var transformed = new Transformer(spec, opts);
      return transformed;
    }
  };
}

function extractStream(spec, dest, opts) {
  opts = opts || {};
  var sawIgnores = new Set();
  return tar.x({
    cwd: dest,
    filter: function filter(name, entry) {
      return !entry.header.type.match(/^.*link$/i);
    },
    strip: 1,
    onwarn: function onwarn(msg) {
      return opts.log && opts.log.warn('tar', msg);
    },
    uid: opts.uid,
    gid: opts.gid,
    transform: opts.resolved && pkgJsonTransform(spec, opts),
    onentry: function onentry(entry) {
      if (entry.type.toLowerCase() === 'file') {
        entry.mode = computeMode(entry.mode, opts.fmode, opts.umask);
      } else if (entry.type.toLowerCase() === 'directory') {
        entry.mode = computeMode(entry.mode, opts.dmode, opts.umask);
      } else {
        entry.mode = computeMode(entry.mode, 0, opts.umask);
      }

      // Note: This mirrors logic in the fs read operations that are
      // employed during tarball creation, in the fstream-npm module.
      // It is duplicated here to handle tarballs that are created
      // using other means, such as system tar or git archive.
      if (entry.type.toLowerCase() === 'file') {
        var base = path.basename(entry.path);
        if (base === '.npmignore') {
          sawIgnores.add(entry.path);
        } else if (base === '.gitignore') {
          var npmignore = entry.path.replace(/\.gitignore$/, '.npmignore');
          if (!sawIgnores.has(npmignore)) {
            // Rename, may be clobbered later.
            entry.path = npmignore;
          }
        }
      }
    }
  });
}
//# sourceMappingURL=extract-stream.js.map