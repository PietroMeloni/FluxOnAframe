{"version":3,"sources":["../../../../../../node_modules/npm/node_modules/pacote/lib/with-tarball-stream.js"],"names":["BB","require","cacache","fetch","fs","npa","optCheck","path","ssri","retry","statAsync","promisify","stat","RETRIABLE_ERRORS","Set","module","exports","withTarballStream","spec","opts","streamHandler","where","tryFile","preferOnline","integrity","resolved","startsWith","try","log","silly","file","resolve","substr","then","verifier","integrityStream","stream","createReadStream","on","emit","err","pipe","catch","code","warn","verbose","message","reject","Object","assign","Error","tryDigest","cache","has","get","byDigest","once","ev","l","cleanUpCached","trySpec","tryAgain","attemptNum","tardata","tarball","m","_resolved","i","match","sri","retries","cachePath","rm","content"],"mappings":"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","file":"with-tarball-stream.js","sourcesContent":["'use strict'\n\nconst BB = require('bluebird')\n\nconst cacache = require('cacache')\nconst fetch = require('./fetch.js')\nconst fs = require('fs')\nconst npa = require('npm-package-arg')\nconst optCheck = require('./util/opt-check.js')\nconst path = require('path')\nconst ssri = require('ssri')\nconst retry = require('promise-retry')\n\nconst statAsync = BB.promisify(fs.stat)\n\nconst RETRIABLE_ERRORS = new Set(['ENOENT', 'EINTEGRITY', 'Z_DATA_ERROR'])\n\nmodule.exports = withTarballStream\nfunction withTarballStream (spec, opts, streamHandler) {\n  opts = optCheck(opts)\n  spec = npa(spec, opts.where)\n\n  // First, we check for a file: resolved shortcut\n  const tryFile = (\n    !opts.preferOnline &&\n    opts.integrity &&\n    opts.resolved &&\n    opts.resolved.startsWith('file:')\n  )\n    ? BB.try(() => {\n    // NOTE - this is a special shortcut! Packages installed as files do not\n    // have a `resolved` field -- this specific case only occurs when you have,\n    // say, a git dependency or a registry dependency that you've packaged into\n    // a local file, and put that file: spec in the `resolved` field.\n      opts.log.silly('pacote', `trying ${spec} by local file: ${opts.resolved}`)\n      const file = path.resolve(opts.where || '.', opts.resolved.substr(5))\n      return statAsync(file)\n        .then(() => {\n          const verifier = ssri.integrityStream({integrity: opts.integrity})\n          const stream = fs.createReadStream(file)\n            .on('error', err => verifier.emit('error', err))\n            .pipe(verifier)\n          return streamHandler(stream)\n        })\n        .catch(err => {\n          if (err.code === 'EINTEGRITY') {\n            opts.log.warn('pacote', `EINTEGRITY while extracting ${spec} from ${file}.You will have to recreate the file.`)\n            opts.log.verbose('pacote', `EINTEGRITY for ${spec}: ${err.message}`)\n          }\n          throw err\n        })\n    })\n    : BB.reject(Object.assign(new Error('no file!'), {code: 'ENOENT'}))\n\n  const tryDigest = tryFile\n    .catch(err => {\n      if (\n        opts.preferOnline ||\n      !opts.cache ||\n      !opts.integrity ||\n      !RETRIABLE_ERRORS.has(err.code)\n      ) {\n        throw err\n      } else {\n        opts.log.silly('tarball', `trying ${spec} by hash: ${opts.integrity}`)\n        const stream = cacache.get.stream.byDigest(\n          opts.cache, opts.integrity, opts\n        )\n        stream.once('error', err => stream.on('newListener', (ev, l) => {\n          if (ev === 'error') { l(err) }\n        }))\n        return streamHandler(stream)\n          .catch(err => {\n            if (err.code === 'EINTEGRITY' || err.code === 'Z_DATA_ERROR') {\n              opts.log.warn('tarball', `cached data for ${spec} (${opts.integrity}) seems to be corrupted. Refreshing cache.`)\n              return cleanUpCached(opts.cache, opts.integrity, opts)\n                .then(() => { throw err })\n            } else {\n              throw err\n            }\n          })\n      }\n    })\n\n  const trySpec = tryDigest\n    .catch(err => {\n      if (!RETRIABLE_ERRORS.has(err.code)) {\n      // If it's not one of our retriable errors, bail out and give up.\n        throw err\n      } else {\n        opts.log.silly(\n          'tarball',\n          `no local data for ${spec}. Extracting by manifest.`\n        )\n        return BB.resolve(retry((tryAgain, attemptNum) => {\n          const tardata = fetch.tarball(spec, opts)\n          if (!opts.resolved) {\n            tardata.on('manifest', m => {\n              opts.resolved = m._resolved\n            })\n            tardata.on('integrity', i => {\n              opts.integrity = i\n            })\n          }\n          return BB.try(() => streamHandler(tardata))\n            .catch(err => {\n              // Retry once if we have a cache, to clear up any weird conditions.\n              // Don't retry network errors, though -- make-fetch-happen has already\n              // taken care of making sure we're all set on that front.\n              if (opts.cache && err.code && !err.code.match(/^E\\d{3}$/)) {\n                if (err.code === 'EINTEGRITY' || err.code === 'Z_DATA_ERROR') {\n                  opts.log.warn('tarball', `tarball data for ${spec} (${opts.integrity}) seems to be corrupted. Trying one more time.`)\n                }\n                return cleanUpCached(opts.cache, err.sri, opts)\n                  .then(() => tryAgain(err))\n              } else {\n                throw err\n              }\n            })\n        }, {retries: 1}))\n      }\n    })\n\n  return trySpec\n    .catch(err => {\n      if (err.code === 'EINTEGRITY') {\n        err.message = `Verification failed while extracting ${spec}:\\n${err.message}`\n      }\n      throw err\n    })\n}\n\nfunction cleanUpCached (cachePath, integrity, opts) {\n  return cacache.rm.content(cachePath, integrity, opts)\n}\n"]}