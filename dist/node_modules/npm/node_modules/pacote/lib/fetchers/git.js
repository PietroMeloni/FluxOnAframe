'use strict';

var BB = require('bluebird');

var cacache = require('cacache');
var cacheKey = require('../util/cache-key');
var Fetcher = require('../fetch');
var git = require('../util/git');
var mkdirp = BB.promisify(require('mkdirp'));
var pickManifest = require('npm-pick-manifest');
var optCheck = require('../util/opt-check');
var osenv = require('osenv');
var packDir = require('../util/pack-dir');
var PassThrough = require('stream').PassThrough;
var path = require('path');
var pipe = BB.promisify(require('mississippi').pipe);
var rimraf = BB.promisify(require('rimraf'));
var uniqueFilename = require('unique-filename');

// `git` dependencies are fetched from git repositories and packed up.
var fetchGit = module.exports = Object.create(null);

Fetcher.impl(fetchGit, {
  manifest: function manifest(spec, opts) {
    opts = optCheck(opts);
    if (spec.hosted && spec.hosted.getDefaultRepresentation() === 'shortcut') {
      return hostedManifest(spec, opts);
    } else {
      // If it's not a shortcut, don't do fallbacks.
      return plainManifest(spec.fetchSpec, spec, opts);
    }
  },
  tarball: function tarball(spec, opts) {
    var _this = this;

    opts = optCheck(opts);
    var stream = new PassThrough();
    this.manifest(spec, opts).then(function (manifest) {
      stream.emit('manifest', manifest);
      return pipe(_this.fromManifest(manifest, spec, opts).on('integrity', function (i) {
        return stream.emit('integrity', i);
      }), stream);
    }, function (err) {
      return stream.emit('error', err);
    });
    return stream;
  },
  fromManifest: function fromManifest(manifest, spec, opts) {
    opts = optCheck(opts);
    var streamError = void 0;
    var stream = new PassThrough().on('error', function (e) {
      streamError = e;
    });
    var cacheName = manifest._uniqueResolved || manifest._resolved || '';
    var cacheStream = opts.cache && cacache.get.stream(opts.cache, cacheKey('packed-dir', cacheName), opts).on('integrity', function (i) {
      return stream.emit('integrity', i);
    });
    cacheStream.pipe(stream);
    cacheStream.on('error', function (err) {
      if (err.code !== 'ENOENT') {
        return stream.emit('error', err);
      } else {
        stream.emit('reset');
        return withTmp(opts, function (tmp) {
          if (streamError) {
            throw streamError;
          }
          return cloneRepo(spec, manifest._repo, manifest._ref, manifest._rawRef, tmp, opts).then(function (HEAD) {
            if (streamError) {
              throw streamError;
            }
            manifest._resolved = spec.saveSpec.replace(/(:?#.*)?$/, '#' + HEAD);
            manifest._uniqueResolved = manifest._resolved;
            return packDir(manifest, manifest._uniqueResolved, tmp, stream, opts);
          });
        }).catch(function (err) {
          return stream.emit('error', err);
        });
      }
    });
    return stream;
  }
});

function hostedManifest(spec, opts) {
  return BB.resolve(null).then(function () {
    if (!spec.hosted.git()) {
      throw new Error('No git url for ' + spec);
    }
    return plainManifest(spec.hosted.git(), spec, opts);
  }).catch(function (err) {
    if (!spec.hosted.https()) {
      throw err;
    }
    return plainManifest(spec.hosted.https(), spec, opts);
  }).catch(function (err) {
    if (!spec.hosted.sshurl()) {
      throw err;
    }
    return plainManifest(spec.hosted.sshurl(), spec, opts);
  });
}

function plainManifest(repo, spec, opts) {
  var rawRef = spec.gitCommittish || spec.gitRange;
  return resolve(repo, spec, spec.name, opts).then(function (ref) {
    if (ref) {
      var resolved = spec.saveSpec.replace(/(?:#.*)?$/, '#' + ref.sha);
      return {
        _repo: repo,
        _resolved: resolved,
        _spec: spec,
        _ref: ref,
        _rawRef: spec.gitCommittish || spec.gitRange,
        _uniqueResolved: resolved,
        _integrity: false,
        _shasum: false
      };
    } else {
      // We're SOL and need a full clone :(
      //
      // If we're confident enough that `rawRef` is a commit SHA,
      // then we can at least get `finalize-manifest` to cache its result.
      var _resolved = spec.saveSpec.replace(/(?:#.*)?$/, rawRef ? '#' + rawRef : '');
      return {
        _repo: repo,
        _rawRef: rawRef,
        _resolved: rawRef && rawRef.match(/^[a-f0-9]{40}$/) && _resolved,
        _uniqueResolved: rawRef && rawRef.match(/^[a-f0-9]{40}$/) && _resolved,
        _integrity: false,
        _shasum: false
      };
    }
  });
}

function resolve(url, spec, name, opts) {
  var isSemver = !!spec.gitRange;
  return git.revs(url, opts).then(function (remoteRefs) {
    return isSemver ? pickManifest({
      versions: remoteRefs.versions,
      'dist-tags': remoteRefs['dist-tags'],
      name: name
    }, spec.gitRange, opts) : remoteRefs ? BB.resolve(remoteRefs.refs[spec.gitCommittish] || remoteRefs.refs[remoteRefs.shas[spec.gitCommittish]]) : null;
  });
}

function withTmp(opts, cb) {
  if (opts.cache) {
    // cacache has a special facility for working in a tmp dir
    return cacache.tmp.withTmp(opts.cache, { tmpPrefix: 'git-clone' }, cb);
  } else {
    var tmpDir = path.join(osenv.tmpdir(), 'pacote-git-tmp');
    var tmpName = uniqueFilename(tmpDir, 'git-clone');
    var tmp = mkdirp(tmpName).then(function () {
      return tmpName;
    }).disposer(rimraf);
    return BB.using(tmp, cb);
  }
}

// Only certain whitelisted hosted gits support shadow cloning
var SHALLOW_HOSTS = new Set(['github', 'gist', 'gitlab', 'bitbucket']);
function cloneRepo(spec, repo, resolvedRef, rawRef, tmp, opts) {
  var ref = resolvedRef ? resolvedRef.ref : rawRef;
  if (resolvedRef && spec.hosted && SHALLOW_HOSTS.has(spec.hosted.type)) {
    return git.shallow(repo, ref, tmp, opts);
  } else {
    return git.clone(repo, ref, tmp, opts);
  }
}
//# sourceMappingURL=git.js.map