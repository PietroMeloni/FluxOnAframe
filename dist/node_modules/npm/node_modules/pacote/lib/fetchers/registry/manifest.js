'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BB = require('bluebird');

var fetch = require('./fetch');
var LRU = require('lru-cache');
var optCheck = require('../../util/opt-check');
var pickManifest = require('npm-pick-manifest');
var pickRegistry = require('./pick-registry');
var ssri = require('ssri');
var url = require('url');

// Corgis are cute. ðŸ•ðŸ¶
var CORGI_DOC = 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*';
var JSON_DOC = 'application/json';

module.exports = manifest;
function manifest(spec, opts) {
  opts = optCheck(opts);

  var registry = pickRegistry(spec, opts);
  var uri = metadataUrl(registry, spec.escapedName);

  return getManifest(uri, registry, spec, opts).then(function (manifest) {
    return annotateManifest(uri, registry, manifest);
  });
}

function metadataUrl(registry, name) {
  var normalized = registry.slice(-1) !== '/' ? registry + '/' : registry;
  return url.resolve(normalized, name);
}

function getManifest(uri, registry, spec, opts) {
  return fetchPackument(uri, spec, registry, opts).then(function (packument) {
    try {
      return pickManifest(packument, spec.fetchSpec, {
        defaultTag: opts.defaultTag,
        includeDeprecated: opts.includeDeprecated
      });
    } catch (err) {
      if (err.code === 'ETARGET' && packument._cached && !opts.offline) {
        opts.log.silly('registry:manifest', 'no matching version for ' + spec.name + '@' + spec.fetchSpec + ' in the cache. Forcing revalidation');
        opts.preferOffline = false;
        opts.preferOnline = true;
        return fetchPackument(uri, spec, registry, opts).then(function (packument) {
          return pickManifest(packument, spec.fetchSpec, {
            defaultTag: opts.defaultTag
          });
        });
      } else {
        throw err;
      }
    }
  });
}

// TODO - make this an opt
var MEMO = new LRU({
  length: function length(m) {
    return m._contentLength;
  },
  max: 200 * 1024 * 1024, // 200MB
  maxAge: 30 * 1000 // 30s
});

module.exports.clearMemoized = clearMemoized;
function clearMemoized() {
  MEMO.reset();
}

function fetchPackument(uri, spec, registry, opts) {
  var mem = pickMem(opts);
  if (mem && !opts.preferOnline && mem.has(uri)) {
    return BB.resolve(mem.get(uri));
  }

  return fetch(uri, registry, Object.assign({
    headers: {
      'pacote-req-type': 'packument',
      'pacote-pkg-id': 'registry:' + manifest.name,
      accept: opts.fullMetadata ? JSON_DOC : CORGI_DOC
    },
    spec: spec
  }, opts, {
    // Force integrity to null: we never check integrity hashes for manifests
    integrity: null
  })).then(function (res) {
    return res.json().then(function (packument) {
      packument._cached = decodeURIComponent(res.headers.has('x-local-cache'));
      packument._contentLength = +res.headers.get('content-length');
      // NOTE - we need to call pickMem again because proxy
      //        objects get reused!
      var mem = pickMem(opts);
      if (mem) {
        mem.set(uri, packument);
      }
      return packument;
    });
  });
}

var ObjProxy = function () {
  function ObjProxy() {
    _classCallCheck(this, ObjProxy);
  }

  _createClass(ObjProxy, [{
    key: 'get',
    value: function get(key) {
      return this.obj[key];
    }
  }, {
    key: 'set',
    value: function set(key, val) {
      this.obj[key] = val;
    }
  }]);

  return ObjProxy;
}();

// This object is used synchronously and immediately, so
// we can safely reuse it instead of consing up new ones


var PROX = new ObjProxy();
function pickMem(opts) {
  if (!opts || !opts.memoize) {
    return MEMO;
  } else if (opts.memoize.get && opts.memoize.set) {
    return opts.memoize;
  } else if (_typeof(opts.memoize) === 'object') {
    PROX.obj = opts.memoize;
    return PROX;
  } else {
    return null;
  }
}

function annotateManifest(uri, registry, manifest) {
  var shasum = manifest.dist && manifest.dist.shasum;
  manifest._integrity = manifest.dist && manifest.dist.integrity;
  manifest._shasum = shasum;
  if (!manifest._integrity && shasum) {
    // Use legacy dist.shasum field if available.
    manifest._integrity = ssri.fromHex(shasum, 'sha1').toString();
  }
  manifest._resolved = manifest.dist && manifest.dist.tarball;
  if (!manifest._resolved) {
    var err = new Error('Manifest for ' + manifest.name + '@' + manifest.version + ' from ' + uri + ' is missing a tarball url (pkg.dist.tarball). Guessing a default.');
    err.code = 'ENOTARBALL';
    err.manifest = manifest;
    if (!manifest._warnings) {
      manifest._warnings = [];
    }
    manifest._warnings.push(err.message);
    manifest._resolved = registry + '/' + manifest.name + '/-/' + manifest.name + '-' + manifest.version + '.tgz';
  }
  return manifest;
}
//# sourceMappingURL=manifest.js.map