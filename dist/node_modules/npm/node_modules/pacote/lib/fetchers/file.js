'use strict';

var BB = require('bluebird');

var cacache = require('cacache');
var Fetcher = require('../fetch');
var fs = require('fs');
var pipe = BB.promisify(require('mississippi').pipe);
var through = require('mississippi').through;

var readFileAsync = BB.promisify(fs.readFile);
var statAsync = BB.promisify(fs.stat);

var MAX_BULK_SIZE = 2 * 1024 * 1024; // 2MB

// `file` packages refer to local tarball files.
var fetchFile = module.exports = Object.create(null);

Fetcher.impl(fetchFile, {
  manifest: function manifest(spec, opts) {
    // We can't do much here. `finalizeManifest` will take care of
    // calling `tarball` to fill out all the necessary details.
    return BB.resolve(null);
  },


  // All the heavy lifting for `file` packages is done here.
  // They're never cached. We just read straight out of the file.
  // TODO - maybe they *should* be cached?
  tarball: function tarball(spec, opts) {
    var src = spec._resolved || spec.fetchSpec;
    var stream = through();
    statAsync(src).then(function (stat) {
      if (spec._resolved) {
        stream.emit('manifest', spec);
      }
      if (stat.size <= MAX_BULK_SIZE) {
        // YAY LET'S DO THING IN BULK
        return readFileAsync(src).then(function (data) {
          if (opts.cache) {
            return cacache.put(opts.cache, 'pacote:tarball:file:' + src, data, {
              integrity: opts.integrity
            }).then(function (integrity) {
              return { data: data, integrity: integrity };
            });
          } else {
            return { data: data };
          }
        }).then(function (info) {
          if (info.integrity) {
            stream.emit('integrity', info.integrity);
          }
          stream.write(info.data, function () {
            stream.end();
          });
        });
      } else {
        var integrity = void 0;
        var cacheWriter = !opts.cache ? BB.resolve(null) : pipe(fs.createReadStream(src), cacache.put.stream(opts.cache, 'pacote:tarball:' + src, {
          integrity: opts.integrity
        }).on('integrity', function (d) {
          integrity = d;
        }));
        return cacheWriter.then(function () {
          if (integrity) {
            stream.emit('integrity', integrity);
          }
          return pipe(fs.createReadStream(src), stream);
        });
      }
    }, function (err) {
      return stream.emit('error', err);
    });
    return stream;
  },
  fromManifest: function fromManifest(manifest, spec, opts) {
    return this.tarball(manifest || spec, opts);
  }
});
//# sourceMappingURL=file.js.map