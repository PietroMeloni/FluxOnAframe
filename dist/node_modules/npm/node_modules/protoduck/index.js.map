{"version":3,"sources":["../../../../../node_modules/npm/node_modules/protoduck/index.js"],"names":["genfun","require","Duck","target","types","impls","isArray","isDerivable","_defaultImpls","isGenfun","prototype","checkImpls","checkArgTypes","_constraints","forEach","c","verify","Error","name","parent","_methodNames","defineMethod","arg","args","fns","gf","map","i","length","hasMethod","apply","thisType","argTypes","Constraint","Function","isDuck","isProtocol","Protoduck","module","exports","define","createGenfun","_metaCreateGenfun","addMethod","_metaAddMethod","noImplFound","noApplicableMethod","spec","opts","duck","matches","Object","setPrototypeOf","defineProperty","value","where","w","_metaobject","metaobject","_types","_gfTypes","keys","checkMethodSpec","attach","gfTypes","pop","idx","indexOf","typeId","join","methodTypes","typeIdx","undefined","useMetaobject","hasOwnProperty","call","fn","formatMethod","filter","m","withDuckName","n","requiredTypes","typeName","obj","exec","toString","installMethodErrorMessage","proto","add","thisArg","getPrototypeOf","msg","err","protocol","function","code","x","impl","deflt","default","child","thisIdx","indices","parentTypes","hasImpl","isConstraint"],"mappings":"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","file":"index.js","sourcesContent":["'use strict'\n\nconst genfun = require('genfun')\n\nclass Duck extends Function {\n  // Duck.impl(Foo, [String, Array], { frob (str, arr) { ... }})\n  impl (target, types, impls) {\n    if (!impls && !isArray(types)) {\n      impls = types\n      types = []\n    }\n    if (!impls && this.isDerivable) {\n      impls = this._defaultImpls\n    }\n    if (!impls) {\n      impls = {}\n    }\n    if (typeof target === 'function' && !target.isGenfun) {\n      target = target.prototype\n    }\n    checkImpls(this, target, impls)\n    checkArgTypes(this, types)\n    this._constraints.forEach(c => {\n      if (!c.verify(target, types)) {\n        throw new Error(`Implementations of ${\n          this.name || 'this protocol'\n        } must first implement ${\n          c.parent.name || 'its constraint protocols defined in opts.where.'\n        }`)\n      }\n    })\n    this._methodNames.forEach(name => {\n      defineMethod(this, name, target, types, impls)\n    })\n  }\n\n  hasImpl (arg, args) {\n    args = args || []\n    const fns = this._methodNames\n    var gf\n    if (typeof arg === 'function' && !arg.isGenfun) {\n      arg = arg.prototype\n    }\n    args = args.map(arg => {\n      if (typeof arg === 'function' && !arg.isGenfun) {\n        return arg.prototype\n      } else {\n        return arg\n      }\n    })\n    for (var i = 0; i < fns.length; i++) {\n      gf = arg[fns[i]]\n      if (!gf ||\n          (gf.hasMethod\n          ? !gf.hasMethod.apply(gf, args)\n          : typeof gf === 'function')) {\n        return false\n      }\n    }\n    return true\n  }\n\n  // MyDuck.matches('a', ['this', 'c'])\n  matches (thisType, argTypes) {\n    if (!argTypes && isArray(thisType)) {\n      argTypes = thisType\n      thisType = 'this'\n    }\n    if (!thisType) {\n      thisType = 'this'\n    }\n    if (!argTypes) {\n      argTypes = []\n    }\n    return new Constraint(this, thisType, argTypes)\n  }\n}\nDuck.prototype.isDuck = true\nDuck.prototype.isProtocol = true\n\nconst Protoduck = module.exports = define(['duck'], {\n  createGenfun: ['duck', _metaCreateGenfun],\n  addMethod: ['duck', _metaAddMethod]\n}, {name: 'Protoduck'})\n\nconst noImplFound = module.exports.noImplFound = genfun.noApplicableMethod\n\nmodule.exports.define = define\nfunction define (types, spec, opts) {\n  if (!isArray(types)) {\n    // protocol(spec, opts?) syntax for method-based protocols\n    opts = spec\n    spec = types\n    types = []\n  }\n  const duck = function (thisType, argTypes) {\n    return duck.matches(thisType, argTypes)\n  }\n  Object.setPrototypeOf(duck, Duck.prototype)\n  duck.isDerivable = true\n  Object.defineProperty(duck, 'name', {\n    value: (opts && opts.name) || 'Protocol'\n  })\n  if (opts && opts.where) {\n    let where = opts.where\n    if (!isArray(opts.where)) { where = [opts.where] }\n    duck._constraints = where.map(w => w.isProtocol // `where: [Foo]`\n      ? w.matches()\n      : w\n    )\n  } else {\n    duck._constraints = []\n  }\n  duck.isProtocol = true\n  duck._metaobject = opts && opts.metaobject\n  duck._types = types\n  duck._defaultImpls = {}\n  duck._gfTypes = {}\n  duck._methodNames = Object.keys(spec)\n  duck._methodNames.forEach(name => {\n    checkMethodSpec(duck, name, spec)\n  })\n  duck._constraints.forEach(c => c.attach(duck))\n  return duck\n}\n\nfunction checkMethodSpec (duck, name, spec) {\n  let gfTypes = spec[name]\n  if (typeof gfTypes === 'function') {\n    duck._defaultImpls[name] = gfTypes\n    gfTypes = [gfTypes]\n  } if (typeof gfTypes[gfTypes.length - 1] === 'function') {\n    duck._defaultImpls[name] = gfTypes.pop()\n  } else {\n    duck.isDerivable = false\n  }\n  duck._gfTypes[name] = gfTypes.map(typeId => {\n    const idx = duck._types.indexOf(typeId)\n    if (idx === -1) {\n      throw new Error(\n        `type '${\n          typeId\n        }' for function '${\n          name\n        }' does not match any protocol types (${\n          duck._types.join(', ')\n        }).`\n      )\n    } else {\n      return idx\n    }\n  })\n}\n\nfunction defineMethod (duck, name, target, types, impls) {\n  const methodTypes = duck._gfTypes[name].map(function (typeIdx) {\n    return types[typeIdx]\n  })\n  for (let i = methodTypes.length - 1; i >= 0; i--) {\n    if (methodTypes[i] === undefined) {\n      methodTypes.pop()\n    } else {\n      break\n    }\n  }\n  const useMetaobject = duck._metaobject && duck._metaobject !== Protoduck\n  // `target` does not necessarily inherit from `Object`\n  if (!Object.prototype.hasOwnProperty.call(target, name)) {\n    // Make a genfun if there's nothing there\n    const gf = useMetaobject\n    ? duck._metaobject.createGenfun(duck, target, name, null)\n    : _metaCreateGenfun(duck, target, name, null)\n    target[name] = gf\n  } else if (typeof target[name] === 'function' && !target[name].isGenfun) {\n    // Turn non-gf functions into genfuns\n    const gf = useMetaobject\n    ? duck._metaobject.createGenfun(duck, target, name, target[name])\n    : _metaCreateGenfun(duck, target, name, target[name])\n    target[name] = gf\n  }\n\n  const fn = impls[name] || duck._defaultImpls[name]\n  if (fn) { // checkImpls made sure this is safe\n    useMetaobject\n    ? duck._metaobject.addMethod(duck, target, name, methodTypes, fn)\n    : _metaAddMethod(duck, target, name, methodTypes, fn)\n  }\n}\n\nfunction checkImpls (duck, target, impls) {\n  duck._methodNames.forEach(function (name) {\n    if (\n      !impls[name] &&\n      !duck._defaultImpls[name] &&\n      // Existing methods on the target are acceptable defaults.\n      typeof target[name] !== 'function'\n    ) {\n      throw new Error(`Missing implementation for ${\n        formatMethod(duck, name, duck.name)\n      }. Make sure the method is present in your ${\n        duck.name || 'protocol'\n      } definition. Required methods: ${\n        duck._methodNames.filter(m => {\n          return !duck._defaultImpls[m]\n        }).map(m => formatMethod(duck, m)).join(', ')\n      }.`)\n    }\n  })\n  Object.keys(impls).forEach(function (name) {\n    if (duck._methodNames.indexOf(name) === -1) {\n      throw new Error(\n        `${name}() was included in the impl, but is not part of ${\n          duck.name || 'the protocol'\n        }. Allowed methods: ${\n          duck._methodNames.map(m => formatMethod(duck, m)).join(', ')\n        }.`\n      )\n    }\n  })\n}\n\nfunction formatMethod (duck, name, withDuckName) {\n  return `${\n    withDuckName && duck.name ? `${duck.name}#` : ''\n  }${name}(${duck._gfTypes[name].map(n => duck._types[n]).join(', ')})`\n}\n\nfunction checkArgTypes (duck, types) {\n  var requiredTypes = duck._types\n  if (types.length > requiredTypes.length) {\n    throw new Error(\n      `${\n        duck.name || 'Protocol'\n      } expects to be defined across ${\n        requiredTypes.length\n      } type${requiredTypes.length > 1 ? 's' : ''}, but ${\n        types.length\n      } ${types.length > 1 ? 'were' : 'was'} specified.`\n    )\n  }\n}\n\nfunction typeName (obj) {\n  return (/\\[object ([a-zA-Z0-9]+)\\]/).exec(({}).toString.call(obj))[1]\n}\n\nfunction installMethodErrorMessage (proto, gf, target, name) {\n  noImplFound.add([gf], function (gf, thisArg, args) {\n    let parent = Object.getPrototypeOf(thisArg)\n    while (parent && parent[name] === gf) {\n      parent = Object.getPrototypeOf(parent)\n    }\n    if (parent && parent[name] && typeof parent[name] === 'function') {\n    }\n    var msg = `No ${typeName(thisArg)} impl for ${\n      proto.name ? `${proto.name}#` : ''\n    }${name}(${[].map.call(args, typeName).join(', ')}). You must implement ${\n      proto.name\n      ? formatMethod(proto, name, true)\n      : `the protocol ${formatMethod(proto, name)} belongs to`\n    } in order to call ${typeName(thisArg)}#${name}(${\n      [].map.call(args, typeName).join(', ')\n    }).`\n    const err = new Error(msg)\n    err.protocol = proto\n    err.function = gf\n    err.thisArg = thisArg\n    err.args = args\n    err.code = 'ENOIMPL'\n    throw err\n  })\n}\n\nfunction isArray (x) {\n  return Object.prototype.toString.call(x) === '[object Array]'\n}\n\n// Metaobject Protocol\nProtoduck.impl(Protoduck) // defaults configured by definition\n\nfunction _metaCreateGenfun (proto, target, name, deflt) {\n  var gf = genfun({\n    default: deflt,\n    name: `${proto.name ? `${proto.name}#` : ''}${name}`\n  })\n  installMethodErrorMessage(proto, gf, target, name)\n  gf.duck = proto\n  return gf\n}\n\nfunction _metaAddMethod (duck, target, name, methodTypes, fn) {\n  return target[name].add(methodTypes, fn)\n}\n\n// Constraints\nclass Constraint {\n  constructor (parent, thisType, argTypes) {\n    this.parent = parent\n    this.target = thisType\n    this.types = argTypes\n  }\n\n  attach (obj) {\n    this.child = obj\n    if (this.target === 'this') {\n      this.thisIdx = 'this'\n    } else {\n      const idx = this.child._types.indexOf(this.target)\n      if (idx === -1) {\n        this.thisIdx = null\n      } else {\n        this.thisIdx = idx\n      }\n    }\n    this.indices = this.types.map(typeId => {\n      if (typeId === 'this') {\n        return 'this'\n      } else {\n        const idx = this.child._types.indexOf(typeId)\n        if (idx === -1) {\n          return null\n        } else {\n          return idx\n        }\n      }\n    })\n  }\n\n  verify (target, types) {\n    const thisType = (\n      this.thisIdx === 'this' || this.thisIdx == null\n    )\n    ? target\n    : types[this.thisIdx]\n    const parentTypes = this.indices.map(idx => {\n      if (idx === 'this') {\n        return target\n      } else if (idx === 'this') {\n        return types[this.thisIdx]\n      } else if (idx === null) {\n        return Object\n      } else {\n        return types[idx] || Object.prototype\n      }\n    })\n    return this.parent.hasImpl(thisType, parentTypes)\n  }\n}\nConstraint.prototype.isConstraint = true\n"]}