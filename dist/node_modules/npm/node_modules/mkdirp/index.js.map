{"version":3,"sources":["../../../../../node_modules/npm/node_modules/mkdirp/index.js"],"names":["path","require","fs","_0777","parseInt","module","exports","mkdirP","mkdirp","p","opts","f","made","mode","xfs","undefined","process","umask","cb","resolve","mkdir","er","code","dirname","stat","er2","isDirectory","sync","mkdirSync","err0","statSync","err1"],"mappings":"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","file":"index.js","sourcesContent":["var path = require('path');\nvar fs = require('fs');\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n"]}