'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _path = void 0;

var LogicalTree = function () {
  function LogicalTree(name, address, opts) {
    _classCallCheck(this, LogicalTree);

    this.name = name;
    this.version = opts.version;
    this.address = address || '';
    this.optional = !!opts.optional;
    this.dev = !!opts.dev;
    this.bundled = !!opts.bundled;
    this.resolved = opts.resolved;
    this.integrity = opts.integrity;
    this.dependencies = new Map();
    this.requiredBy = new Set();
  }

  _createClass(LogicalTree, [{
    key: 'addDep',
    value: function addDep(dep) {
      this.dependencies.set(dep.name, dep);
      dep.requiredBy.add(this);
      return this;
    }
  }, {
    key: 'delDep',
    value: function delDep(dep) {
      this.dependencies.delete(dep.name);
      dep.requiredBy.delete(this);
      return this;
    }
  }, {
    key: 'getDep',
    value: function getDep(name) {
      return this.dependencies.get(name);
    }
  }, {
    key: 'path',
    value: function path(prefix) {
      if (this.isRoot) {
        // The address of the root is the prefix itself.
        return prefix || '';
      } else {
        if (!_path) {
          _path = require('path');
        }
        return _path.join(prefix || '', 'node_modules', this.address.replace(/:/g, '/node_modules/'));
      }
    }

    // This finds cycles _from_ a given node: if some deeper dep has
    // its own cycle, but that cycle does not refer to this node,
    // it will return false.

  }, {
    key: 'hasCycle',
    value: function hasCycle(_seen, _from) {
      if (!_seen) {
        _seen = new Set();
      }
      if (!_from) {
        _from = this;
      }
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.dependencies.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var dep = _step.value;

          if (_seen.has(dep)) {
            continue;
          }
          _seen.add(dep);
          if (dep === _from || dep.hasCycle(_seen, _from)) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return false;
    }
  }, {
    key: 'forEachAsync',
    value: function forEachAsync(fn, opts, _pending) {
      var _this = this;

      if (!opts) {
        opts = _pending || {};
      }
      if (!_pending) {
        _pending = new Map();
      }
      var P = opts.Promise || Promise;
      if (_pending.has(this)) {
        return P.resolve(this.hasCycle() || _pending.get(this));
      }
      var pending = P.resolve().then(function () {
        return fn(_this, function () {
          return promiseMap(_this.dependencies.values(), function (dep) {
            return dep.forEachAsync(fn, opts, _pending);
          }, opts);
        });
      });
      _pending.set(this, pending);
      return pending;
    }
  }, {
    key: 'forEach',
    value: function forEach(fn, _seen) {
      var _this2 = this;

      if (!_seen) {
        _seen = new Set();
      }
      if (_seen.has(this)) {
        return;
      }
      _seen.add(this);
      fn(this, function () {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = _this2.dependencies.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var dep = _step2.value;

            dep.forEach(fn, _seen);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      });
    }
  }, {
    key: 'isRoot',
    get: function get() {
      return !this.requiredBy.size;
    }
  }]);

  return LogicalTree;
}();

module.exports = lockTree;
function lockTree(pkg, pkgLock, opts) {
  var tree = makeNode(pkg.name, null, pkg);
  var allDeps = new Map();
  Array.from(new Set(Object.keys(pkg.devDependencies || {}).concat(Object.keys(pkg.optionalDependencies || {})).concat(Object.keys(pkg.dependencies || {})))).forEach(function (name) {
    var dep = allDeps.get(name);
    if (!dep) {
      var depNode = (pkgLock.dependencies || {})[name];
      dep = makeNode(name, name, depNode);
    }
    addChild(dep, tree, allDeps, pkgLock);
  });
  return tree;
}

module.exports.node = makeNode;
function makeNode(name, address, opts) {
  return new LogicalTree(name, address, opts || {});
}

function addChild(dep, tree, allDeps, pkgLock) {
  tree.addDep(dep);
  allDeps.set(dep.address, dep);
  var addr = dep.address;
  var lockNode = atAddr(pkgLock, addr);
  Object.keys(lockNode.requires || {}).forEach(function (name) {
    var tdepAddr = reqAddr(pkgLock, name, addr);
    var tdep = allDeps.get(tdepAddr);
    if (!tdep) {
      tdep = makeNode(name, tdepAddr, atAddr(pkgLock, tdepAddr));
      addChild(tdep, dep, allDeps, pkgLock);
    } else {
      dep.addDep(tdep);
    }
  });
}

module.exports._reqAddr = reqAddr;
function reqAddr(pkgLock, name, fromAddr) {
  var lockNode = atAddr(pkgLock, fromAddr);
  var child = (lockNode.dependencies || {})[name];
  if (child) {
    return fromAddr + ':' + name;
  } else {
    var parts = fromAddr.split(':');
    while (parts.length) {
      parts.pop();
      var joined = parts.join(':');
      var parent = atAddr(pkgLock, joined);
      if (parent) {
        var _child = (parent.dependencies || {})[name];
        if (_child) {
          return '' + joined + (parts.length ? ':' : '') + name;
        }
      }
    }
    var err = new Error(name + ' not accessible from ' + fromAddr);
    err.pkgLock = pkgLock;
    err.target = name;
    err.from = fromAddr;
    throw err;
  }
}

module.exports._atAddr = atAddr;
function atAddr(pkgLock, addr) {
  if (!addr.length) {
    return pkgLock;
  }
  var parts = addr.split(':');
  return parts.reduce(function (acc, next) {
    return acc && (acc.dependencies || {})[next];
  }, pkgLock);
}

function promiseMap(arr, fn, opts, _index) {
  _index = _index || 0;
  var P = opts && opts.Promise || Promise;
  if (P.map) {
    return P.map(arr, fn, opts);
  } else {
    if (!(arr instanceof Array)) {
      arr = Array.from(arr);
    }
    if (_index >= arr.length) {
      return P.resolve();
    } else {
      return P.resolve(fn(arr[_index], _index, arr)).then(function () {
        return promiseMap(arr, fn, opts, _index + 1);
      });
    }
  }
}
//# sourceMappingURL=index.js.map