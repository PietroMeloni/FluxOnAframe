'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BB = require('bluebird');

var binLink = require('bin-links');
var buildLogicalTree = require('npm-logical-tree');
var extract = require('./lib/extract.js');
var fs = require('graceful-fs');
var getPrefix = require('find-npm-prefix');
var lifecycle = require('npm-lifecycle');
var lockVerify = require('lock-verify');
var mkdirp = BB.promisify(require('mkdirp'));
var npa = require('npm-package-arg');
var path = require('path');
var readPkgJson = BB.promisify(require('read-package-json'));
var rimraf = BB.promisify(require('rimraf'));

var readFileAsync = BB.promisify(fs.readFile);
var statAsync = BB.promisify(fs.stat);
var symlinkAsync = BB.promisify(fs.symlink);
var writeFileAsync = BB.promisify(fs.writeFile);

var Installer = function () {
  function Installer(opts) {
    _classCallCheck(this, Installer);

    this.opts = opts;
    this.config = opts.config;

    // Stats
    this.startTime = Date.now();
    this.runTime = 0;
    this.timings = { scripts: 0 };
    this.pkgCount = 0;

    // Misc
    this.log = this.opts.log || require('./lib/silentlog.js');
    this.pkg = null;
    this.tree = null;
    this.failedDeps = new Set();
  }

  _createClass(Installer, [{
    key: 'timedStage',
    value: function timedStage(name) {
      var _this = this;

      var start = Date.now();
      return BB.resolve(this[name].apply(this, [].slice.call(arguments, 1))).tap(function () {
        _this.timings[name] = Date.now() - start;
        _this.log.info(name, 'Done in ' + _this.timings[name] / 1000 + 's');
      });
    }
  }, {
    key: 'run',
    value: function run() {
      var _this2 = this;

      return this.timedStage('prepare').then(function () {
        return _this2.timedStage('extractTree', _this2.tree);
      }).then(function () {
        return _this2.timedStage('updateJson', _this2.tree);
      }).then(function (pkgJsons) {
        return _this2.timedStage('buildTree', _this2.tree, pkgJsons);
      }).then(function () {
        return _this2.timedStage('garbageCollect', _this2.tree);
      }).then(function () {
        return _this2.timedStage('runScript', 'prepublish', _this2.pkg, _this2.prefix);
      }).then(function () {
        return _this2.timedStage('runScript', 'prepare', _this2.pkg, _this2.prefix);
      }).then(function () {
        return _this2.timedStage('teardown');
      }).then(function () {
        _this2.runTime = Date.now() - _this2.startTime;
        _this2.log.info('run-scripts', 'total script time: ' + _this2.timings.scripts / 1000 + 's');
        _this2.log.info('run-time', 'total run time: ' + _this2.runTime / 1000 + 's');
      }).catch(function (err) {
        _this2.timedStage('teardown');
        if (err.message.match(/aggregate error/)) {
          throw err[0];
        } else {
          throw err;
        }
      }).then(function () {
        return _this2;
      });
    }
  }, {
    key: 'prepare',
    value: function prepare() {
      var _this3 = this;

      this.log.info('prepare', 'initializing installer');
      this.log.level = this.config.get('loglevel');
      this.log.verbose('prepare', 'starting workers');
      extract.startWorkers();

      return (this.config.get('prefix') && this.config.get('global') ? BB.resolve(this.config.get('prefix'))
      // There's some Specialâ„¢ logic around the `--prefix` config when it
      // comes from a config file or env vs when it comes from the CLI
      : process.argv.some(function (arg) {
        return arg.match(/^\s*--prefix\s*/i);
      }) ? BB.resolve(this.config.get('prefix')) : getPrefix(process.cwd())).then(function (prefix) {
        _this3.prefix = prefix;
        _this3.log.verbose('prepare', 'installation prefix: ' + prefix);
        return BB.join(readJson(prefix, 'package.json'), readJson(prefix, 'package-lock.json', true), readJson(prefix, 'npm-shrinkwrap.json', true), function (pkg, lock, shrink) {
          if (shrink) {
            _this3.log.verbose('prepare', 'using npm-shrinkwrap.json');
          } else if (lock) {
            _this3.log.verbose('prepare', 'using package-lock.json');
          }
          pkg._shrinkwrap = shrink || lock;
          _this3.pkg = pkg;
        });
      }).then(function () {
        return statAsync(path.join(_this3.prefix, 'node_modules')).catch(function (err) {
          if (err.code !== 'ENOENT') {
            throw err;
          }
        });
      }).then(function (stat) {
        stat && _this3.log.warn('prepare', 'removing existing node_modules/ before installation');
        return BB.join(_this3.checkLock(), stat && rimraf(path.join(_this3.prefix, 'node_modules')));
      }).then(function () {
        // This needs to happen -after- we've done checkLock()
        _this3.tree = buildLogicalTree(_this3.pkg, _this3.pkg._shrinkwrap);
        _this3.log.silly('tree', _this3.tree);
        _this3.expectedTotal = 0;
        _this3.tree.forEach(function (dep, next) {
          _this3.expectedTotal++;
          next();
        });
      });
    }
  }, {
    key: 'teardown',
    value: function teardown() {
      this.log.verbose('teardown', 'shutting down workers.');
      return extract.stopWorkers();
    }
  }, {
    key: 'checkLock',
    value: function checkLock() {
      var _this4 = this;

      this.log.verbose('checkLock', 'verifying package-lock data');
      var pkg = this.pkg;
      var prefix = this.prefix;
      if (!pkg._shrinkwrap || !pkg._shrinkwrap.lockfileVersion) {
        return BB.reject(new Error('cipm can only install packages with an existing package-lock.json or npm-shrinkwrap.json with lockfileVersion >= 1. Run an install with npm@5 or later to generate it, then try again.'));
      }
      return lockVerify(prefix).then(function (result) {
        if (result.status) {
          result.warnings.forEach(function (w) {
            return _this4.log.warn('lockfile', w);
          });
        } else {
          throw new Error('cipm can only install packages when your package.json and package-lock.json or ' + 'npm-shrinkwrap.json are in sync. Please update your lock file with `npm install` ' + 'before continuing.\n\n' + result.warnings.map(function (w) {
            return 'Warning: ' + w;
          }).join('\n') + '\n' + result.errors.join('\n') + '\n');
        }
      }).catch(function (err) {
        throw err;
      });
    }
  }, {
    key: 'extractTree',
    value: function extractTree(tree) {
      var _this5 = this;

      this.log.verbose('extractTree', 'extracting dependencies to node_modules/');
      var cg = this.log.newItem('extractTree', this.expectedTotal);
      return tree.forEachAsync(function (dep, next) {
        if (!_this5.checkDepEnv(dep)) {
          return;
        }
        var depPath = dep.path(_this5.prefix);
        var spec = npa.resolve(dep.name, dep.version, _this5.prefix);
        if (dep.isRoot) {
          return next();
        } else if (spec.type === 'directory') {
          var relative = path.relative(path.dirname(depPath), spec.fetchSpec);
          _this5.log.silly('extractTree', dep.name + '@' + spec.fetchSpec + ' -> ' + depPath + ' (symlink)');
          return mkdirp(path.dirname(depPath)).then(function () {
            return symlinkAsync(relative, depPath, 'junction');
          }).catch(function () {
            return rimraf(depPath).then(function () {
              return symlinkAsync(relative, depPath, 'junction');
            });
          }).then(function () {
            return next();
          }).then(function () {
            _this5.pkgCount++;
            cg.completeWork(1);
          });
        } else {
          _this5.log.silly('extractTree', dep.name + '@' + dep.version + ' -> ' + depPath);
          return (dep.bundled ? statAsync(path.join(depPath, 'package.json')).catch(function (err) {
            if (err.code !== 'ENOENT') {
              throw err;
            }
          }) : BB.resolve(false)).then(function (wasBundled) {
            // Don't extract if a bundled dep is actually present
            if (wasBundled) {
              cg.completeWork(1);
              return next();
            } else {
              return BB.resolve(extract.child(dep.name, dep, depPath, _this5.config, _this5.opts)).then(function () {
                return cg.completeWork(1);
              }).then(function () {
                _this5.pkgCount++;
              }).then(next);
            }
          });
        }
      }, { concurrency: 50, Promise: BB }).then(function () {
        return cg.finish();
      });
    }
  }, {
    key: 'checkDepEnv',
    value: function checkDepEnv(dep) {
      var includeDev =
      // Covers --dev and --development (from npm config itself)
      this.config.get('dev') || !/^prod(uction)?$/.test(this.config.get('only')) && !this.config.get('production') || /^dev(elopment)?$/.test(this.config.get('only')) || /^dev(elopment)?$/.test(this.config.get('also'));
      var includeProd = !/^dev(elopment)?$/.test(this.config.get('only'));
      return dep.dev && includeDev || !dep.dev && includeProd;
    }
  }, {
    key: 'updateJson',
    value: function updateJson(tree) {
      var _this6 = this;

      this.log.verbose('updateJson', 'updating json deps to include _from');
      var pkgJsons = new Map();
      return tree.forEachAsync(function (dep, next) {
        if (!_this6.checkDepEnv(dep)) {
          return;
        }
        var spec = npa.resolve(dep.name, dep.version);
        var depPath = dep.path(_this6.prefix);
        return next().then(function () {
          return readJson(depPath, 'package.json');
        }).then(function (pkg) {
          return spec.registry || spec.type === 'directory' ? pkg : _this6.updateFromField(dep, pkg).then(function () {
            return pkg;
          });
        }).then(function (pkg) {
          return pkg.scripts && pkg.scripts.install ? pkg : _this6.updateInstallScript(dep, pkg).then(function () {
            return pkg;
          });
        }).tap(function (pkg) {
          pkgJsons.set(dep, pkg);
        });
      }, { concurrency: 100, Promise: BB }).then(function () {
        return pkgJsons;
      });
    }
  }, {
    key: 'buildTree',
    value: function buildTree(tree, pkgJsons) {
      var _this7 = this;

      this.log.verbose('buildTree', 'finalizing tree and running scripts');
      return tree.forEachAsync(function (dep, next) {
        if (!_this7.checkDepEnv(dep)) {
          return;
        }
        var spec = npa.resolve(dep.name, dep.version);
        var depPath = dep.path(_this7.prefix);
        var pkg = pkgJsons.get(dep);
        _this7.log.silly('buildTree', 'linking ' + spec);
        return _this7.runScript('preinstall', pkg, depPath).then(next) // build children between preinstall and binLink
        // Don't link root bins
        .then(function () {
          if (dep.isRoot || !(pkg.bin || pkg.man || pkg.directories && pkg.directories.bin)) {
            // We skip the relatively expensive readPkgJson if there's no way
            // we'll actually be linking any bins or mans
            return;
          }
          return readPkgJson(path.join(depPath, 'package.json')).then(function (pkg) {
            return binLink(pkg, depPath, false, {
              force: _this7.config.get('force'),
              ignoreScripts: _this7.config.get('ignore-scripts'),
              log: Object.assign({}, _this7.log, { info: function info() {} }),
              name: pkg.name,
              pkgId: pkg.name + '@' + pkg.version,
              prefix: _this7.prefix,
              prefixes: [_this7.prefix],
              umask: _this7.config.get('umask')
            });
          }, function (e) {
            _this7.log.verbose('buildTree', 'error linking ' + spec + ': ' + e.message + ' ' + e.stack);
          });
        }).then(function () {
          return _this7.runScript('install', pkg, depPath);
        }).then(function () {
          return _this7.runScript('postinstall', pkg, depPath);
        }).then(function () {
          return _this7;
        }).catch(function (e) {
          if (dep.optional) {
            _this7.failedDeps.add(dep);
          } else {
            throw e;
          }
        });
      }, { concurrency: 1, Promise: BB });
    }
  }, {
    key: 'updateFromField',
    value: function updateFromField(dep, pkg) {
      var depPath = dep.path(this.prefix);
      var depPkgPath = path.join(depPath, 'package.json');
      var parent = dep.requiredBy.values().next().value;
      return readJson(parent.path(this.prefix), 'package.json').then(function (ppkg) {
        return ppkg.dependencies && ppkg.dependencies[dep.name] || ppkg.devDependencies && ppkg.devDependencies[dep.name] || ppkg.optionalDependencies && ppkg.optionalDependencies[dep.name];
      }).then(function (from) {
        return npa.resolve(dep.name, from);
      }).then(function (from) {
        pkg._from = from.toString();
      }).then(function () {
        return writeFileAsync(depPkgPath, JSON.stringify(pkg, null, 2));
      }).then(pkg);
    }
  }, {
    key: 'updateInstallScript',
    value: function updateInstallScript(dep, pkg) {
      var depPath = dep.path(this.prefix);
      return statAsync(path.join(depPath, 'binding.gyp')).catch(function (err) {
        if (err.code !== 'ENOENT') {
          throw err;
        }
      }).then(function (stat) {
        if (stat) {
          if (!pkg.scripts) {
            pkg.scripts = {};
          }
          pkg.scripts.install = 'node-gyp rebuild';
        }
      }).then(pkg);
    }

    // A cute little mark-and-sweep collector!

  }, {
    key: 'garbageCollect',
    value: function garbageCollect(tree) {
      var _this8 = this;

      if (!this.failedDeps.size) {
        return;
      }
      return sweep(tree, this.prefix, mark(tree, this.failedDeps)).then(function (purged) {
        _this8.purgedDeps = purged;
        _this8.pkgCount -= purged.size;
      });
    }
  }, {
    key: 'runScript',
    value: function runScript(stage, pkg, pkgPath) {
      var _this9 = this;

      var start = Date.now();
      if (!this.config.get('ignore-scripts')) {
        // TODO(mikesherov): remove pkg._id when npm-lifecycle no longer relies on it
        pkg._id = pkg.name + '@' + pkg.version;
        var opts = this.config.toLifecycle();
        return BB.resolve(lifecycle(pkg, stage, pkgPath, opts)).tap(function () {
          _this9.timings.scripts += Date.now() - start;
        });
      }
      return BB.resolve();
    }
  }]);

  return Installer;
}();

module.exports = Installer;
module.exports.CipmConfig = require('./lib/config/npm-config.js').CipmConfig;

function mark(tree, failed) {
  var liveDeps = new Set();
  tree.forEach(function (dep, next) {
    if (!failed.has(dep)) {
      liveDeps.add(dep);
      next();
    }
  });
  return liveDeps;
}

function sweep(tree, prefix, liveDeps) {
  var purged = new Set();
  return tree.forEachAsync(function (dep, next) {
    return next().then(function () {
      if (!dep.isRoot && // never purge root! ðŸ™ˆ
      !liveDeps.has(dep) && !purged.has(dep)) {
        purged.add(dep);
        return rimraf(dep.path(prefix));
      }
    });
  }, { concurrency: 50, Promise: BB }).then(function () {
    return purged;
  });
}

function stripBOM(str) {
  return str.replace(/^\uFEFF/, '');
}

module.exports._readJson = readJson;
function readJson(jsonPath, name, ignoreMissing) {
  return readFileAsync(path.join(jsonPath, name), 'utf8').then(function (str) {
    return JSON.parse(stripBOM(str));
  }).catch({ code: 'ENOENT' }, function (err) {
    if (!ignoreMissing) {
      throw err;
    }
  });
}
//# sourceMappingURL=index.js.map