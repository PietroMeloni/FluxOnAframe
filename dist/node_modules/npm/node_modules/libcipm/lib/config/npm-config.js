'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BB = require('bluebird');
var lifecycleOpts = require('./lifecycle-opts.js');
var pacoteOpts = require('./pacote-opts.js');
var protoduck = require('protoduck');
var spawn = require('child_process').spawn;

var NpmConfig = function (_Map) {
  _inherits(NpmConfig, _Map);

  function NpmConfig() {
    _classCallCheck(this, NpmConfig);

    return _possibleConstructorReturn(this, (NpmConfig.__proto__ || Object.getPrototypeOf(NpmConfig)).apply(this, arguments));
  }

  return NpmConfig;
}(Map);

var CipmConfig = protoduck.define({
  get: [],
  set: [],
  toPacote: [],
  toLifecycle: []
}, {
  name: 'CipmConfig'
});
module.exports.CipmConfig = CipmConfig;

CipmConfig.impl(NpmConfig, {
  get: Map.prototype.get,
  set: Map.prototype.set,
  toPacote: function toPacote(opts) {
    return pacoteOpts(this, opts);
  },
  toLifecycle: function toLifecycle() {
    return lifecycleOpts(this);
  }
});

module.exports.fromObject = fromObj;
function fromObj(obj) {
  var map = new NpmConfig();
  Object.keys(obj).forEach(function (k) {
    return map.set(k, obj[k]);
  });
  return map;
}

module.exports.fromNpm = getNpmConfig;
function getNpmConfig(argv) {
  return new BB(function (resolve, reject) {
    var npmBin = process.platform === 'win32' ? 'npm.cmd' : 'npm';
    var child = spawn(npmBin, ['config', 'ls', '--json', '-l'
    // We add argv here to get npm to parse those options for us :D
    ].concat(argv || []), {
      env: process.env,
      cwd: process.cwd(),
      stdio: [0, 'pipe', 2]
    });

    var stdout = '';
    if (child.stdout) {
      child.stdout.on('data', function (chunk) {
        stdout += chunk;
      });
    }

    child.on('error', reject);
    child.on('close', function (code) {
      if (code === 127) {
        reject(new Error('`npm` command not found. Please ensure you have npm@5.4.0 or later installed.'));
      } else {
        try {
          resolve(fromObj(JSON.parse(stdout)));
        } catch (e) {
          reject(new Error('`npm config ls --json` failed to output json. Please ensure you have npm@5.4.0 or later installed.'));
        }
      }
    });
  });
}
//# sourceMappingURL=npm-config.js.map