{"version":3,"sources":["../../../../../node_modules/npm/node_modules/spdx-expression-parse/scan.js"],"names":["licenses","concat","require","exceptions","module","exports","source","index","hasMore","length","read","value","RegExp","chars","slice","match","indexOf","skipWhitespace","operator","string","possibilities","i","Error","type","idstring","expectIdstring","documentRef","licenseRef","identifier","begin","parseToken","tokens","token","push"],"mappings":"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","file":"scan.js","sourcesContent":["'use strict'\n\nvar licenses = []\n  .concat(require('spdx-license-ids'))\n  .concat(require('spdx-license-ids/deprecated'))\nvar exceptions = require('spdx-exceptions')\n\nmodule.exports = function (source) {\n  var index = 0\n\n  function hasMore () {\n    return index < source.length\n  }\n\n  // `value` can be a regexp or a string.\n  // If it is recognized, the matching source string is returned and\n  // the index is incremented. Otherwise `undefined` is returned.\n  function read (value) {\n    if (value instanceof RegExp) {\n      var chars = source.slice(index)\n      var match = chars.match(value)\n      if (match) {\n        index += match[0].length\n        return match[0]\n      }\n    } else {\n      if (source.indexOf(value, index) === index) {\n        index += value.length\n        return value\n      }\n    }\n  }\n\n  function skipWhitespace () {\n    read(/[ ]*/)\n  }\n\n  function operator () {\n    var string\n    var possibilities = ['WITH', 'AND', 'OR', '(', ')', ':', '+']\n    for (var i = 0; i < possibilities.length; i++) {\n      string = read(possibilities[i])\n      if (string) {\n        break\n      }\n    }\n\n    if (string === '+' && index > 1 && source[index - 2] === ' ') {\n      throw new Error('Space before `+`')\n    }\n\n    return string && {\n      type: 'OPERATOR',\n      string: string\n    }\n  }\n\n  function idstring () {\n    return read(/[A-Za-z0-9-.]+/)\n  }\n\n  function expectIdstring () {\n    var string = idstring()\n    if (!string) {\n      throw new Error('Expected idstring at offset ' + index)\n    }\n    return string\n  }\n\n  function documentRef () {\n    if (read('DocumentRef-')) {\n      var string = expectIdstring()\n      return {type: 'DOCUMENTREF', string: string}\n    }\n  }\n\n  function licenseRef () {\n    if (read('LicenseRef-')) {\n      var string = expectIdstring()\n      return {type: 'LICENSEREF', string: string}\n    }\n  }\n\n  function identifier () {\n    var begin = index\n    var string = idstring()\n\n    if (licenses.indexOf(string) !== -1) {\n      return {\n        type: 'LICENSE',\n        string: string\n      }\n    } else if (exceptions.indexOf(string) !== -1) {\n      return {\n        type: 'EXCEPTION',\n        string: string\n      }\n    }\n\n    index = begin\n  }\n\n  // Tries to read the next token. Returns `undefined` if no token is\n  // recognized.\n  function parseToken () {\n    // Ordering matters\n    return (\n      operator() ||\n      documentRef() ||\n      licenseRef() ||\n      identifier()\n    )\n  }\n\n  var tokens = []\n  while (hasMore()) {\n    skipWhitespace()\n    if (!hasMore()) {\n      break\n    }\n\n    var token = parseToken()\n    if (!token) {\n      throw new Error('Unexpected `' + source[index] +\n                      '` at offset ' + index)\n    }\n\n    tokens.push(token)\n  }\n  return tokens\n}\n"]}