{"version":3,"sources":["../../../../../node_modules/npm/node_modules/spdx-expression-parse/parse.js"],"names":["module","exports","tokens","index","hasMore","length","token","next","Error","parseOperator","operator","t","type","string","parseWith","parseLicenseRef","begin","license","parseLicense","node","plus","exception","parseParenthesizedExpression","left","expr","parseExpression","parseAtom","makeBinaryOpParser","nextParser","parseBinaryOp","right","conjunction","toLowerCase","parseAnd"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;;AAEAA,OAAOC,OAAP,GAAiB,UAAUC,MAAV,EAAkB;AACjC,MAAIC,QAAQ,CAAZ;;AAEA,WAASC,OAAT,GAAoB;AAClB,WAAOD,QAAQD,OAAOG,MAAtB;AACD;;AAED,WAASC,KAAT,GAAkB;AAChB,WAAOF,YAAYF,OAAOC,KAAP,CAAZ,GAA4B,IAAnC;AACD;;AAED,WAASI,IAAT,GAAiB;AACf,QAAI,CAACH,SAAL,EAAgB;AACd,YAAM,IAAII,KAAJ,EAAN;AACD;AACDL;AACD;;AAED,WAASM,aAAT,CAAwBC,QAAxB,EAAkC;AAChC,QAAIC,IAAIL,OAAR;AACA,QAAIK,KAAKA,EAAEC,IAAF,KAAW,UAAhB,IAA8BF,aAAaC,EAAEE,MAAjD,EAAyD;AACvDN;AACA,aAAOI,EAAEE,MAAT;AACD;AACF;;AAED,WAASC,SAAT,GAAsB;AACpB,QAAIL,cAAc,MAAd,CAAJ,EAA2B;AACzB,UAAIE,IAAIL,OAAR;AACA,UAAIK,KAAKA,EAAEC,IAAF,KAAW,WAApB,EAAiC;AAC/BL;AACA,eAAOI,EAAEE,MAAT;AACD;AACD,YAAM,IAAIL,KAAJ,CAAU,iCAAV,CAAN;AACD;AACF;;AAED,WAASO,eAAT,GAA4B;AAC1B;AACA;AACA;AACA,QAAIC,QAAQb,KAAZ;AACA,QAAIU,SAAS,EAAb;AACA,QAAIF,IAAIL,OAAR;AACA,QAAIK,EAAEC,IAAF,KAAW,aAAf,EAA8B;AAC5BL;AACAM,gBAAU,iBAAiBF,EAAEE,MAAnB,GAA4B,GAAtC;AACA,UAAI,CAACJ,cAAc,GAAd,CAAL,EAAyB;AACvB,cAAM,IAAID,KAAJ,CAAU,sCAAV,CAAN;AACD;AACF;AACDG,QAAIL,OAAJ;AACA,QAAIK,EAAEC,IAAF,KAAW,YAAf,EAA6B;AAC3BL;AACAM,gBAAU,gBAAgBF,EAAEE,MAA5B;AACA,aAAO,EAACI,SAASJ,MAAV,EAAP;AACD;AACDV,YAAQa,KAAR;AACD;;AAED,WAASE,YAAT,GAAyB;AACvB,QAAIP,IAAIL,OAAR;AACA,QAAIK,KAAKA,EAAEC,IAAF,KAAW,SAApB,EAA+B;AAC7BL;AACA,UAAIY,OAAO,EAACF,SAASN,EAAEE,MAAZ,EAAX;AACA,UAAIJ,cAAc,GAAd,CAAJ,EAAwB;AACtBU,aAAKC,IAAL,GAAY,IAAZ;AACD;AACD,UAAIC,YAAYP,WAAhB;AACA,UAAIO,SAAJ,EAAe;AACbF,aAAKE,SAAL,GAAiBA,SAAjB;AACD;AACD,aAAOF,IAAP;AACD;AACF;;AAED,WAASG,4BAAT,GAAyC;AACvC,QAAIC,OAAOd,cAAc,GAAd,CAAX;AACA,QAAI,CAACc,IAAL,EAAW;AACT;AACD;;AAED,QAAIC,OAAOC,iBAAX;;AAEA,QAAI,CAAChB,cAAc,GAAd,CAAL,EAAyB;AACvB,YAAM,IAAID,KAAJ,CAAU,cAAV,CAAN;AACD;;AAED,WAAOgB,IAAP;AACD;;AAED,WAASE,SAAT,GAAsB;AACpB,WACEJ,kCACAP,iBADA,IAEAG,cAHF;AAKD;;AAED,WAASS,kBAAT,CAA6BjB,QAA7B,EAAuCkB,UAAvC,EAAmD;AACjD,WAAO,SAASC,aAAT,GAA0B;AAC/B,UAAIN,OAAOK,YAAX;AACA,UAAI,CAACL,IAAL,EAAW;AACT;AACD;;AAED,UAAI,CAACd,cAAcC,QAAd,CAAL,EAA8B;AAC5B,eAAOa,IAAP;AACD;;AAED,UAAIO,QAAQD,eAAZ;AACA,UAAI,CAACC,KAAL,EAAY;AACV,cAAM,IAAItB,KAAJ,CAAU,qBAAV,CAAN;AACD;AACD,aAAO;AACLe,cAAMA,IADD;AAELQ,qBAAarB,SAASsB,WAAT,EAFR;AAGLF,eAAOA;AAHF,OAAP;AAKD,KAnBD;AAoBD;;AAED,MAAIG,WAAWN,mBAAmB,KAAnB,EAA0BD,SAA1B,CAAf;AACA,MAAID,kBAAkBE,mBAAmB,IAAnB,EAAyBM,QAAzB,CAAtB;;AAEA,MAAId,OAAOM,iBAAX;AACA,MAAI,CAACN,IAAD,IAASf,SAAb,EAAwB;AACtB,UAAM,IAAII,KAAJ,CAAU,cAAV,CAAN;AACD;AACD,SAAOW,IAAP;AACD,CAlID","file":"parse.js","sourcesContent":["'use strict'\n\n// The ABNF grammar in the spec is totally ambiguous.\n//\n// This parser follows the operator precedence defined in the\n// `Order of Precedence and Parentheses` section.\n\nmodule.exports = function (tokens) {\n  var index = 0\n\n  function hasMore () {\n    return index < tokens.length\n  }\n\n  function token () {\n    return hasMore() ? tokens[index] : null\n  }\n\n  function next () {\n    if (!hasMore()) {\n      throw new Error()\n    }\n    index++\n  }\n\n  function parseOperator (operator) {\n    var t = token()\n    if (t && t.type === 'OPERATOR' && operator === t.string) {\n      next()\n      return t.string\n    }\n  }\n\n  function parseWith () {\n    if (parseOperator('WITH')) {\n      var t = token()\n      if (t && t.type === 'EXCEPTION') {\n        next()\n        return t.string\n      }\n      throw new Error('Expected exception after `WITH`')\n    }\n  }\n\n  function parseLicenseRef () {\n    // TODO: Actually, everything is concatenated into one string\n    // for backward-compatibility but it could be better to return\n    // a nice structure.\n    var begin = index\n    var string = ''\n    var t = token()\n    if (t.type === 'DOCUMENTREF') {\n      next()\n      string += 'DocumentRef-' + t.string + ':'\n      if (!parseOperator(':')) {\n        throw new Error('Expected `:` after `DocumentRef-...`')\n      }\n    }\n    t = token()\n    if (t.type === 'LICENSEREF') {\n      next()\n      string += 'LicenseRef-' + t.string\n      return {license: string}\n    }\n    index = begin\n  }\n\n  function parseLicense () {\n    var t = token()\n    if (t && t.type === 'LICENSE') {\n      next()\n      var node = {license: t.string}\n      if (parseOperator('+')) {\n        node.plus = true\n      }\n      var exception = parseWith()\n      if (exception) {\n        node.exception = exception\n      }\n      return node\n    }\n  }\n\n  function parseParenthesizedExpression () {\n    var left = parseOperator('(')\n    if (!left) {\n      return\n    }\n\n    var expr = parseExpression()\n\n    if (!parseOperator(')')) {\n      throw new Error('Expected `)`')\n    }\n\n    return expr\n  }\n\n  function parseAtom () {\n    return (\n      parseParenthesizedExpression() ||\n      parseLicenseRef() ||\n      parseLicense()\n    )\n  }\n\n  function makeBinaryOpParser (operator, nextParser) {\n    return function parseBinaryOp () {\n      var left = nextParser()\n      if (!left) {\n        return\n      }\n\n      if (!parseOperator(operator)) {\n        return left\n      }\n\n      var right = parseBinaryOp()\n      if (!right) {\n        throw new Error('Expected expression')\n      }\n      return {\n        left: left,\n        conjunction: operator.toLowerCase(),\n        right: right\n      }\n    }\n  }\n\n  var parseAnd = makeBinaryOpParser('AND', parseAtom)\n  var parseExpression = makeBinaryOpParser('OR', parseAnd)\n\n  var node = parseExpression()\n  if (!node || hasMore()) {\n    throw new Error('Syntax error')\n  }\n  return node\n}\n"]}