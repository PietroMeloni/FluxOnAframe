/**
 * refer:
 *   * @atimb "Real keep-alive HTTP agent": https://gist.github.com/2963672
 *   * https://github.com/joyent/node/blob/master/lib/http.js
 *   * https://github.com/joyent/node/blob/master/lib/https.js
 *   * https://github.com/joyent/node/blob/master/lib/_http_agent.js
 */

'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var OriginalAgent = require('./_http_agent').Agent;
var ms = require('humanize-ms');

var Agent = function (_OriginalAgent) {
  _inherits(Agent, _OriginalAgent);

  function Agent(options) {
    _classCallCheck(this, Agent);

    options = options || {};
    options.keepAlive = options.keepAlive !== false;
    // default is keep-alive and 15s free socket timeout
    if (options.freeSocketKeepAliveTimeout === undefined) {
      options.freeSocketKeepAliveTimeout = 15000;
    }
    // Legacy API: keepAliveTimeout should be rename to `freeSocketKeepAliveTimeout`
    if (options.keepAliveTimeout) {
      options.freeSocketKeepAliveTimeout = options.keepAliveTimeout;
    }
    options.freeSocketKeepAliveTimeout = ms(options.freeSocketKeepAliveTimeout);

    // Sets the socket to timeout after timeout milliseconds of inactivity on the socket.
    // By default is double free socket keepalive timeout.
    if (options.timeout === undefined) {
      options.timeout = options.freeSocketKeepAliveTimeout * 2;
      // make sure socket default inactivity timeout >= 30s
      if (options.timeout < 30000) {
        options.timeout = 30000;
      }
    }
    options.timeout = ms(options.timeout);

    var _this = _possibleConstructorReturn(this, (Agent.__proto__ || Object.getPrototypeOf(Agent)).call(this, options));

    _this.createSocketCount = 0;
    _this.createSocketCountLastCheck = 0;

    _this.createSocketErrorCount = 0;
    _this.createSocketErrorCountLastCheck = 0;

    _this.closeSocketCount = 0;
    _this.closeSocketCountLastCheck = 0;

    // socket error event count
    _this.errorSocketCount = 0;
    _this.errorSocketCountLastCheck = 0;

    _this.requestCount = 0;
    _this.requestCountLastCheck = 0;

    _this.timeoutSocketCount = 0;
    _this.timeoutSocketCountLastCheck = 0;

    _this.on('free', function (s) {
      _this.requestCount++;
      // last enter free queue timestamp
      s.lastFreeTime = Date.now();
    });
    _this.on('timeout', function () {
      _this.timeoutSocketCount++;
    });
    _this.on('close', function () {
      _this.closeSocketCount++;
    });
    _this.on('error', function () {
      _this.errorSocketCount++;
    });
    return _this;
  }

  _createClass(Agent, [{
    key: 'createSocket',
    value: function createSocket(req, options, cb) {
      var _this2 = this;

      _get(Agent.prototype.__proto__ || Object.getPrototypeOf(Agent.prototype), 'createSocket', this).call(this, req, options, function (err, socket) {
        if (err) {
          _this2.createSocketErrorCount++;
          return cb(err);
        }
        if (_this2.keepAlive) {
          // Disable Nagle's algorithm: http://blog.caustik.com/2012/04/08/scaling-node-js-to-100k-concurrent-connections/
          // https://fengmk2.com/benchmark/nagle-algorithm-delayed-ack-mock.html
          socket.setNoDelay(true);
        }
        _this2.createSocketCount++;
        cb(null, socket);
      });
    }
  }, {
    key: 'getCurrentStatus',
    value: function getCurrentStatus() {
      return {
        createSocketCount: this.createSocketCount,
        createSocketErrorCount: this.createSocketErrorCount,
        closeSocketCount: this.closeSocketCount,
        errorSocketCount: this.errorSocketCount,
        timeoutSocketCount: this.timeoutSocketCount,
        requestCount: this.requestCount,
        freeSockets: inspect(this.freeSockets),
        sockets: inspect(this.sockets),
        requests: inspect(this.requests)
      };
    }
  }, {
    key: 'statusChanged',
    get: function get() {
      var changed = this.createSocketCount !== this.createSocketCountLastCheck || this.createSocketErrorCount !== this.createSocketErrorCountLastCheck || this.closeSocketCount !== this.closeSocketCountLastCheck || this.errorSocketCount !== this.errorSocketCountLastCheck || this.timeoutSocketCount !== this.timeoutSocketCountLastCheck || this.requestCount !== this.requestCountLastCheck;
      if (changed) {
        this.createSocketCountLastCheck = this.createSocketCount;
        this.createSocketErrorCountLastCheck = this.createSocketErrorCount;
        this.closeSocketCountLastCheck = this.closeSocketCount;
        this.errorSocketCountLastCheck = this.errorSocketCount;
        this.timeoutSocketCountLastCheck = this.timeoutSocketCount;
        this.requestCountLastCheck = this.requestCount;
      }
      return changed;
    }
  }]);

  return Agent;
}(OriginalAgent);

module.exports = Agent;

function inspect(obj) {
  var res = {};
  for (var key in obj) {
    res[key] = obj[key].length;
  }
  return res;
}
//# sourceMappingURL=agent.js.map