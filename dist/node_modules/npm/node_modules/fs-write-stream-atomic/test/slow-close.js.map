{"version":3,"sources":["../../../../../../node_modules/npm/node_modules/fs-write-stream-atomic/test/slow-close.js"],"names":["fs","require","path","test","rimraf","writeStream","target","resolve","__dirname","t","plan","realEmit","WriteStream","prototype","emit","reallyClosed","event","apply","arguments","setTimeout","call","bind","stream","on","is","end","sync"],"mappings":"AAAA;;AACA,IAAIA,KAAKC,QAAQ,aAAR,CAAT;AACA,IAAIC,OAAOD,QAAQ,MAAR,CAAX;AACA,IAAIE,OAAOF,QAAQ,KAAR,EAAeE,IAA1B;AACA,IAAIC,SAASH,QAAQ,QAAR,CAAb;AACA,IAAII,cAAcJ,QAAQ,aAAR,CAAlB;;AAEA,IAAIK,SAASJ,KAAKK,OAAL,CAAaC,SAAb,EAAwB,YAAxB,CAAb;;AAEAL,KAAK,YAAL,EAAmB,UAAUM,CAAV,EAAa;AAC9BA,IAAEC,IAAF,CAAO,CAAP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAIC,WAAWX,GAAGY,WAAH,CAAeC,SAAf,CAAyBC,IAAxC;AACA,MAAIC,eAAe,KAAnB;AACAf,KAAGY,WAAH,CAAeC,SAAf,CAAyBC,IAAzB,GAAgC,UAAUE,KAAV,EAAiB;AAC/C,QAAIA,UAAU,OAAd,EAAuB,OAAOL,SAASM,KAAT,CAAe,IAAf,EAAqBC,SAArB,CAAP;AACvBC,eAAW,YAAY;AACrBJ,qBAAe,IAAf;AACAJ,eAASS,IAAT,CAAc,IAAd,EAAoB,OAApB;AACD,KAHU,CAGTC,IAHS,CAGJ,IAHI,CAAX,EAGc,GAHd;AAID,GAND;AAOA,MAAIC,SAASjB,YAAYC,MAAZ,CAAb;AACAgB,SAAOC,EAAP,CAAU,QAAV,EAAoB,YAAY;AAC9Bd,MAAEe,EAAF,CAAKT,YAAL,EAAmB,IAAnB,EAAyB,wCAAzB;AACD,GAFD;AAGAO,SAAOC,EAAP,CAAU,OAAV,EAAmB,YAAY;AAC7Bd,MAAEe,EAAF,CAAKT,YAAL,EAAmB,IAAnB,EAAyB,uCAAzB;AACD,GAFD;AAGAO,SAAOG,GAAP;AACD,CAzBD;;AA2BAtB,KAAK,SAAL,EAAgB,UAAUM,CAAV,EAAa;AAC3BL,SAAOsB,IAAP,CAAYpB,MAAZ;AACAG,IAAEgB,GAAF;AACD,CAHD","file":"slow-close.js","sourcesContent":["'use strict'\nvar fs = require('graceful-fs')\nvar path = require('path')\nvar test = require('tap').test\nvar rimraf = require('rimraf')\nvar writeStream = require('../index.js')\n\nvar target = path.resolve(__dirname, 'test-chown')\n\ntest('slow close', function (t) {\n  t.plan(2)\n  // The goal here is to simulate the \"file close\" step happening so slowly\n  // that the whole close/rename process could finish before the file is\n  // actually closed (and thus buffers truely flushed to the OS). In\n  // previous versions of this module, this would result in the module\n  // emitting finish & close before the file was fully written and in\n  // turn, could break other layers that tried to read the new file.\n  var realEmit = fs.WriteStream.prototype.emit\n  var reallyClosed = false\n  fs.WriteStream.prototype.emit = function (event) {\n    if (event !== 'close') return realEmit.apply(this, arguments)\n    setTimeout(function () {\n      reallyClosed = true\n      realEmit.call(this, 'close')\n    }.bind(this), 200)\n  }\n  var stream = writeStream(target)\n  stream.on('finish', function () {\n    t.is(reallyClosed, true, \"didn't finish before target was closed\")\n  })\n  stream.on('close', function () {\n    t.is(reallyClosed, true, \"didn't close before target was closed\")\n  })\n  stream.end()\n})\n\ntest('cleanup', function (t) {\n  rimraf.sync(target)\n  t.end()\n})\n"]}