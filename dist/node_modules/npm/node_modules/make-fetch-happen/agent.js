'use strict';

var LRU = require('lru-cache');
var url = require('url');

var AGENT_CACHE = new LRU({ max: 50 });
var HttpsAgent = void 0;
var HttpAgent = void 0;

module.exports = getAgent;

function getAgent(uri, opts) {
  var parsedUri = url.parse(typeof uri === 'string' ? uri : uri.url);
  var isHttps = parsedUri.protocol === 'https:';
  var pxuri = getProxyUri(uri, opts);

  var key = ['https:' + isHttps, pxuri ? 'proxy:' + pxuri.protocol + '//' + pxuri.host + ':' + pxuri.port : '>no-proxy<', 'local-address:' + (opts.localAddress || '>no-local-address<'), 'strict-ssl:' + (isHttps ? !!opts.strictSSL : '>no-strict-ssl<'), 'ca:' + (isHttps && opts.ca || '>no-ca<'), 'cert:' + (isHttps && opts.cert || '>no-cert<'), 'key:' + (isHttps && opts.key || '>no-key<')].join(':');

  if (opts.agent != null) {
    // `agent: false` has special behavior!
    return opts.agent;
  }

  if (AGENT_CACHE.peek(key)) {
    return AGENT_CACHE.get(key);
  }

  if (pxuri) {
    var proxy = getProxy(pxuri, opts, isHttps);
    AGENT_CACHE.set(key, proxy);
    return proxy;
  }

  if (isHttps && !HttpsAgent) {
    HttpsAgent = require('agentkeepalive').HttpsAgent;
  } else if (!isHttps && !HttpAgent) {
    HttpAgent = require('agentkeepalive');
  }

  // If opts.timeout is zero, set the agentTimeout to zero as well. A timeout
  // of zero disables the timeout behavior (OS limits still apply). Else, if
  // opts.timeout is a non-zero value, set it to timeout + 1, to ensure that
  // the node-fetch-npm timeout will always fire first, giving us more
  // consistent errors.
  var agentTimeout = opts.timeout === 0 ? 0 : opts.timeout + 1;

  var agent = isHttps ? new HttpsAgent({
    maxSockets: opts.maxSockets || 15,
    ca: opts.ca,
    cert: opts.cert,
    key: opts.key,
    localAddress: opts.localAddress,
    rejectUnauthorized: opts.strictSSL,
    timeout: agentTimeout
  }) : new HttpAgent({
    maxSockets: opts.maxSockets || 15,
    localAddress: opts.localAddress,
    timeout: agentTimeout
  });
  AGENT_CACHE.set(key, agent);
  return agent;
}

function checkNoProxy(uri, opts) {
  var host = url.parse(uri).hostname.split('.').reverse();
  var noproxy = opts.noProxy || getProcessEnv('no_proxy');
  if (typeof noproxy === 'string') {
    noproxy = noproxy.split(/\s*,\s*/g);
  }
  return noproxy && noproxy.some(function (no) {
    var noParts = no.split('.').filter(function (x) {
      return x;
    }).reverse();
    if (!noParts.length) {
      return false;
    }
    for (var i = 0; i < noParts.length; i++) {
      if (host[i] !== noParts[i]) {
        return false;
      }
    }
    return true;
  });
}

module.exports.getProcessEnv = getProcessEnv;

function getProcessEnv(env) {
  if (!env) {
    return;
  }

  var value = void 0;

  if (Array.isArray(env)) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = env[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var e = _step.value;

        value = process.env[e] || process.env[e.toUpperCase()] || process.env[e.toLowerCase()];
        if (typeof value !== 'undefined') {
          break;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  if (typeof env === 'string') {
    value = process.env[env] || process.env[env.toUpperCase()] || process.env[env.toLowerCase()];
  }

  return value;
}

function getProxyUri(uri, opts) {
  var protocol = url.parse(uri).protocol;

  var proxy = opts.proxy || protocol === 'https:' && getProcessEnv('https_proxy') || protocol === 'http:' && getProcessEnv(['https_proxy', 'http_proxy', 'proxy']);
  if (!proxy) {
    return null;
  }

  var parsedProxy = typeof proxy === 'string' ? url.parse(proxy) : proxy;

  return !checkNoProxy(uri, opts) && parsedProxy;
}

var HttpProxyAgent = void 0;
var HttpsProxyAgent = void 0;
var SocksProxyAgent = void 0;
function getProxy(proxyUrl, opts, isHttps) {
  var popts = {
    host: proxyUrl.hostname,
    port: proxyUrl.port,
    protocol: proxyUrl.protocol,
    path: proxyUrl.path,
    auth: proxyUrl.auth,
    ca: opts.ca,
    cert: opts.cert,
    key: opts.key,
    timeout: opts.timeout === 0 ? 0 : opts.timeout + 1,
    localAddress: opts.localAddress,
    maxSockets: opts.maxSockets || 15,
    rejectUnauthorized: opts.strictSSL
  };

  if (proxyUrl.protocol === 'http:' || proxyUrl.protocol === 'https:') {
    if (!isHttps) {
      if (!HttpProxyAgent) {
        HttpProxyAgent = require('http-proxy-agent');
      }

      return new HttpProxyAgent(popts);
    } else {
      if (!HttpsProxyAgent) {
        HttpsProxyAgent = require('https-proxy-agent');
      }

      return new HttpsProxyAgent(popts);
    }
  }
  if (proxyUrl.protocol.startsWith('socks')) {
    if (!SocksProxyAgent) {
      SocksProxyAgent = require('socks-proxy-agent');
    }

    return new SocksProxyAgent(popts);
  }
}
//# sourceMappingURL=agent.js.map