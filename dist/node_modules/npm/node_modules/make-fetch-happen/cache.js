'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var cacache = require('cacache');
var fetch = require('node-fetch-npm');
var pipe = require('mississippi').pipe;
var ssri = require('ssri');
var through = require('mississippi').through;
var to = require('mississippi').to;
var url = require('url');
var stream = require('stream');

var MAX_MEM_SIZE = 5 * 1024 * 1024; // 5MB

function cacheKey(req) {
  var parsed = url.parse(req.url);
  return 'make-fetch-happen:request-cache:' + url.format({
    protocol: parsed.protocol,
    slashes: parsed.slashes,
    host: parsed.host,
    hostname: parsed.hostname,
    pathname: parsed.pathname
  });
}

// This is a cacache-based implementation of the Cache standard,
// using node-fetch.
// docs: https://developer.mozilla.org/en-US/docs/Web/API/Cache
//
module.exports = function () {
  function Cache(path, opts) {
    _classCallCheck(this, Cache);

    this._path = path;
    this._uid = opts && opts.uid;
    this._gid = opts && opts.gid;
    this.Promise = opts && opts.Promise || Promise;
  }

  // Returns a Promise that resolves to the response associated with the first
  // matching request in the Cache object.


  _createClass(Cache, [{
    key: 'match',
    value: function match(req, opts) {
      var _this = this;

      opts = opts || {};
      var key = cacheKey(req);
      return cacache.get.info(this._path, key).then(function (info) {
        return info && cacache.get.hasContent(_this._path, info.integrity, opts).then(function (exists) {
          return exists && info;
        });
      }).then(function (info) {
        if (info && info.metadata && matchDetails(req, {
          url: info.metadata.url,
          reqHeaders: new fetch.Headers(info.metadata.reqHeaders),
          resHeaders: new fetch.Headers(info.metadata.resHeaders),
          cacheIntegrity: info.integrity,
          integrity: opts && opts.integrity
        })) {
          var resHeaders = new fetch.Headers(info.metadata.resHeaders);
          addCacheHeaders(resHeaders, _this._path, key, info.integrity, info.time);
          if (req.method === 'HEAD') {
            return new fetch.Response(null, {
              url: req.url,
              headers: resHeaders,
              status: 200
            });
          }
          var body = void 0;
          var cachePath = _this._path;
          // avoid opening cache file handles until a user actually tries to
          // read from it.
          if (opts.memoize !== false && info.size > MAX_MEM_SIZE) {
            body = new stream.PassThrough();
            var realRead = body._read;
            body._read = function (size) {
              body._read = realRead;
              pipe(cacache.get.stream.byDigest(cachePath, info.integrity, {
                memoize: opts.memoize
              }), body, function (err) {
                return body.emit(err);
              });
              return realRead.call(this, size);
            };
          } else {
            var readOnce = false;
            // cacache is much faster at bulk reads
            body = new stream.Readable({
              read: function read() {
                var _this2 = this;

                if (readOnce) return this.push(null);
                readOnce = true;
                cacache.get.byDigest(cachePath, info.integrity, {
                  memoize: opts.memoize
                }).then(function (data) {
                  _this2.push(data);
                  _this2.push(null);
                }, function (err) {
                  return _this2.emit('error', err);
                });
              }
            });
          }
          return _this.Promise.resolve(new fetch.Response(body, {
            url: req.url,
            headers: resHeaders,
            status: 200,
            size: info.size
          }));
        }
      });
    }

    // Takes both a request and its response and adds it to the given cache.

  }, {
    key: 'put',
    value: function put(req, response, opts) {
      var _this3 = this;

      opts = opts || {};
      var size = response.headers.get('content-length');
      var fitInMemory = !!size && opts.memoize !== false && size < MAX_MEM_SIZE;
      var ckey = cacheKey(req);
      var cacheOpts = {
        algorithms: opts.algorithms,
        metadata: {
          url: req.url,
          reqHeaders: req.headers.raw(),
          resHeaders: response.headers.raw()
        },
        uid: this._uid,
        gid: this._gid,
        size: size,
        memoize: fitInMemory && opts.memoize
      };
      if (req.method === 'HEAD' || response.status === 304) {
        // Update metadata without writing
        return cacache.get.info(this._path, ckey).then(function (info) {
          // Providing these will bypass content write
          cacheOpts.integrity = info.integrity;
          addCacheHeaders(response.headers, _this3._path, ckey, info.integrity, info.time);
          return new _this3.Promise(function (resolve, reject) {
            pipe(cacache.get.stream.byDigest(_this3._path, info.integrity, cacheOpts), cacache.put.stream(_this3._path, cacheKey(req), cacheOpts), function (err) {
              return err ? reject(err) : resolve(response);
            });
          });
        }).then(function () {
          return response;
        });
      }
      var buf = [];
      var bufSize = 0;
      var cacheTargetStream = false;
      var cachePath = this._path;
      var cacheStream = to(function (chunk, enc, cb) {
        if (!cacheTargetStream) {
          if (fitInMemory) {
            cacheTargetStream = to({ highWaterMark: MAX_MEM_SIZE }, function (chunk, enc, cb) {
              buf.push(chunk);
              bufSize += chunk.length;
              cb();
            }, function (done) {
              cacache.put(cachePath, cacheKey(req), Buffer.concat(buf, bufSize), cacheOpts).then(function () {
                return done();
              }, done);
            });
          } else {
            cacheTargetStream = cacache.put.stream(cachePath, cacheKey(req), cacheOpts);
          }
        }
        cacheTargetStream.write(chunk, enc, cb);
      }, function (done) {
        cacheTargetStream ? cacheTargetStream.end(done) : done();
      });
      var oldBody = response.body;
      var newBody = through({ highWaterMark: fitInMemory && MAX_MEM_SIZE });
      response.body = newBody;
      oldBody.once('error', function (err) {
        return newBody.emit('error', err);
      });
      newBody.once('error', function (err) {
        return oldBody.emit('error', err);
      });
      cacheStream.once('error', function (err) {
        return newBody.emit('error', err);
      });
      pipe(oldBody, to(function (chunk, enc, cb) {
        cacheStream.write(chunk, enc, function () {
          newBody.write(chunk, enc, cb);
        });
      }, function (done) {
        cacheStream.end(function () {
          newBody.end(function () {
            done();
          });
        });
      }), function (err) {
        return err && newBody.emit('error', err);
      });
      return response;
    }

    // Finds the Cache entry whose key is the request, and if found, deletes the
    // Cache entry and returns a Promise that resolves to true. If no Cache entry
    // is found, it returns false.

  }, {
    key: 'delete',
    value: function _delete(req, opts) {
      opts = opts || {};
      if (_typeof(opts.memoize) === 'object') {
        if (opts.memoize.reset) {
          opts.memoize.reset();
        } else if (opts.memoize.clear) {
          opts.memoize.clear();
        } else {
          Object.keys(opts.memoize).forEach(function (k) {
            opts.memoize[k] = null;
          });
        }
      }
      return cacache.rm.entry(this._path, cacheKey(req)
      // TODO - true/false
      ).then(function () {
        return false;
      });
    }
  }]);

  return Cache;
}();

function matchDetails(req, cached) {
  var reqUrl = url.parse(req.url);
  var cacheUrl = url.parse(cached.url);
  var vary = cached.resHeaders.get('Vary');
  // https://tools.ietf.org/html/rfc7234#section-4.1
  if (vary) {
    if (vary.match(/\*/)) {
      return false;
    } else {
      var fieldsMatch = vary.split(/\s*,\s*/).every(function (field) {
        return cached.reqHeaders.get(field) === req.headers.get(field);
      });
      if (!fieldsMatch) {
        return false;
      }
    }
  }
  if (cached.integrity) {
    return ssri.parse(cached.integrity).match(cached.cacheIntegrity);
  }
  reqUrl.hash = null;
  cacheUrl.hash = null;
  return url.format(reqUrl) === url.format(cacheUrl);
}

function addCacheHeaders(resHeaders, path, key, hash, time) {
  resHeaders.set('X-Local-Cache', encodeURIComponent(path));
  resHeaders.set('X-Local-Cache-Key', encodeURIComponent(key));
  resHeaders.set('X-Local-Cache-Hash', encodeURIComponent(hash));
  resHeaders.set('X-Local-Cache-Time', new Date(time).toUTCString());
}
//# sourceMappingURL=cache.js.map