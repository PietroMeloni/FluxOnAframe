{"version":3,"sources":["../../../../../node_modules/npm/node_modules/safer-buffer/safer.js"],"names":["buffer","require","Buffer","safer","key","hasOwnProperty","Safer","prototype","from","Uint8Array","value","encodingOrOffset","length","TypeError","alloc","size","fill","encoding","RangeError","buf","kStringMaxLength","process","binding","e","constants","MAX_LENGTH","kMaxLength","MAX_STRING_LENGTH","module","exports"],"mappings":"AAAA;;AAEA;;;;AAEA,IAAIA,SAASC,QAAQ,QAAR,CAAb;AACA,IAAIC,SAASF,OAAOE,MAApB;;AAEA,IAAIC,QAAQ,EAAZ;;AAEA,IAAIC,GAAJ;;AAEA,KAAKA,GAAL,IAAYJ,MAAZ,EAAoB;AAClB,MAAI,CAACA,OAAOK,cAAP,CAAsBD,GAAtB,CAAL,EAAiC;AACjC,MAAIA,QAAQ,YAAR,IAAwBA,QAAQ,QAApC,EAA8C;AAC9CD,QAAMC,GAAN,IAAaJ,OAAOI,GAAP,CAAb;AACD;;AAED,IAAIE,QAAQH,MAAMD,MAAN,GAAe,EAA3B;AACA,KAAKE,GAAL,IAAYF,MAAZ,EAAoB;AAClB,MAAI,CAACA,OAAOG,cAAP,CAAsBD,GAAtB,CAAL,EAAiC;AACjC,MAAIA,QAAQ,aAAR,IAAyBA,QAAQ,iBAArC,EAAwD;AACxDE,QAAMF,GAAN,IAAaF,OAAOE,GAAP,CAAb;AACD;;AAEDD,MAAMD,MAAN,CAAaK,SAAb,GAAyBL,OAAOK,SAAhC;;AAEA,IAAI,CAACD,MAAME,IAAP,IAAeF,MAAME,IAAN,KAAeC,WAAWD,IAA7C,EAAmD;AACjDF,QAAME,IAAN,GAAa,UAAUE,KAAV,EAAiBC,gBAAjB,EAAmCC,MAAnC,EAA2C;AACtD,QAAI,OAAOF,KAAP,KAAiB,QAArB,EAA+B;AAC7B,YAAM,IAAIG,SAAJ,CAAc,4EAA2EH,KAA3E,yCAA2EA,KAA3E,EAAd,CAAN;AACD;AACD,QAAIA,SAAS,OAAOA,MAAME,MAAb,KAAwB,WAArC,EAAkD;AAChD,YAAM,IAAIC,SAAJ,CAAc,4HAA2HH,KAA3H,yCAA2HA,KAA3H,EAAd,CAAN;AACD;AACD,WAAOR,OAAOQ,KAAP,EAAcC,gBAAd,EAAgCC,MAAhC,CAAP;AACD,GARD;AASD;;AAED,IAAI,CAACN,MAAMQ,KAAX,EAAkB;AAChBR,QAAMQ,KAAN,GAAc,UAAUC,IAAV,EAAgBC,IAAhB,EAAsBC,QAAtB,EAAgC;AAC5C,QAAI,OAAOF,IAAP,KAAgB,QAApB,EAA8B;AAC5B,YAAM,IAAIF,SAAJ,CAAc,uEAAsEE,IAAtE,yCAAsEA,IAAtE,EAAd,CAAN;AACD;AACD,QAAIA,OAAO,CAAP,IAAYA,QAAQ,KAAK,KAAK,EAAV,CAAxB,EAAuC;AACrC,YAAM,IAAIG,UAAJ,CAAe,gBAAgBH,IAAhB,GAAuB,gCAAtC,CAAN;AACD;AACD,QAAII,MAAMjB,OAAOa,IAAP,CAAV;AACA,QAAI,CAACC,IAAD,IAASA,KAAKJ,MAAL,KAAgB,CAA7B,EAAgC;AAC9BO,UAAIH,IAAJ,CAAS,CAAT;AACD,KAFD,MAEO,IAAI,OAAOC,QAAP,KAAoB,QAAxB,EAAkC;AACvCE,UAAIH,IAAJ,CAASA,IAAT,EAAeC,QAAf;AACD,KAFM,MAEA;AACLE,UAAIH,IAAJ,CAASA,IAAT;AACD;AACD,WAAOG,GAAP;AACD,GAhBD;AAiBD;;AAED,IAAI,CAAChB,MAAMiB,gBAAX,EAA6B;AAC3B,MAAI;AACFjB,UAAMiB,gBAAN,GAAyBC,QAAQC,OAAR,CAAgB,QAAhB,EAA0BF,gBAAnD;AACD,GAFD,CAEE,OAAOG,CAAP,EAAU;AACV;AACA;AACD;AACF;;AAED,IAAI,CAACpB,MAAMqB,SAAX,EAAsB;AACpBrB,QAAMqB,SAAN,GAAkB;AAChBC,gBAAYtB,MAAMuB;AADF,GAAlB;AAGA,MAAIvB,MAAMiB,gBAAV,EAA4B;AAC1BjB,UAAMqB,SAAN,CAAgBG,iBAAhB,GAAoCxB,MAAMiB,gBAA1C;AACD;AACF;;AAEDQ,OAAOC,OAAP,GAAiB1B,KAAjB","file":"safer.js","sourcesContent":["/* eslint-disable node/no-deprecated-api */\n\n'use strict'\n\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\nvar safer = {}\n\nvar key\n\nfor (key in buffer) {\n  if (!buffer.hasOwnProperty(key)) continue\n  if (key === 'SlowBuffer' || key === 'Buffer') continue\n  safer[key] = buffer[key]\n}\n\nvar Safer = safer.Buffer = {}\nfor (key in Buffer) {\n  if (!Buffer.hasOwnProperty(key)) continue\n  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue\n  Safer[key] = Buffer[key]\n}\n\nsafer.Buffer.prototype = Buffer.prototype\n\nif (!Safer.from || Safer.from === Uint8Array.from) {\n  Safer.from = function (value, encodingOrOffset, length) {\n    if (typeof value === 'number') {\n      throw new TypeError('The \"value\" argument must not be of type number. Received type ' + typeof value)\n    }\n    if (value && typeof value.length === 'undefined') {\n      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)\n    }\n    return Buffer(value, encodingOrOffset, length)\n  }\n}\n\nif (!Safer.alloc) {\n  Safer.alloc = function (size, fill, encoding) {\n    if (typeof size !== 'number') {\n      throw new TypeError('The \"size\" argument must be of type number. Received type ' + typeof size)\n    }\n    if (size < 0 || size >= 2 * (1 << 30)) {\n      throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n    }\n    var buf = Buffer(size)\n    if (!fill || fill.length === 0) {\n      buf.fill(0)\n    } else if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n    return buf\n  }\n}\n\nif (!safer.kStringMaxLength) {\n  try {\n    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength\n  } catch (e) {\n    // we can't determine kStringMaxLength in environments where process.binding\n    // is unsupported, so let's not set it\n  }\n}\n\nif (!safer.constants) {\n  safer.constants = {\n    MAX_LENGTH: safer.kMaxLength\n  }\n  if (safer.kStringMaxLength) {\n    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength\n  }\n}\n\nmodule.exports = safer\n"]}