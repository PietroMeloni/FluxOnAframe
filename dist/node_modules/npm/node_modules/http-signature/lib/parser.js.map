{"version":3,"sources":["../../../../../../node_modules/npm/node_modules/http-signature/lib/parser.js"],"names":["assert","require","util","utils","HASH_ALGOS","PK_ALGOS","HttpSignatureError","InvalidAlgorithmError","validateAlgorithm","State","New","Params","ParamsState","Name","Quote","Value","Comma","ExpiredRequestError","message","call","inherits","InvalidHeaderError","InvalidParamsError","MissingHeaderError","StrictParsingError","module","exports","parseRequest","request","options","object","headers","undefined","arrayOfString","optionalNumber","clockSkew","authorization","i","state","substate","tmpName","tmpValue","parsed","scheme","params","signingString","algorithm","toUpperCase","keyId","authz","length","c","charAt","Number","code","charCodeAt","Error","split","signature","toLowerCase","e","h","strict","method","url","httpVersion","value","date","Date","now","skew","Math","abs","getTime","forEach","hdr","indexOf","algorithms"],"mappings":"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","file":"parser.js","sourcesContent":["// Copyright 2012 Joyent, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\nvar utils = require('./utils');\n\n\n\n///--- Globals\n\nvar HASH_ALGOS = utils.HASH_ALGOS;\nvar PK_ALGOS = utils.PK_ALGOS;\nvar HttpSignatureError = utils.HttpSignatureError;\nvar InvalidAlgorithmError = utils.InvalidAlgorithmError;\nvar validateAlgorithm = utils.validateAlgorithm;\n\nvar State = {\n  New: 0,\n  Params: 1\n};\n\nvar ParamsState = {\n  Name: 0,\n  Quote: 1,\n  Value: 2,\n  Comma: 3\n};\n\n\n///--- Specific Errors\n\n\nfunction ExpiredRequestError(message) {\n  HttpSignatureError.call(this, message, ExpiredRequestError);\n}\nutil.inherits(ExpiredRequestError, HttpSignatureError);\n\n\nfunction InvalidHeaderError(message) {\n  HttpSignatureError.call(this, message, InvalidHeaderError);\n}\nutil.inherits(InvalidHeaderError, HttpSignatureError);\n\n\nfunction InvalidParamsError(message) {\n  HttpSignatureError.call(this, message, InvalidParamsError);\n}\nutil.inherits(InvalidParamsError, HttpSignatureError);\n\n\nfunction MissingHeaderError(message) {\n  HttpSignatureError.call(this, message, MissingHeaderError);\n}\nutil.inherits(MissingHeaderError, HttpSignatureError);\n\nfunction StrictParsingError(message) {\n  HttpSignatureError.call(this, message, StrictParsingError);\n}\nutil.inherits(StrictParsingError, HttpSignatureError);\n\n///--- Exported API\n\nmodule.exports = {\n\n  /**\n   * Parses the 'Authorization' header out of an http.ServerRequest object.\n   *\n   * Note that this API will fully validate the Authorization header, and throw\n   * on any error.  It will not however check the signature, or the keyId format\n   * as those are specific to your environment.  You can use the options object\n   * to pass in extra constraints.\n   *\n   * As a response object you can expect this:\n   *\n   *     {\n   *       \"scheme\": \"Signature\",\n   *       \"params\": {\n   *         \"keyId\": \"foo\",\n   *         \"algorithm\": \"rsa-sha256\",\n   *         \"headers\": [\n   *           \"date\" or \"x-date\",\n   *           \"digest\"\n   *         ],\n   *         \"signature\": \"base64\"\n   *       },\n   *       \"signingString\": \"ready to be passed to crypto.verify()\"\n   *     }\n   *\n   * @param {Object} request an http.ServerRequest.\n   * @param {Object} options an optional options object with:\n   *                   - clockSkew: allowed clock skew in seconds (default 300).\n   *                   - headers: required header names (def: date or x-date)\n   *                   - algorithms: algorithms to support (default: all).\n   *                   - strict: should enforce latest spec parsing\n   *                             (default: false).\n   * @return {Object} parsed out object (see above).\n   * @throws {TypeError} on invalid input.\n   * @throws {InvalidHeaderError} on an invalid Authorization header error.\n   * @throws {InvalidParamsError} if the params in the scheme are invalid.\n   * @throws {MissingHeaderError} if the params indicate a header not present,\n   *                              either in the request headers from the params,\n   *                              or not in the params from a required header\n   *                              in options.\n   * @throws {StrictParsingError} if old attributes are used in strict parsing\n   *                              mode.\n   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.\n   */\n  parseRequest: function parseRequest(request, options) {\n    assert.object(request, 'request');\n    assert.object(request.headers, 'request.headers');\n    if (options === undefined) {\n      options = {};\n    }\n    if (options.headers === undefined) {\n      options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];\n    }\n    assert.object(options, 'options');\n    assert.arrayOfString(options.headers, 'options.headers');\n    assert.optionalNumber(options.clockSkew, 'options.clockSkew');\n\n    if (!request.headers.authorization)\n      throw new MissingHeaderError('no authorization header present in ' +\n                                   'the request');\n\n    options.clockSkew = options.clockSkew || 300;\n\n\n    var i = 0;\n    var state = State.New;\n    var substate = ParamsState.Name;\n    var tmpName = '';\n    var tmpValue = '';\n\n    var parsed = {\n      scheme: '',\n      params: {},\n      signingString: '',\n\n      get algorithm() {\n        return this.params.algorithm.toUpperCase();\n      },\n\n      get keyId() {\n        return this.params.keyId;\n      }\n    };\n\n    var authz = request.headers.authorization;\n    for (i = 0; i < authz.length; i++) {\n      var c = authz.charAt(i);\n\n      switch (Number(state)) {\n\n      case State.New:\n        if (c !== ' ') parsed.scheme += c;\n        else state = State.Params;\n        break;\n\n      case State.Params:\n        switch (Number(substate)) {\n\n        case ParamsState.Name:\n          var code = c.charCodeAt(0);\n          // restricted name of A-Z / a-z\n          if ((code >= 0x41 && code <= 0x5a) || // A-Z\n              (code >= 0x61 && code <= 0x7a)) { // a-z\n            tmpName += c;\n          } else if (c === '=') {\n            if (tmpName.length === 0)\n              throw new InvalidHeaderError('bad param format');\n            substate = ParamsState.Quote;\n          } else {\n            throw new InvalidHeaderError('bad param format');\n          }\n          break;\n\n        case ParamsState.Quote:\n          if (c === '\"') {\n            tmpValue = '';\n            substate = ParamsState.Value;\n          } else {\n            throw new InvalidHeaderError('bad param format');\n          }\n          break;\n\n        case ParamsState.Value:\n          if (c === '\"') {\n            parsed.params[tmpName] = tmpValue;\n            substate = ParamsState.Comma;\n          } else {\n            tmpValue += c;\n          }\n          break;\n\n        case ParamsState.Comma:\n          if (c === ',') {\n            tmpName = '';\n            substate = ParamsState.Name;\n          } else {\n            throw new InvalidHeaderError('bad param format');\n          }\n          break;\n\n        default:\n          throw new Error('Invalid substate');\n        }\n        break;\n\n      default:\n        throw new Error('Invalid substate');\n      }\n\n    }\n\n    if (!parsed.params.headers || parsed.params.headers === '') {\n      if (request.headers['x-date']) {\n        parsed.params.headers = ['x-date'];\n      } else {\n        parsed.params.headers = ['date'];\n      }\n    } else {\n      parsed.params.headers = parsed.params.headers.split(' ');\n    }\n\n    // Minimally validate the parsed object\n    if (!parsed.scheme || parsed.scheme !== 'Signature')\n      throw new InvalidHeaderError('scheme was not \"Signature\"');\n\n    if (!parsed.params.keyId)\n      throw new InvalidHeaderError('keyId was not specified');\n\n    if (!parsed.params.algorithm)\n      throw new InvalidHeaderError('algorithm was not specified');\n\n    if (!parsed.params.signature)\n      throw new InvalidHeaderError('signature was not specified');\n\n    // Check the algorithm against the official list\n    parsed.params.algorithm = parsed.params.algorithm.toLowerCase();\n    try {\n      validateAlgorithm(parsed.params.algorithm);\n    } catch (e) {\n      if (e instanceof InvalidAlgorithmError)\n        throw (new InvalidParamsError(parsed.params.algorithm + ' is not ' +\n          'supported'));\n      else\n        throw (e);\n    }\n\n    // Build the signingString\n    for (i = 0; i < parsed.params.headers.length; i++) {\n      var h = parsed.params.headers[i].toLowerCase();\n      parsed.params.headers[i] = h;\n\n      if (h === 'request-line') {\n        if (!options.strict) {\n          /*\n           * We allow headers from the older spec drafts if strict parsing isn't\n           * specified in options.\n           */\n          parsed.signingString +=\n            request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;\n        } else {\n          /* Strict parsing doesn't allow older draft headers. */\n          throw (new StrictParsingError('request-line is not a valid header ' +\n            'with strict parsing enabled.'));\n        }\n      } else if (h === '(request-target)') {\n        parsed.signingString +=\n          '(request-target): ' + request.method.toLowerCase() + ' ' +\n          request.url;\n      } else {\n        var value = request.headers[h];\n        if (value === undefined)\n          throw new MissingHeaderError(h + ' was not in the request');\n        parsed.signingString += h + ': ' + value;\n      }\n\n      if ((i + 1) < parsed.params.headers.length)\n        parsed.signingString += '\\n';\n    }\n\n    // Check against the constraints\n    var date;\n    if (request.headers.date || request.headers['x-date']) {\n        if (request.headers['x-date']) {\n          date = new Date(request.headers['x-date']);\n        } else {\n          date = new Date(request.headers.date);\n        }\n      var now = new Date();\n      var skew = Math.abs(now.getTime() - date.getTime());\n\n      if (skew > options.clockSkew * 1000) {\n        throw new ExpiredRequestError('clock skew of ' +\n                                      (skew / 1000) +\n                                      's was greater than ' +\n                                      options.clockSkew + 's');\n      }\n    }\n\n    options.headers.forEach(function (hdr) {\n      // Remember that we already checked any headers in the params\n      // were in the request, so if this passes we're good.\n      if (parsed.params.headers.indexOf(hdr) < 0)\n        throw new MissingHeaderError(hdr + ' was not a signed header');\n    });\n\n    if (options.algorithms) {\n      if (options.algorithms.indexOf(parsed.params.algorithm) === -1)\n        throw new InvalidParamsError(parsed.params.algorithm +\n                                     ' is not a supported algorithm');\n    }\n\n    return parsed;\n  }\n\n};\n"]}