{"version":3,"sources":["../../../../../node_modules/npm/node_modules/lockfile/speedtest.js"],"names":["path","require","async","lf","fs","n","process","argv","a","Array","apply","length","map","_","i","file","resolve","__dirname","unlinkSync","e","parallel","fn","msg","each","eachSeries","start","Date","now","console","log","val","cb","lock","retries","err","unlock","complete","exit"],"mappings":";;AAAA,IAAMA,OAAOC,QAAQ,MAAR,CAAb;AACA,IAAMC,QAAQD,QAAQ,OAAR,CAAd;AACA,IAAME,KAAKF,QAAQ,UAAR,CAAX;AACA,IAAMG,KAAKH,QAAQ,IAAR,CAAX;;AAEA,IAAMI,IAAI,CAACC,QAAQC,IAAR,CAAa,CAAb,CAAD,IAAoB,GAA9B;AACA,IAAMC,IAAIC,MAAMC,KAAN,CAAY,IAAZ,EAAkB,EAACC,QAAQN,CAAT,EAAlB,EAA+BO,GAA/B,CAAmC,UAASC,CAAT,EAAYC,CAAZ,EAAe;AAC1D,WAAOA,CAAP;AACD,CAFS,CAAV;AAGA,IAAMC,OAAOf,KAAKgB,OAAL,CAAaC,SAAb,EAAwB,iBAAxB,CAAb;;AAEA,IAAG;AACCb,OAAGc,UAAH,CAAcH,IAAd;AACH,CAFD,CAGA,OAAMI,CAAN,EAAQ,CAAE;;AAGV;AACA;AACA;;;AAGA,IAAMC,WAAWd,QAAQC,IAAR,CAAa,CAAb,MAAoB,UAArC;;AAEA,IAAIc,EAAJ,EAAQC,GAAR;;AAEA,IAAGF,QAAH,EAAY;AACRE,UAAM,UAAN;AACAD,SAAKnB,MAAMqB,IAAX;AACH,CAHD,MAII;AACAD,UAAM,QAAN;AACAD,SAAKnB,MAAMsB,UAAX;AACH;;AAGD,IAAMC,QAAQC,KAAKC,GAAL,EAAd;AACAC,QAAQC,GAAR,CAAY,2BAA2BrB,EAAEG,MAA7B,GAAsC,aAAtC,GAAsDW,GAAlE;;AAEAD,GAAGb,CAAH,EAAM,UAAUsB,GAAV,EAAeC,EAAf,EAAmB;;AAErBH,YAAQC,GAAR,CAAY,QAAZ,EAAsBC,GAAtB;;AAEA3B,OAAG6B,IAAH,CAAQjB,IAAR,EAAc,EAAEkB,SAAS5B,IAAI,CAAf,EAAd,EAAkC,UAAU6B,GAAV,EAAe;AAC7C,YAAIA,GAAJ,EAAS;AACLH,eAAGG,GAAH;AACH,SAFD,MAGK;AACDN,oBAAQC,GAAR,CAAY,aAAZ,EAA2BC,GAA3B;AACA3B,eAAGgC,MAAH,CAAUpB,IAAV,EAAgBgB,EAAhB;AACH;AACJ,KARD;AAUH,CAdD,EAcG,SAASK,QAAT,CAAkBF,GAAlB,EAAuB;;AAEtB,QAAIA,GAAJ,EAAS;AACL,cAAMA,GAAN;AACH;;AAEDN,YAAQC,GAAR,CAAY,oCAAZ,EAAkDH,KAAKC,GAAL,KAAaF,KAA/D,EAAsE,IAAtE;AACAnB,YAAQ+B,IAAR,CAAa,CAAb;AAEH,CAvBD","file":"speedtest.js","sourcesContent":["const path = require('path');\nconst async = require('async');\nconst lf = require('lockfile');\nconst fs = require('fs');\n\nconst n = +process.argv[3] || 300;\nconst a = Array.apply(null, {length: n}).map(function(_, i) {\n  return i\n})\nconst file = path.resolve(__dirname, 'speed-test.lock');\n\ntry{\n    fs.unlinkSync(file);\n}\ncatch(e){}\n\n\n/// NOTE: this should run in about 30ms on a SSD Ubuntu 16.04, that is fast, because we are locking/unlocking 300 locks\n/// *HOWEVER* if we change async.eachSeries to async.each, lockfile will barf immediately, and I can't get lockfile\n/// to not barf, using any of the options {} available to lockfile#lock.\n\n\nconst parallel = process.argv[2] === 'parallel';\n\nvar fn, msg;\n\nif(parallel){\n    msg = 'parallel';\n    fn = async.each;\n}\nelse{\n    msg = 'series';\n    fn = async.eachSeries;\n}\n\n\nconst start = Date.now();\nconsole.log(' => locking/unlocking ' + a.length + ' times, in ' + msg);\n\nfn(a, function (val, cb) {\n\n    console.log('try %d', val)\n\n    lf.lock(file, { retries: n * 3 }, function (err) {\n        if (err) {\n            cb(err);\n        }\n        else {\n            console.log('complete %d', val)\n            lf.unlock(file, cb);\n        }\n    });\n\n}, function complete(err) {\n\n    if (err) {\n        throw err;\n    }\n\n    console.log(' => Time required for lockfile => ', Date.now() - start, 'ms');\n    process.exit(0);\n\n});\n"]}