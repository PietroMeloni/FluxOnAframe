{"version":3,"sources":["../../../../../../../node_modules/npm/node_modules/es6-promise/lib/es6-promise/asap.js"],"names":["setScheduler","setAsap","len","vertxNext","customSchedulerFn","asap","callback","arg","queue","flush","scheduleFlush","scheduleFn","asapFn","browserWindow","window","undefined","browserGlobal","BrowserMutationObserver","MutationObserver","WebKitMutationObserver","isNode","self","process","toString","call","isWorker","Uint8ClampedArray","importScripts","MessageChannel","useNextTick","nextTick","useVertxTimer","useSetTimeout","useMutationObserver","iterations","observer","node","document","createTextNode","observe","characterData","data","useMessageChannel","channel","port1","onmessage","port2","postMessage","globalSetTimeout","setTimeout","Array","i","attemptVertx","vertx","Function","require","runOnLoop","runOnContext","e"],"mappings":";;;;;QAoBgBA,Y,GAAAA,Y;QAIAC,O,GAAAA,O;AAxBhB,IAAIC,MAAM,CAAV;AACA,IAAIC,kBAAJ;AACA,IAAIC,0BAAJ;;AAEO,IAAIC,sBAAO,SAASA,IAAT,CAAcC,QAAd,EAAwBC,GAAxB,EAA6B;AAC7CC,QAAMN,GAAN,IAAaI,QAAb;AACAE,QAAMN,MAAM,CAAZ,IAAiBK,GAAjB;AACAL,SAAO,CAAP;AACA,MAAIA,QAAQ,CAAZ,EAAe;AACb;AACA;AACA;AACA,QAAIE,iBAAJ,EAAuB;AACrBA,wBAAkBK,KAAlB;AACD,KAFD,MAEO;AACLC;AACD;AACF;AACF,CAdM;;AAgBA,SAASV,YAAT,CAAsBW,UAAtB,EAAkC;AACvCP,sBAAoBO,UAApB;AACD;;AAEM,SAASV,OAAT,CAAiBW,MAAjB,EAAyB;AAC9B,UArBSP,IAqBT,UAAOO,MAAP;AACD;;AAED,IAAMC,gBAAiB,OAAOC,MAAP,KAAkB,WAAnB,GAAkCA,MAAlC,GAA2CC,SAAjE;AACA,IAAMC,gBAAgBH,iBAAiB,EAAvC;AACA,IAAMI,0BAA0BD,cAAcE,gBAAd,IAAkCF,cAAcG,sBAAhF;AACA,IAAMC,SAAS,OAAOC,IAAP,KAAgB,WAAhB,IAA+B,OAAOC,OAAP,KAAmB,WAAlD,IAAiE,GAAGC,QAAH,CAAYC,IAAZ,CAAiBF,OAAjB,MAA8B,kBAA9G;;AAEA;AACA,IAAMG,WAAW,OAAOC,iBAAP,KAA6B,WAA7B,IACf,OAAOC,aAAP,KAAyB,WADV,IAEf,OAAOC,cAAP,KAA0B,WAF5B;;AAIA;AACA,SAASC,WAAT,GAAuB;AACrB;AACA;AACA,SAAO;AAAA,WAAMP,QAAQQ,QAAR,CAAiBrB,KAAjB,CAAN;AAAA,GAAP;AACD;;AAED;AACA,SAASsB,aAAT,GAAyB;AACvB,MAAI,OAAO5B,SAAP,KAAqB,WAAzB,EAAsC;AACpC,WAAO,YAAW;AAChBA,gBAAUM,KAAV;AACD,KAFD;AAGD;;AAED,SAAOuB,eAAP;AACD;;AAED,SAASC,mBAAT,GAA+B;AAC7B,MAAIC,aAAa,CAAjB;AACA,MAAMC,WAAW,IAAIlB,uBAAJ,CAA4BR,KAA5B,CAAjB;AACA,MAAM2B,OAAOC,SAASC,cAAT,CAAwB,EAAxB,CAAb;AACAH,WAASI,OAAT,CAAiBH,IAAjB,EAAuB,EAAEI,eAAe,IAAjB,EAAvB;;AAEA,SAAO,YAAM;AACXJ,SAAKK,IAAL,GAAaP,aAAa,EAAEA,UAAF,GAAe,CAAzC;AACD,GAFD;AAGD;;AAED;AACA,SAASQ,iBAAT,GAA6B;AAC3B,MAAMC,UAAU,IAAIf,cAAJ,EAAhB;AACAe,UAAQC,KAAR,CAAcC,SAAd,GAA0BpC,KAA1B;AACA,SAAO;AAAA,WAAMkC,QAAQG,KAAR,CAAcC,WAAd,CAA0B,CAA1B,CAAN;AAAA,GAAP;AACD;;AAED,SAASf,aAAT,GAAyB;AACvB;AACA;AACA,MAAMgB,mBAAmBC,UAAzB;AACA,SAAO;AAAA,WAAMD,iBAAiBvC,KAAjB,EAAwB,CAAxB,CAAN;AAAA,GAAP;AACD;;AAED,IAAMD,QAAQ,IAAI0C,KAAJ,CAAU,IAAV,CAAd;AACA,SAASzC,KAAT,GAAiB;AACf,OAAK,IAAI0C,IAAI,CAAb,EAAgBA,IAAIjD,GAApB,EAAyBiD,KAAG,CAA5B,EAA+B;AAC7B,QAAI7C,WAAWE,MAAM2C,CAAN,CAAf;AACA,QAAI5C,MAAMC,MAAM2C,IAAE,CAAR,CAAV;;AAEA7C,aAASC,GAAT;;AAEAC,UAAM2C,CAAN,IAAWpC,SAAX;AACAP,UAAM2C,IAAE,CAAR,IAAapC,SAAb;AACD;;AAEDb,QAAM,CAAN;AACD;;AAED,SAASkD,YAAT,GAAwB;AACtB,MAAI;AACF,QAAMC,QAAQC,SAAS,aAAT,IAA0BC,OAA1B,CAAkC,OAAlC,CAAd;AACApD,gBAAYkD,MAAMG,SAAN,IAAmBH,MAAMI,YAArC;AACA,WAAO1B,eAAP;AACD,GAJD,CAIE,OAAM2B,CAAN,EAAS;AACT,WAAO1B,eAAP;AACD;AACF;;AAED,IAAItB,sBAAJ;AACA;AACA,IAAIU,MAAJ,EAAY;AACVV,kBAAgBmB,aAAhB;AACD,CAFD,MAEO,IAAIZ,uBAAJ,EAA6B;AAClCP,kBAAgBuB,qBAAhB;AACD,CAFM,MAEA,IAAIR,QAAJ,EAAc;AACnBf,kBAAgBgC,mBAAhB;AACD,CAFM,MAEA,IAAI7B,kBAAkBE,SAAlB,IAA+B,OAAOwC,OAAP,KAAmB,UAAtD,EAAkE;AACvE7C,kBAAgB0C,cAAhB;AACD,CAFM,MAEA;AACL1C,kBAAgBsB,eAAhB;AACD","file":"asap.js","sourcesContent":["let len = 0;\nlet vertxNext;\nlet customSchedulerFn;\n\nexport var asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n}\n\nexport function setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nexport function setAsap(asapFn) {\n  asap = asapFn;\n}\n\nconst browserWindow = (typeof window !== 'undefined') ? window : undefined;\nconst browserGlobal = browserWindow || {};\nconst BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nconst isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nconst isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n  typeof importScripts !== 'undefined' &&\n  typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return () => process.nextTick(flush);\n}\n\n// vertx\nfunction useVertxTimer() {\n  if (typeof vertxNext !== 'undefined') {\n    return function() {\n      vertxNext(flush);\n    };\n  }\n\n  return useSetTimeout();\n}\n\nfunction useMutationObserver() {\n  let iterations = 0;\n  const observer = new BrowserMutationObserver(flush);\n  const node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return () => {\n    node.data = (iterations = ++iterations % 2);\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  const channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return () => channel.port2.postMessage(0);\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  const globalSetTimeout = setTimeout;\n  return () => globalSetTimeout(flush, 1);\n}\n\nconst queue = new Array(1000);\nfunction flush() {\n  for (let i = 0; i < len; i+=2) {\n    let callback = queue[i];\n    let arg = queue[i+1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i+1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    const vertx = Function('return this')().require('vertx');\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch(e) {\n    return useSetTimeout();\n  }\n}\n\nlet scheduleFlush;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && typeof require === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n"]}