{"version":3,"sources":["../../../../../../../node_modules/npm/node_modules/es6-promise/lib/es6-promise/promise.js"],"names":["needsResolver","TypeError","needsNew","Promise","resolver","PROMISE_ID","_result","_state","undefined","_subscribers","noop","onRejection","then","callback","promise","constructor","resolve","value","reason","prototype","all","race","Resolve","reject","Reject","_setScheduler","setScheduler","_setAsap","setAsap","_asap","asap"],"mappings":";;;;;;;;AAAA;;AAGA;;AAMA;;AAMA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;AAEA,SAASA,aAAT,GAAyB;AACvB,QAAM,IAAIC,SAAJ,CAAc,oFAAd,CAAN;AACD;;AAED,SAASC,QAAT,GAAoB;AAClB,QAAM,IAAID,SAAJ,CAAc,uHAAd,CAAN;AACD;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAwGME,O;AACJ,mBAAYC,QAAZ,EAAsB;AAAA;;AACpB,SAAKC,oBAAL,IAAmB,uBAAnB;AACA,SAAKC,OAAL,GAAe,KAAKC,MAAL,GAAcC,SAA7B;AACA,SAAKC,YAAL,GAAoB,EAApB;;AAEA,QAAIC,mBAASN,QAAb,EAAuB;AACrB,aAAOA,QAAP,KAAoB,UAApB,IAAkCJ,eAAlC;AACA,sBAAgBG,OAAhB,GAA0B,iCAAkB,IAAlB,EAAwBC,QAAxB,CAA1B,GAA8DF,UAA9D;AACD;AACF;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkME;;;;;;;;;;;;;;;;;;;;;;;;;;;2BA2BIS,W,EAAa;AACjB,aAAO,KAAKC,IAAL,CAAU,IAAV,EAAgBD,WAAhB,CAAP;AACD;;AAEH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BAsCUE,Q,EAAU;AAChB,UAAIC,UAAU,IAAd;AACA,UAAIC,cAAcD,QAAQC,WAA1B;;AAEA,aAAOD,QAAQF,IAAR,CAAa;AAAA,eAASG,YAAYC,OAAZ,CAAoBH,UAApB,EAAgCD,IAAhC,CAAqC;AAAA,iBAAMK,KAAN;AAAA,SAArC,CAAT;AAAA,OAAb,EACY;AAAA,eAAUF,YAAYC,OAAZ,CAAoBH,UAApB,EAAgCD,IAAhC,CAAqC,YAAM;AAAE,gBAAMM,MAAN;AAAe,SAA5D,CAAV;AAAA,OADZ,CAAP;AAED;;;;;;AAGHf,QAAQgB,SAAR,CAAkBP,IAAlB,GAAyBA,cAAzB;kBACeT,O;;AACfA,QAAQiB,GAAR,GAAcA,aAAd;AACAjB,QAAQkB,IAAR,GAAeA,cAAf;AACAlB,QAAQa,OAAR,GAAkBM,iBAAlB;AACAnB,QAAQoB,MAAR,GAAiBC,gBAAjB;AACArB,QAAQsB,aAAR,GAAwBC,kBAAxB;AACAvB,QAAQwB,QAAR,GAAmBC,aAAnB;AACAzB,QAAQ0B,KAAR,GAAgBC,UAAhB","file":"promise.js","sourcesContent":["import {\n  isFunction\n} from './utils';\nimport {\n  noop,\n  nextId,\n  PROMISE_ID,\n  initializePromise\n} from './-internal';\nimport {\n  asap,\n  setAsap,\n  setScheduler\n} from './asap';\n\nimport all from './promise/all';\nimport race from './promise/race';\nimport Resolve from './promise/resolve';\nimport Reject from './promise/reject';\nimport then from './then';\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {Function} resolver\n  Useful for tooling.\n  @constructor\n*/\n\nclass Promise {\n  constructor(resolver) {\n    this[PROMISE_ID] = nextId();\n    this._result = this._state = undefined;\n    this._subscribers = [];\n\n    if (noop !== resolver) {\n      typeof resolver !== 'function' && needsResolver();\n      this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n    }\n  }\n\n  /**\n  The primary way of interacting with a promise is through its `then` method,\n  which registers callbacks to receive either a promise's eventual value or the\n  reason why the promise cannot be fulfilled.\n\n  ```js\n  findUser().then(function(user){\n    // user is available\n  }, function(reason){\n    // user is unavailable, and you are given the reason why\n  });\n  ```\n\n  Chaining\n  --------\n\n  The return value of `then` is itself a promise.  This second, 'downstream'\n  promise is resolved with the return value of the first promise's fulfillment\n  or rejection handler, or rejected if the handler throws an exception.\n\n  ```js\n  findUser().then(function (user) {\n    return user.name;\n  }, function (reason) {\n    return 'default name';\n  }).then(function (userName) {\n    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n    // will be `'default name'`\n  });\n\n  findUser().then(function (user) {\n    throw new Error('Found user, but still unhappy');\n  }, function (reason) {\n    throw new Error('`findUser` rejected and we're unhappy');\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n  });\n  ```\n  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\n  ```js\n  findUser().then(function (user) {\n    throw new PedagogicalException('Upstream error');\n  }).then(function (value) {\n    // never reached\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // The `PedgagocialException` is propagated all the way down to here\n  });\n  ```\n\n  Assimilation\n  ------------\n\n  Sometimes the value you want to propagate to a downstream promise can only be\n  retrieved asynchronously. This can be achieved by returning a promise in the\n  fulfillment or rejection handler. The downstream promise will then be pending\n  until the returned promise is settled. This is called *assimilation*.\n\n  ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // The user's comments are now available\n  });\n  ```\n\n  If the assimliated promise rejects, then the downstream promise will also reject.\n\n  ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // If `findCommentsByAuthor` fulfills, we'll have the value here\n  }, function (reason) {\n    // If `findCommentsByAuthor` rejects, we'll have the reason here\n  });\n  ```\n\n  Simple Example\n  --------------\n\n  Synchronous Example\n\n  ```javascript\n  let result;\n\n  try {\n    result = findResult();\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n\n  Errback Example\n\n  ```js\n  findResult(function(result, err){\n    if (err) {\n      // failure\n    } else {\n      // success\n    }\n  });\n  ```\n\n  Promise Example;\n\n  ```javascript\n  findResult().then(function(result){\n    // success\n  }, function(reason){\n    // failure\n  });\n  ```\n\n  Advanced Example\n  --------------\n\n  Synchronous Example\n\n  ```javascript\n  let author, books;\n\n  try {\n    author = findAuthor();\n    books  = findBooksByAuthor(author);\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n\n  Errback Example\n\n  ```js\n\n  function foundBooks(books) {\n\n  }\n\n  function failure(reason) {\n\n  }\n\n  findAuthor(function(author, err){\n    if (err) {\n      failure(err);\n      // failure\n    } else {\n      try {\n        findBoooksByAuthor(author, function(books, err) {\n          if (err) {\n            failure(err);\n          } else {\n            try {\n              foundBooks(books);\n            } catch(reason) {\n              failure(reason);\n            }\n          }\n        });\n      } catch(error) {\n        failure(err);\n      }\n      // success\n    }\n  });\n  ```\n\n  Promise Example;\n\n  ```javascript\n  findAuthor().\n    then(findBooksByAuthor).\n    then(function(books){\n      // found books\n  }).catch(function(reason){\n    // something went wrong\n  });\n  ```\n\n  @method then\n  @param {Function} onFulfilled\n  @param {Function} onRejected\n  Useful for tooling.\n  @return {Promise}\n  */\n\n    /**\n  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n  as the catch block of a try/catch statement.\n\n  ```js\n  function findAuthor(){\n    throw new Error('couldn't find that author');\n  }\n\n  // synchronous\n  try {\n    findAuthor();\n  } catch(reason) {\n    // something went wrong\n  }\n\n  // async with promises\n  findAuthor().catch(function(reason){\n    // something went wrong\n  });\n  ```\n\n  @method catch\n  @param {Function} onRejection\n  Useful for tooling.\n  @return {Promise}\n  */\n  catch(onRejection) {\n    return this.then(null, onRejection);\n  }\n\n/**\n  `finally` will be invoked regardless of the promise's fate just as native\n  try/catch/finally behaves\n\n  Synchronous example:\n\n  ```js\n  findAuthor() {\n    if (Math.random() > 0.5) {\n      throw new Error();\n    }\n    return new Author();\n  }\n\n  try {\n    return findAuthor(); // succeed or fail\n  } catch(error) {\n    return findOtherAuther();\n  } finally {\n    // always runs\n    // doesn't affect the return value\n  }\n  ```\n\n  Asynchronous example:\n\n  ```js\n  findAuthor().catch(function(reason){\n    return findOtherAuther();\n  }).finally(function(){\n    // author was either found, or not\n  });\n  ```\n\n  @method finally\n  @param {Function} callback\n  @return {Promise}\n*/\n  finally(callback) {\n    let promise = this;\n    let constructor = promise.constructor;\n\n    return promise.then(value => constructor.resolve(callback()).then(() => value),\n                       reason => constructor.resolve(callback()).then(() => { throw reason; }));\n  }\n}\n\nPromise.prototype.then = then;\nexport default Promise;\nPromise.all = all;\nPromise.race = race;\nPromise.resolve = Resolve;\nPromise.reject = Reject;\nPromise._setScheduler = setScheduler;\nPromise._setAsap = setAsap;\nPromise._asap = asap;\n\n"]}