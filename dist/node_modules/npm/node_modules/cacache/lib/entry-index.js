'use strict';

var _templateObject = _taggedTemplateLiteral(['No cache entry for `', '` found in `', '`'], ['No cache entry for \\`', '\\` found in \\`', '\\`']);

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BB = require('bluebird');

var contentPath = require('./content/path');
var crypto = require('crypto');
var figgyPudding = require('figgy-pudding');
var fixOwner = require('./util/fix-owner');
var fs = require('graceful-fs');
var hashToSegments = require('./util/hash-to-segments');
var ms = require('mississippi');
var path = require('path');
var ssri = require('ssri');
var Y = require('./util/y.js');

var indexV = require('../package.json')['cache-version'].index;

var appendFileAsync = BB.promisify(fs.appendFile);
var readFileAsync = BB.promisify(fs.readFile);
var readdirAsync = BB.promisify(fs.readdir);
var concat = ms.concat;
var from = ms.from;

module.exports.NotFoundError = function (_Error) {
  _inherits(NotFoundError, _Error);

  function NotFoundError(cache, key) {
    _classCallCheck(this, NotFoundError);

    var _this = _possibleConstructorReturn(this, (NotFoundError.__proto__ || Object.getPrototypeOf(NotFoundError)).call(this, Y(_templateObject, key, cache)));

    _this.code = 'ENOENT';
    _this.cache = cache;
    _this.key = key;
    return _this;
  }

  return NotFoundError;
}(Error);

var IndexOpts = figgyPudding({
  metadata: {},
  size: {},
  uid: {},
  gid: {}
});

module.exports.insert = insert;
function insert(cache, key, integrity, opts) {
  opts = IndexOpts(opts);
  var bucket = bucketPath(cache, key);
  var entry = {
    key: key,
    integrity: integrity && ssri.stringify(integrity),
    time: Date.now(),
    size: opts.size,
    metadata: opts.metadata
  };
  return fixOwner.mkdirfix(path.dirname(bucket), opts.uid, opts.gid).then(function () {
    var stringified = JSON.stringify(entry);
    // NOTE - Cleverness ahoy!
    //
    // This works because it's tremendously unlikely for an entry to corrupt
    // another while still preserving the string length of the JSON in
    // question. So, we just slap the length in there and verify it on read.
    //
    // Thanks to @isaacs for the whiteboarding session that ended up with this.
    return appendFileAsync(bucket, '\n' + hashEntry(stringified) + '\t' + stringified);
  }).then(function () {
    return fixOwner.chownr(bucket, opts.uid, opts.gid);
  }).catch({ code: 'ENOENT' }, function () {
    // There's a class of race conditions that happen when things get deleted
    // during fixOwner, or between the two mkdirfix/chownr calls.
    //
    // It's perfectly fine to just not bother in those cases and lie
    // that the index entry was written. Because it's a cache.
  }).then(function () {
    return formatEntry(cache, entry);
  });
}

module.exports.find = find;
function find(cache, key) {
  var bucket = bucketPath(cache, key);
  return bucketEntries(cache, bucket).then(function (entries) {
    return entries.reduce(function (latest, next) {
      if (next && next.key === key) {
        return formatEntry(cache, next);
      } else {
        return latest;
      }
    }, null);
  }).catch(function (err) {
    if (err.code === 'ENOENT') {
      return null;
    } else {
      throw err;
    }
  });
}

module.exports.delete = del;
function del(cache, key, opts) {
  return insert(cache, key, null, opts);
}

module.exports.lsStream = lsStream;
function lsStream(cache) {
  var indexDir = bucketDir(cache);
  var stream = from.obj();

  // "/cachename/*"
  readdirOrEmpty(indexDir).map(function (bucket) {
    var bucketPath = path.join(indexDir, bucket);

    // "/cachename/<bucket 0xFF>/*"
    return readdirOrEmpty(bucketPath).map(function (subbucket) {
      var subbucketPath = path.join(bucketPath, subbucket);

      // "/cachename/<bucket 0xFF>/<bucket 0xFF>/*"
      return readdirOrEmpty(subbucketPath).map(function (entry) {
        var getKeyToEntry = bucketEntries(cache, path.join(subbucketPath, entry)).reduce(function (acc, entry) {
          acc.set(entry.key, entry);
          return acc;
        }, new Map());

        return getKeyToEntry.then(function (reduced) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = reduced.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _entry = _step.value;

              var formatted = formatEntry(cache, _entry);
              formatted && stream.push(formatted);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }).catch({ code: 'ENOENT' }, nop);
      });
    });
  }).then(function () {
    stream.push(null);
  }, function (err) {
    stream.emit('error', err);
  });

  return stream;
}

module.exports.ls = ls;
function ls(cache) {
  return BB.fromNode(function (cb) {
    lsStream(cache).on('error', cb).pipe(concat(function (entries) {
      cb(null, entries.reduce(function (acc, xs) {
        acc[xs.key] = xs;
        return acc;
      }, {}));
    }));
  });
}

function bucketEntries(cache, bucket, filter) {
  return readFileAsync(bucket, 'utf8').then(function (data) {
    var entries = [];
    data.split('\n').forEach(function (entry) {
      if (!entry) {
        return;
      }
      var pieces = entry.split('\t');
      if (!pieces[1] || hashEntry(pieces[1]) !== pieces[0]) {
        // Hash is no good! Corruption or malice? Doesn't matter!
        // EJECT EJECT
        return;
      }
      var obj = void 0;
      try {
        obj = JSON.parse(pieces[1]);
      } catch (e) {
        // Entry is corrupted!
        return;
      }
      if (obj) {
        entries.push(obj);
      }
    });
    return entries;
  });
}

module.exports._bucketDir = bucketDir;
function bucketDir(cache) {
  return path.join(cache, 'index-v' + indexV);
}

module.exports._bucketPath = bucketPath;
function bucketPath(cache, key) {
  var hashed = hashKey(key);
  return path.join.apply(path, [bucketDir(cache)].concat(hashToSegments(hashed)));
}

module.exports._hashKey = hashKey;
function hashKey(key) {
  return hash(key, 'sha256');
}

module.exports._hashEntry = hashEntry;
function hashEntry(str) {
  return hash(str, 'sha1');
}

function hash(str, digest) {
  return crypto.createHash(digest).update(str).digest('hex');
}

function formatEntry(cache, entry) {
  // Treat null digests as deletions. They'll shadow any previous entries.
  if (!entry.integrity) {
    return null;
  }
  return {
    key: entry.key,
    integrity: entry.integrity,
    path: contentPath(cache, entry.integrity),
    size: entry.size,
    time: entry.time,
    metadata: entry.metadata
  };
}

function readdirOrEmpty(dir) {
  return readdirAsync(dir).catch({ code: 'ENOENT' }, function () {
    return [];
  }).catch({ code: 'ENOTDIR' }, function () {
    return [];
  });
}

function nop() {}
//# sourceMappingURL=entry-index.js.map