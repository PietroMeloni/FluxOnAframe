'use strict';

module.exports = lockVerify;

var fs = require('fs');
var path = require('path');
var npa = require('npm-package-arg');
var semver = require('semver');

function lockVerify(check) {
  if (!check) check = '.';

  var pjson = readJson(check + '/package.json');
  var plock = readJson(check + '/npm-shrinkwrap.json').catch(function () {
    return readJson(check + '/package-lock.json');
  });

  return Promise.all([pjson, plock]).then(function (result) {
    var pjson = result[0];
    var plock = result[1];
    var warnings = [];
    var errors = [];

    var _loop = function _loop(type) {
      var deps = pjson[type[0]];
      if (!deps) return 'continue';
      var isOptional = type[1];
      Object.keys(deps).forEach(function (name) {
        var spec = npa.resolve(name, deps[name]);
        var lock = plock.dependencies[name];
        if (!lock) {
          if (isOptional) {
            warnings.push('Optional missing: ' + name + '@' + deps[name]);
          } else {
            errors.push('Missing: ' + name + '@' + deps[name]);
          }
          return;
        }
        if (spec.registry) {
          // Can't match tags to package-lock w/o network
          if (spec.type === 'tag') return;
          if (!semver.satisfies(lock.version, spec.fetchSpec)) {
            errors.push("Invalid: lock file's " + name + '@' + lock.version + ' does not satisfy ' + name + '@' + spec.fetchSpec);
            return;
          }
        } else if (spec.type === 'git') {
          // can't verify git w/o network
          return;
        } else if (spec.type === 'remote') {
          if (lock.version !== spec.fetchSpec) {
            errors.push("Invalid: lock file's " + name + '@' + lock.version + ' does not satisfy ' + name + '@' + spec.fetchSpec);
            return;
          }
        } else if (spec.type === 'file' || spec.type === 'directory') {
          var lockSpec = npa.resolve(name, lock.version);
          if (spec.fetchSpec !== lockSpec.fetchSpec) {
            errors.push("Invalid: lock file's " + name + '@' + lock.version + ' does not satisfy ' + name + '@' + deps[name]);
            return;
          }
        } else {
          console.log(spec);
        }
      });
    };

    var _arr = [['dependencies'], ['devDependencies'], ['optionalDependencies', true]];
    for (var _i = 0; _i < _arr.length; _i++) {
      var type = _arr[_i];
      var _ret = _loop(type);

      if (_ret === 'continue') continue;
    }
    return Promise.resolve({ status: errors.length === 0, warnings: warnings, errors: errors });
  });
}

function readJson(file) {
  return new Promise(function (resolve, reject) {
    fs.readFile(file, function (err, content) {
      if (err) return reject(err);
      return resolve(JSON.parse(content));
    });
  });
}
//# sourceMappingURL=index.js.map