{"version":3,"sources":["../../../../../node_modules/npm/node_modules/detect-indent/index.js"],"names":["INDENT_RE","getMostUsed","indents","result","maxUsed","maxWeight","entry","key","val","u","w","Number","module","exports","str","TypeError","tabs","spaces","prev","Map","current","isIndent","split","line","indent","matches","match","length","diff","get","set","amount","type","repeat"],"mappings":"AAAA;;AAEA;AACA;;AACA,IAAMA,YAAY,eAAlB;;AAEA,SAASC,WAAT,CAAqBC,OAArB,EAA8B;AAC7B,KAAIC,SAAS,CAAb;AACA,KAAIC,UAAU,CAAd;AACA,KAAIC,YAAY,CAAhB;;AAH6B;AAAA;AAAA;;AAAA;AAK7B,uBAAoBH,OAApB,8HAA6B;AAAA,OAAlBI,KAAkB;;AAC5B;AACA,OAAMC,MAAMD,MAAM,CAAN,CAAZ;AACA,OAAME,MAAMF,MAAM,CAAN,CAAZ;;AAEA,OAAMG,IAAID,IAAI,CAAJ,CAAV;AACA,OAAME,IAAIF,IAAI,CAAJ,CAAV;;AAEA,OAAIC,IAAIL,OAAJ,IAAgBK,MAAML,OAAN,IAAiBM,IAAIL,SAAzC,EAAqD;AACpDD,cAAUK,CAAV;AACAJ,gBAAYK,CAAZ;AACAP,aAASQ,OAAOJ,GAAP,CAAT;AACA;AACD;AAlB4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAoB7B,QAAOJ,MAAP;AACA;;AAEDS,OAAOC,OAAP,GAAiB,eAAO;AACvB,KAAI,OAAOC,GAAP,KAAe,QAAnB,EAA6B;AAC5B,QAAM,IAAIC,SAAJ,CAAc,mBAAd,CAAN;AACA;;AAED;AACA,KAAIC,OAAO,CAAX;AACA,KAAIC,SAAS,CAAb;;AAEA;AACA,KAAIC,OAAO,CAAX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAMhB,UAAU,IAAIiB,GAAJ,EAAhB;;AAEA;AACA,KAAIC,gBAAJ;;AAEA;AACA,KAAIC,iBAAJ;;AA3BuB;AAAA;AAAA;;AAAA;AA6BvB,wBAAmBP,IAAIQ,KAAJ,CAAU,KAAV,CAAnB,mIAAqC;AAAA,OAA1BC,IAA0B;;AACpC,OAAI,CAACA,IAAL,EAAW;AACV;AACA;AACA;;AAED,OAAIC,gBAAJ;AACA,OAAMC,UAAUF,KAAKG,KAAL,CAAW1B,SAAX,CAAhB;;AAEA,OAAIyB,OAAJ,EAAa;AACZD,cAASC,QAAQ,CAAR,EAAWE,MAApB;;AAEA,QAAIF,QAAQ,CAAR,CAAJ,EAAgB;AACfR;AACA,KAFD,MAEO;AACND;AACA;AACD,IARD,MAQO;AACNQ,cAAS,CAAT;AACA;;AAED,OAAMI,OAAOJ,UAASN,IAAtB;AACAA,UAAOM,OAAP;;AAEA,OAAII,IAAJ,EAAU;AACT;;AAEAP,eAAWO,OAAO,CAAlB;;AAEAR,cAAUlB,QAAQ2B,GAAR,CAAYR,WAAWO,IAAX,GAAkB,CAACA,IAA/B,CAAV;;AAEA,QAAIR,OAAJ,EAAa;AACZA,aAAQ,CAAR;AACA,KAFD,MAEO;AACNA,eAAU,CAAC,CAAD,EAAI,CAAJ,CAAV;AACAlB,aAAQ4B,GAAR,CAAYF,IAAZ,EAAkBR,OAAlB;AACA;AACD,IAbD,MAaO,IAAIA,OAAJ,EAAa;AACnB;AACAA,YAAQ,CAAR,KAAcT,OAAOU,QAAP,CAAd;AACA;AACD;AAtEsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAwEvB,KAAMU,SAAS9B,YAAYC,OAAZ,CAAf;;AAEA,KAAI8B,aAAJ;AACA,KAAIR,eAAJ;AACA,KAAI,CAACO,MAAL,EAAa;AACZC,SAAO,IAAP;AACAR,WAAS,EAAT;AACA,EAHD,MAGO,IAAIP,UAAUD,IAAd,EAAoB;AAC1BgB,SAAO,OAAP;AACAR,WAAS,IAAIS,MAAJ,CAAWF,MAAX,CAAT;AACA,EAHM,MAGA;AACNC,SAAO,KAAP;AACAR,WAAS,KAAKS,MAAL,CAAYF,MAAZ,CAAT;AACA;;AAED,QAAO;AACNA,gBADM;AAENC,YAFM;AAGNR;AAHM,EAAP;AAKA,CA5FD","file":"index.js","sourcesContent":["'use strict';\n\n// detect either spaces or tabs but not both to properly handle tabs\n// for indentation and spaces for alignment\nconst INDENT_RE = /^(?:( )+|\\t+)/;\n\nfunction getMostUsed(indents) {\n\tlet result = 0;\n\tlet maxUsed = 0;\n\tlet maxWeight = 0;\n\n\tfor (const entry of indents) {\n\t\t// TODO: use destructuring when targeting Node.js 6\n\t\tconst key = entry[0];\n\t\tconst val = entry[1];\n\n\t\tconst u = val[0];\n\t\tconst w = val[1];\n\n\t\tif (u > maxUsed || (u === maxUsed && w > maxWeight)) {\n\t\t\tmaxUsed = u;\n\t\t\tmaxWeight = w;\n\t\t\tresult = Number(key);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nmodule.exports = str => {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// used to see if tabs or spaces are the most used\n\tlet tabs = 0;\n\tlet spaces = 0;\n\n\t// remember the size of previous line's indentation\n\tlet prev = 0;\n\n\t// remember how many indents/unindents as occurred for a given size\n\t// and how much lines follow a given indentation\n\t//\n\t// indents = {\n\t//    3: [1, 0],\n\t//    4: [1, 5],\n\t//    5: [1, 0],\n\t//   12: [1, 0],\n\t// }\n\tconst indents = new Map();\n\n\t// pointer to the array of last used indent\n\tlet current;\n\n\t// whether the last action was an indent (opposed to an unindent)\n\tlet isIndent;\n\n\tfor (const line of str.split(/\\n/g)) {\n\t\tif (!line) {\n\t\t\t// ignore empty lines\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet indent;\n\t\tconst matches = line.match(INDENT_RE);\n\n\t\tif (matches) {\n\t\t\tindent = matches[0].length;\n\n\t\t\tif (matches[1]) {\n\t\t\t\tspaces++;\n\t\t\t} else {\n\t\t\t\ttabs++;\n\t\t\t}\n\t\t} else {\n\t\t\tindent = 0;\n\t\t}\n\n\t\tconst diff = indent - prev;\n\t\tprev = indent;\n\n\t\tif (diff) {\n\t\t\t// an indent or unindent has been detected\n\n\t\t\tisIndent = diff > 0;\n\n\t\t\tcurrent = indents.get(isIndent ? diff : -diff);\n\n\t\t\tif (current) {\n\t\t\t\tcurrent[0]++;\n\t\t\t} else {\n\t\t\t\tcurrent = [1, 0];\n\t\t\t\tindents.set(diff, current);\n\t\t\t}\n\t\t} else if (current) {\n\t\t\t// if the last action was an indent, increment the weight\n\t\t\tcurrent[1] += Number(isIndent);\n\t\t}\n\t}\n\n\tconst amount = getMostUsed(indents);\n\n\tlet type;\n\tlet indent;\n\tif (!amount) {\n\t\ttype = null;\n\t\tindent = '';\n\t} else if (spaces >= tabs) {\n\t\ttype = 'space';\n\t\tindent = ' '.repeat(amount);\n\t} else {\n\t\ttype = 'tab';\n\t\tindent = '\\t'.repeat(amount);\n\t}\n\n\treturn {\n\t\tamount,\n\t\ttype,\n\t\tindent\n\t};\n};\n"]}