{"version":3,"sources":["../../../../../../../../node_modules/npm/node_modules/node-gyp/node_modules/tar/lib/parse.js"],"names":["module","exports","Parse","create","stream","require","Stream","BlockStream","tar","TarHeader","Entry","BufferEntry","ExtendedHeader","assert","ok","inherits","fstream","Reader","me","apply","writable","readable","_stream","position","_ended","on","e","emit","c","_process","_streamEnd","prototype","_entry","error","write","i","l","length","end","_read","entry","_abort","_remaining","zero","_eofStarted","_startEntry","header","self","ev","EntryType","onend","meta","size","cksumValid","Error","tar_file_offset","tar_block","types","type","_global","Object","keys","fields","forEach","k","_extended","linkpath","body","path","global","extended","pause","resume","listeners","props"],"mappings":"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","file":"parse.js","sourcesContent":["\n// A writable stream.\n// It emits \"entry\" events, which provide a readable stream that has\n// header info attached.\n\nmodule.exports = Parse.create = Parse\n\nvar stream = require(\"stream\")\n  , Stream = stream.Stream\n  , BlockStream = require(\"block-stream\")\n  , tar = require(\"../tar.js\")\n  , TarHeader = require(\"./header.js\")\n  , Entry = require(\"./entry.js\")\n  , BufferEntry = require(\"./buffer-entry.js\")\n  , ExtendedHeader = require(\"./extended-header.js\")\n  , assert = require(\"assert\").ok\n  , inherits = require(\"inherits\")\n  , fstream = require(\"fstream\")\n\n// reading a tar is a lot like reading a directory\n// However, we're actually not going to run the ctor,\n// since it does a stat and various other stuff.\n// This inheritance gives us the pause/resume/pipe\n// behavior that is desired.\ninherits(Parse, fstream.Reader)\n\nfunction Parse () {\n  var me = this\n  if (!(me instanceof Parse)) return new Parse()\n\n  // doesn't apply fstream.Reader ctor?\n  // no, becasue we don't want to stat/etc, we just\n  // want to get the entry/add logic from .pipe()\n  Stream.apply(me)\n\n  me.writable = true\n  me.readable = true\n  me._stream = new BlockStream(512)\n  me.position = 0\n  me._ended = false\n\n  me._stream.on(\"error\", function (e) {\n    me.emit(\"error\", e)\n  })\n\n  me._stream.on(\"data\", function (c) {\n    me._process(c)\n  })\n\n  me._stream.on(\"end\", function () {\n    me._streamEnd()\n  })\n\n  me._stream.on(\"drain\", function () {\n    me.emit(\"drain\")\n  })\n}\n\n// overridden in Extract class, since it needs to\n// wait for its DirWriter part to finish before\n// emitting \"end\"\nParse.prototype._streamEnd = function () {\n  var me = this\n  if (!me._ended || me._entry) me.error(\"unexpected eof\")\n  me.emit(\"end\")\n}\n\n// a tar reader is actually a filter, not just a readable stream.\n// So, you should pipe a tarball stream into it, and it needs these\n// write/end methods to do that.\nParse.prototype.write = function (c) {\n  if (this._ended) {\n    // gnutar puts a LOT of nulls at the end.\n    // you can keep writing these things forever.\n    // Just ignore them.\n    for (var i = 0, l = c.length; i > l; i ++) {\n      if (c[i] !== 0) return this.error(\"write() after end()\")\n    }\n    return\n  }\n  return this._stream.write(c)\n}\n\nParse.prototype.end = function (c) {\n  this._ended = true\n  return this._stream.end(c)\n}\n\n// don't need to do anything, since we're just\n// proxying the data up from the _stream.\n// Just need to override the parent's \"Not Implemented\"\n// error-thrower.\nParse.prototype._read = function () {}\n\nParse.prototype._process = function (c) {\n  assert(c && c.length === 512, \"block size should be 512\")\n\n  // one of three cases.\n  // 1. A new header\n  // 2. A part of a file/extended header\n  // 3. One of two or more EOF null blocks\n\n  if (this._entry) {\n    var entry = this._entry\n    if(!entry._abort) entry.write(c)\n    else {\n      entry._remaining -= c.length\n      if(entry._remaining < 0) entry._remaining = 0\n    }\n    if (entry._remaining === 0) {\n      entry.end()\n      this._entry = null\n    }\n  } else {\n    // either zeroes or a header\n    var zero = true\n    for (var i = 0; i < 512 && zero; i ++) {\n      zero = c[i] === 0\n    }\n\n    // eof is *at least* 2 blocks of nulls, and then the end of the\n    // file.  you can put blocks of nulls between entries anywhere,\n    // so appending one tarball to another is technically valid.\n    // ending without the eof null blocks is not allowed, however.\n    if (zero) {\n      if (this._eofStarted)\n        this._ended = true\n      this._eofStarted = true\n    } else {\n      this._eofStarted = false\n      this._startEntry(c)\n    }\n  }\n\n  this.position += 512\n}\n\n// take a header chunk, start the right kind of entry.\nParse.prototype._startEntry = function (c) {\n  var header = new TarHeader(c)\n    , self = this\n    , entry\n    , ev\n    , EntryType\n    , onend\n    , meta = false\n\n  if (null === header.size || !header.cksumValid) {\n    var e = new Error(\"invalid tar file\")\n    e.header = header\n    e.tar_file_offset = this.position\n    e.tar_block = this.position / 512\n    return this.emit(\"error\", e)\n  }\n\n  switch (tar.types[header.type]) {\n    case \"File\":\n    case \"OldFile\":\n    case \"Link\":\n    case \"SymbolicLink\":\n    case \"CharacterDevice\":\n    case \"BlockDevice\":\n    case \"Directory\":\n    case \"FIFO\":\n    case \"ContiguousFile\":\n    case \"GNUDumpDir\":\n      // start a file.\n      // pass in any extended headers\n      // These ones consumers are typically most interested in.\n      EntryType = Entry\n      ev = \"entry\"\n      break\n\n    case \"GlobalExtendedHeader\":\n      // extended headers that apply to the rest of the tarball\n      EntryType = ExtendedHeader\n      onend = function () {\n        self._global = self._global || {}\n        Object.keys(entry.fields).forEach(function (k) {\n          self._global[k] = entry.fields[k]\n        })\n      }\n      ev = \"globalExtendedHeader\"\n      meta = true\n      break\n\n    case \"ExtendedHeader\":\n    case \"OldExtendedHeader\":\n      // extended headers that apply to the next entry\n      EntryType = ExtendedHeader\n      onend = function () {\n        self._extended = entry.fields\n      }\n      ev = \"extendedHeader\"\n      meta = true\n      break\n\n    case \"NextFileHasLongLinkpath\":\n      // set linkpath=<contents> in extended header\n      EntryType = BufferEntry\n      onend = function () {\n        self._extended = self._extended || {}\n        self._extended.linkpath = entry.body\n      }\n      ev = \"longLinkpath\"\n      meta = true\n      break\n\n    case \"NextFileHasLongPath\":\n    case \"OldGnuLongPath\":\n      // set path=<contents> in file-extended header\n      EntryType = BufferEntry\n      onend = function () {\n        self._extended = self._extended || {}\n        self._extended.path = entry.body\n      }\n      ev = \"longPath\"\n      meta = true\n      break\n\n    default:\n      // all the rest we skip, but still set the _entry\n      // member, so that we can skip over their data appropriately.\n      // emit an event to say that this is an ignored entry type?\n      EntryType = Entry\n      ev = \"ignoredEntry\"\n      break\n  }\n\n  var global, extended\n  if (meta) {\n    global = extended = null\n  } else {\n    var global = this._global\n    var extended = this._extended\n\n    // extendedHeader only applies to one entry, so once we start\n    // an entry, it's over.\n    this._extended = null\n  }\n  entry = new EntryType(header, extended, global)\n  entry.meta = meta\n\n  // only proxy data events of normal files.\n  if (!meta) {\n    entry.on(\"data\", function (c) {\n      me.emit(\"data\", c)\n    })\n  }\n\n  if (onend) entry.on(\"end\", onend)\n\n  this._entry = entry\n  var me = this\n\n  entry.on(\"pause\", function () {\n    me.pause()\n  })\n\n  entry.on(\"resume\", function () {\n    me.resume()\n  })\n\n  if (this.listeners(\"*\").length) {\n    this.emit(\"*\", ev, entry)\n  }\n\n  this.emit(ev, entry)\n\n  // Zero-byte entry.  End immediately.\n  if (entry.props.size === 0) {\n    entry.end()\n    this._entry = null\n  }\n}\n"]}