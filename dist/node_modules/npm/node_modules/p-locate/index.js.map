{"version":3,"sources":["../../../../../node_modules/npm/node_modules/p-locate/index.js"],"names":["pLimit","require","EndError","value","Error","finder","Promise","all","el","then","val","reject","module","exports","iterable","tester","opts","Object","assign","concurrency","Infinity","preserveOrder","limit","items","Array","from","map","resolve","checkLimit","catch","err"],"mappings":"AAAA;;;;;;;;AACA,IAAMA,SAASC,QAAQ,SAAR,CAAf;;IAEMC,Q;;;AACL,mBAAYC,KAAZ,EAAmB;AAAA;;AAAA;;AAElB,QAAKA,KAAL,GAAaA,KAAb;AAFkB;AAGlB;;;EAJqBC,K;;AAOvB;;;AACA,IAAMC,SAAS,SAATA,MAAS;AAAA,QAAMC,QAAQC,GAAR,CAAYC,EAAZ,EAAgBC,IAAhB,CAAqB;AAAA,SAAOC,IAAI,CAAJ,MAAW,IAAX,IAAmBJ,QAAQK,MAAR,CAAe,IAAIT,QAAJ,CAAaQ,IAAI,CAAJ,CAAb,CAAf,CAA1B;AAAA,EAArB,CAAN;AAAA,CAAf;;AAEAE,OAAOC,OAAP,GAAiB,UAACC,QAAD,EAAWC,MAAX,EAAmBC,IAAnB,EAA4B;AAC5CA,QAAOC,OAAOC,MAAP,CAAc;AACpBC,eAAaC,QADO;AAEpBC,iBAAe;AAFK,EAAd,EAGJL,IAHI,CAAP;;AAKA,KAAMM,QAAQtB,OAAOgB,KAAKG,WAAZ,CAAd;;AAEA;AACA,KAAMI,QAAQC,MAAMC,IAAN,CAAWX,QAAX,EAAqBY,GAArB,CAAyB;AAAA,SAAM,CAAClB,EAAD,EAAKc,MAAM;AAAA,UAAMhB,QAAQqB,OAAR,CAAgBnB,EAAhB,EAAoBC,IAApB,CAAyBM,MAAzB,CAAN;AAAA,GAAN,CAAL,CAAN;AAAA,EAAzB,CAAd;;AAEA;AACA,KAAMa,aAAa5B,OAAOgB,KAAKK,aAAL,GAAqB,CAArB,GAAyBD,QAAhC,CAAnB;;AAEA,QAAOd,QAAQC,GAAR,CAAYgB,MAAMG,GAAN,CAAU;AAAA,SAAME,WAAW;AAAA,UAAMvB,OAAOG,EAAP,CAAN;AAAA,GAAX,CAAN;AAAA,EAAV,CAAZ,EACLC,IADK,CACA,YAAM,CAAE,CADR,EAELoB,KAFK,CAEC;AAAA,SAAOC,eAAe5B,QAAf,GAA0B4B,IAAI3B,KAA9B,GAAsCG,QAAQK,MAAR,CAAemB,GAAf,CAA7C;AAAA,EAFD,CAAP;AAGA,CAjBD","file":"index.js","sourcesContent":["'use strict';\nconst pLimit = require('p-limit');\n\nclass EndError extends Error {\n\tconstructor(value) {\n\t\tsuper();\n\t\tthis.value = value;\n\t}\n}\n\n// the input can also be a promise, so we `Promise.all()` them both\nconst finder = el => Promise.all(el).then(val => val[1] === true && Promise.reject(new EndError(val[0])));\n\nmodule.exports = (iterable, tester, opts) => {\n\topts = Object.assign({\n\t\tconcurrency: Infinity,\n\t\tpreserveOrder: true\n\t}, opts);\n\n\tconst limit = pLimit(opts.concurrency);\n\n\t// start all the promises concurrently with optional limit\n\tconst items = Array.from(iterable).map(el => [el, limit(() => Promise.resolve(el).then(tester))]);\n\n\t// check the promises either serially or concurrently\n\tconst checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);\n\n\treturn Promise.all(items.map(el => checkLimit(() => finder(el))))\n\t\t.then(() => {})\n\t\t.catch(err => err instanceof EndError ? err.value : Promise.reject(err));\n};\n"]}