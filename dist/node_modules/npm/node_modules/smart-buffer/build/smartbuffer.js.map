{"version":3,"sources":["../../../../../../node_modules/npm/node_modules/smart-buffer/build/smartbuffer.js"],"names":["Object","defineProperty","exports","value","utils_1","require","DEFAULT_SMARTBUFFER_SIZE","DEFAULT_SMARTBUFFER_ENCODING","SmartBuffer","options","length","_encoding","_writeOffset","_readOffset","isSmartBufferOptions","encoding","checkEncoding","size","isFiniteInteger","_buff","Buffer","allocUnsafe","Error","ERRORS","INVALID_SMARTBUFFER_SIZE","buff","INVALID_SMARTBUFFER_BUFFER","INVALID_SMARTBUFFER_OBJECT","offset","_readNumberValue","prototype","readInt8","readInt16BE","readInt16LE","readInt32BE","readInt32LE","_writeNumberValue","writeInt8","_insertNumberValue","writeInt16BE","writeInt16LE","writeInt32BE","writeInt32LE","readUInt8","readUInt16BE","readUInt16LE","readUInt32BE","readUInt32LE","writeUInt8","writeUInt16BE","writeUInt16LE","writeUInt32BE","writeUInt32LE","readFloatBE","readFloatLE","writeFloatBE","writeFloatLE","readDoubleBE","readDoubleLE","writeDoubleBE","writeDoubleLE","arg1","lengthVal","checkLengthValue","Math","min","slice","toString","checkOffsetValue","_handleString","arg2","nullPos","i","insertString","insertUInt8","writeString","writeOffset","endPoint","_handleBuffer","insertBuffer","writeBuffer","encodingVal","clear","isInsert","arg3","offsetVal","byteLength","ensureInsertable","_ensureWriteable","write","max","copy","INVALID_READ_BEYOND_BOUNDS","dataLength","_ensureCapacity","minLength","oldLength","data","newLength","func","byteSize","ensureReadable","call","INVALID_WRITE_BEYOND_BOUNDS","checkTargetOffset","castOptions","undefined"],"mappings":"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","file":"smartbuffer.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\n// The default Buffer size if one is not provided.\nconst DEFAULT_SMARTBUFFER_SIZE = 4096;\n// The default string encoding to use for reading/writing strings.\nconst DEFAULT_SMARTBUFFER_ENCODING = 'utf8';\nclass SmartBuffer {\n    /**\n       * Creates a new SmartBuffer instance.\n       *\n       * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.\n       */\n    constructor(options) {\n        this.length = 0;\n        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;\n        this._writeOffset = 0;\n        this._readOffset = 0;\n        if (SmartBuffer.isSmartBufferOptions(options)) {\n            // Checks for encoding\n            if (options.encoding) {\n                utils_1.checkEncoding(options.encoding);\n                this._encoding = options.encoding;\n            }\n            // Checks for initial size length\n            if (options.size) {\n                if (utils_1.isFiniteInteger(options.size) && options.size > 0) {\n                    this._buff = Buffer.allocUnsafe(options.size);\n                }\n                else {\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);\n                }\n                // Check for initial Buffer\n            }\n            else if (options.buff) {\n                if (options.buff instanceof Buffer) {\n                    this._buff = options.buff;\n                    this.length = options.buff.length;\n                }\n                else {\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);\n                }\n            }\n            else {\n                this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n            }\n        }\n        else {\n            // If something was passed but it's not a SmartBufferOptions object\n            if (typeof options !== 'undefined') {\n                throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);\n            }\n            // Otherwise default to sane options\n            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n        }\n    }\n    /**\n       * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.\n       *\n       * @param size { Number } The size of the internal Buffer.\n       * @param encoding { String } The BufferEncoding to use for strings.\n       *\n       * @return { SmartBuffer }\n       */\n    static fromSize(size, encoding) {\n        return new this({\n            size: size,\n            encoding: encoding\n        });\n    }\n    /**\n       * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.\n       *\n       * @param buffer { Buffer } The Buffer to use as the internal Buffer value.\n       * @param encoding { String } The BufferEncoding to use for strings.\n       *\n       * @return { SmartBuffer }\n       */\n    static fromBuffer(buff, encoding) {\n        return new this({\n            buff: buff,\n            encoding: encoding\n        });\n    }\n    /**\n       * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.\n       *\n       * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.\n       */\n    static fromOptions(options) {\n        return new this(options);\n    }\n    /**\n       * Type checking function that determines if an object is a SmartBufferOptions object.\n       */\n    static isSmartBufferOptions(options) {\n        const castOptions = options;\n        return castOptions && (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined);\n    }\n    // Signed integers\n    /**\n       * Reads an Int8 value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n    readInt8(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);\n    }\n    /**\n       * Reads an Int16BE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n    readInt16BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);\n    }\n    /**\n       * Reads an Int16LE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n    readInt16LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);\n    }\n    /**\n       * Reads an Int32BE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n    readInt32BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);\n    }\n    /**\n       * Reads an Int32LE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n    readInt32LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);\n    }\n    /**\n       * Writes an Int8 value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n    writeInt8(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n        return this;\n    }\n    /**\n       * Inserts an Int8 value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n    insertInt8(value, offset) {\n        this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n        return this;\n    }\n    /**\n       * Writes an Int16BE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n    writeInt16BE(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n        return this;\n    }\n    /**\n       * Inserts an Int16BE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n    insertInt16BE(value, offset) {\n        this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n        return this;\n    }\n    /**\n       * Writes an Int16LE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n    writeInt16LE(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n        return this;\n    }\n    /**\n       * Inserts an Int16LE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n    insertInt16LE(value, offset) {\n        this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n        return this;\n    }\n    /**\n       * Writes an Int32BE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n    writeInt32BE(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n        return this;\n    }\n    /**\n       * Inserts an Int32BE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n    insertInt32BE(value, offset) {\n        this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n        return this;\n    }\n    /**\n       * Writes an Int32LE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n    writeInt32LE(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n        return this;\n    }\n    /**\n       * Inserts an Int32LE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n    insertInt32LE(value, offset) {\n        this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n        return this;\n    }\n    // Unsigned Integers\n    /**\n       * Reads an UInt8 value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n    readUInt8(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);\n    }\n    /**\n       * Reads an UInt16BE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n    readUInt16BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);\n    }\n    /**\n       * Reads an UInt16LE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n    readUInt16LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);\n    }\n    /**\n       * Reads an UInt32BE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n    readUInt32BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);\n    }\n    /**\n       * Reads an UInt32LE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n    readUInt32LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);\n    }\n    /**\n       * Writes an UInt8 value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n    writeUInt8(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n        return this;\n    }\n    /**\n       * Inserts an UInt8 value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n    insertUInt8(value, offset) {\n        this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n        return this;\n    }\n    /**\n       * Writes an UInt16BE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n    writeUInt16BE(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n        return this;\n    }\n    /**\n       * Inserts an UInt16BE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n    insertUInt16BE(value, offset) {\n        this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n        return this;\n    }\n    /**\n       * Writes an UInt16LE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n    writeUInt16LE(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n        return this;\n    }\n    /**\n       * Inserts an UInt16LE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n    insertUInt16LE(value, offset) {\n        this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n        return this;\n    }\n    /**\n       * Writes an UInt32BE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n    writeUInt32BE(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n        return this;\n    }\n    /**\n       * Inserts an UInt32BE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n    insertUInt32BE(value, offset) {\n        this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n        return this;\n    }\n    /**\n       * Writes an UInt32LE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n    writeUInt32LE(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n        return this;\n    }\n    /**\n       * Inserts an UInt32LE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n    insertUInt32LE(value, offset) {\n        this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n        return this;\n    }\n    // Floating Point\n    /**\n       * Reads an FloatBE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n    readFloatBE(offset) {\n        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);\n    }\n    /**\n       * Reads an FloatLE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n    readFloatLE(offset) {\n        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);\n    }\n    /**\n       * Writes a FloatBE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n    writeFloatBE(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n        return this;\n    }\n    /**\n       * Inserts a FloatBE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n    insertFloatBE(value, offset) {\n        this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n        return this;\n    }\n    /**\n       * Writes a FloatLE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n    writeFloatLE(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n        return this;\n    }\n    /**\n       * Inserts a FloatLE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n    insertFloatLE(value, offset) {\n        this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n        return this;\n    }\n    // Double Floating Point\n    /**\n       * Reads an DoublEBE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n    readDoubleBE(offset) {\n        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);\n    }\n    /**\n       * Reads an DoubleLE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n    readDoubleLE(offset) {\n        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);\n    }\n    /**\n       * Writes a DoubleBE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n    writeDoubleBE(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n        return this;\n    }\n    /**\n       * Inserts a DoubleBE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n    insertDoubleBE(value, offset) {\n        this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n        return this;\n    }\n    /**\n       * Writes a DoubleLE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n    writeDoubleLE(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n        return this;\n    }\n    /**\n       * Inserts a DoubleLE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n    insertDoubleLE(value, offset) {\n        this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n        return this;\n    }\n    // Strings\n    /**\n       * Reads a String from the current read position.\n       *\n       * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for\n       *             the string (Defaults to instance level encoding).\n       * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n       *\n       * @return { String }\n       */\n    readString(arg1, encoding) {\n        let lengthVal;\n        // Length provided\n        if (typeof arg1 === 'number') {\n            utils_1.checkLengthValue(arg1);\n            lengthVal = Math.min(arg1, this.length - this._readOffset);\n        }\n        else {\n            encoding = arg1;\n            lengthVal = this.length - this._readOffset;\n        }\n        // Check encoding\n        if (typeof encoding !== 'undefined') {\n            utils_1.checkEncoding(encoding);\n        }\n        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);\n        this._readOffset += lengthVal;\n        return value;\n    }\n    /**\n       * Inserts a String\n       *\n       * @param value { String } The String value to insert.\n       * @param offset { Number } The offset to insert the string at.\n       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n       */\n    insertString(value, offset, encoding) {\n        utils_1.checkOffsetValue(offset);\n        return this._handleString(value, true, offset, encoding);\n    }\n    /**\n       * Writes a String\n       *\n       * @param value { String } The String value to write.\n       * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.\n       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n       */\n    writeString(value, arg2, encoding) {\n        return this._handleString(value, false, arg2, encoding);\n    }\n    /**\n       * Reads a null-terminated String from the current read position.\n       *\n       * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n       *\n       * @return { String }\n       */\n    readStringNT(encoding) {\n        if (typeof encoding !== 'undefined') {\n            utils_1.checkEncoding(encoding);\n        }\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for (let i = this._readOffset; i < this.length; i++) {\n            if (this._buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read string value\n        const value = this._buff.slice(this._readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this._readOffset = nullPos + 1;\n        return value.toString(encoding || this._encoding);\n    }\n    /**\n       * Inserts a null-terminated String.\n       *\n       * @param value { String } The String value to write.\n       * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n       */\n    insertStringNT(value, offset, encoding) {\n        utils_1.checkOffsetValue(offset);\n        // Write Values\n        this.insertString(value, offset, encoding);\n        this.insertUInt8(0x00, offset + value.length);\n    }\n    /**\n       * Writes a null-terminated String.\n       *\n       * @param value { String } The String value to write.\n       * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n       */\n    writeStringNT(value, arg2, encoding) {\n        // Write Values\n        this.writeString(value, arg2, encoding);\n        this.writeUInt8(0x00, typeof arg2 === 'number' ? arg2 + value.length : this.writeOffset);\n    }\n    // Buffers\n    /**\n       * Reads a Buffer from the internal read position.\n       *\n       * @param length { Number } The length of data to read as a Buffer.\n       *\n       * @return { Buffer }\n       */\n    readBuffer(length) {\n        if (typeof length !== 'undefined') {\n            utils_1.checkLengthValue(length);\n        }\n        const lengthVal = typeof length === 'number' ? length : this.length;\n        const endPoint = Math.min(this.length, this._readOffset + lengthVal);\n        // Read buffer value\n        const value = this._buff.slice(this._readOffset, endPoint);\n        // Increment internal Buffer read offset\n        this._readOffset = endPoint;\n        return value;\n    }\n    /**\n       * Writes a Buffer to the current write position.\n       *\n       * @param value { Buffer } The Buffer to write.\n       * @param offset { Number } The offset to write the Buffer to.\n       */\n    insertBuffer(value, offset) {\n        utils_1.checkOffsetValue(offset);\n        return this._handleBuffer(value, true, offset);\n    }\n    /**\n       * Writes a Buffer to the current write position.\n       *\n       * @param value { Buffer } The Buffer to write.\n       * @param offset { Number } The offset to write the Buffer to.\n       */\n    writeBuffer(value, offset) {\n        return this._handleBuffer(value, false, offset);\n    }\n    /**\n       * Reads a null-terminated Buffer from the current read poisiton.\n       *\n       * @return { Buffer }\n       */\n    readBufferNT() {\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for (let i = this._readOffset; i < this.length; i++) {\n            if (this._buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read value\n        const value = this._buff.slice(this._readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this._readOffset = nullPos + 1;\n        return value;\n    }\n    /**\n       * Inserts a null-terminated Buffer.\n       *\n       * @param value { Buffer } The Buffer to write.\n       * @param offset { Number } The offset to write the Buffer to.\n       */\n    insertBufferNT(value, offset) {\n        utils_1.checkOffsetValue(offset);\n        // Write Values\n        this.insertBuffer(value, offset);\n        this.insertUInt8(0x00, offset + value.length);\n        return this;\n    }\n    /**\n       * Writes a null-terminated Buffer.\n       *\n       * @param value { Buffer } The Buffer to write.\n       * @param offset { Number } The offset to write the Buffer to.\n       */\n    writeBufferNT(value, offset) {\n        // Checks for valid numberic value;\n        if (typeof offset !== 'undefined') {\n            utils_1.checkOffsetValue(offset);\n        }\n        // Write Values\n        this.writeBuffer(value, offset);\n        this.writeUInt8(0x00, typeof offset === 'number' ? offset + value.length : this._writeOffset);\n        return this;\n    }\n    /**\n       * Clears the SmartBuffer instance to its original empty state.\n       */\n    clear() {\n        this._writeOffset = 0;\n        this._readOffset = 0;\n        this.length = 0;\n        return this;\n    }\n    /**\n       * Gets the remaining data left to be read from the SmartBuffer instance.\n       *\n       * @return { Number }\n       */\n    remaining() {\n        return this.length - this._readOffset;\n    }\n    /**\n       * Gets the current read offset value of the SmartBuffer instance.\n       *\n       * @return { Number }\n       */\n    get readOffset() {\n        return this._readOffset;\n    }\n    /**\n       * Sets the read offset value of the SmartBuffer instance.\n       *\n       * @param offset { Number } - The offset value to set.\n       */\n    set readOffset(offset) {\n        utils_1.checkOffsetValue(offset);\n        // Check for bounds.\n        utils_1.checkTargetOffset(offset, this);\n        this._readOffset = offset;\n    }\n    /**\n       * Gets the current write offset value of the SmartBuffer instance.\n       *\n       * @return { Number }\n       */\n    get writeOffset() {\n        return this._writeOffset;\n    }\n    /**\n       * Sets the write offset value of the SmartBuffer instance.\n       *\n       * @param offset { Number } - The offset value to set.\n       */\n    set writeOffset(offset) {\n        utils_1.checkOffsetValue(offset);\n        // Check for bounds.\n        utils_1.checkTargetOffset(offset, this);\n        this._writeOffset = offset;\n    }\n    /**\n       * Gets the currently set string encoding of the SmartBuffer instance.\n       *\n       * @return { BufferEncoding } The string Buffer encoding currently set.\n       */\n    get encoding() {\n        return this._encoding;\n    }\n    /**\n       * Sets the string encoding of the SmartBuffer instance.\n       *\n       * @param encoding { BufferEncoding } The string Buffer encoding to set.\n       */\n    set encoding(encoding) {\n        utils_1.checkEncoding(encoding);\n        this._encoding = encoding;\n    }\n    /**\n       * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)\n       *\n       * @return { Buffer } The Buffer value.\n       */\n    get internalBuffer() {\n        return this._buff;\n    }\n    /**\n       * Gets the value of the internal managed Buffer (Includes managed data only)\n       *\n       * @param { Buffer }\n       */\n    toBuffer() {\n        return this._buff.slice(0, this.length);\n    }\n    /**\n       * Gets the String value of the internal managed Buffer\n       *\n       * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).\n       */\n    toString(encoding) {\n        const encodingVal = typeof encoding === 'string' ? encoding : this._encoding;\n        // Check for invalid encoding.\n        utils_1.checkEncoding(encodingVal);\n        return this._buff.toString(encodingVal, 0, this.length);\n    }\n    /**\n       * Destroys the SmartBuffer instance.\n       */\n    destroy() {\n        this.clear();\n        return this;\n    }\n    /**\n       * Handles inserting and writing strings.\n       *\n       * @param value { String } The String value to insert.\n       * @param isInsert { Boolean } True if inserting a string, false if writing.\n       * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.\n       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n       */\n    _handleString(value, isInsert, arg3, encoding) {\n        let offsetVal = this._writeOffset;\n        let encodingVal = this._encoding;\n        // Check for offset\n        if (typeof arg3 === 'number') {\n            offsetVal = arg3;\n            // Check for encoding\n        }\n        else if (typeof arg3 === 'string') {\n            utils_1.checkEncoding(arg3);\n            encodingVal = arg3;\n        }\n        // Check for encoding (third param)\n        if (typeof encoding === 'string') {\n            utils_1.checkEncoding(encoding);\n            encodingVal = encoding;\n        }\n        // Calculate bytelength of string.\n        const byteLength = Buffer.byteLength(value, encodingVal);\n        // Ensure there is enough internal Buffer capacity.\n        if (isInsert) {\n            this.ensureInsertable(byteLength, offsetVal);\n        }\n        else {\n            this._ensureWriteable(byteLength, offsetVal);\n        }\n        // Write value\n        this._buff.write(value, offsetVal, byteLength, encodingVal);\n        // Increment internal Buffer write offset;\n        if (isInsert) {\n            this._writeOffset += byteLength;\n        }\n        else {\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\n            if (typeof arg3 === 'number') {\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);\n            }\n            else {\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n                this._writeOffset += byteLength;\n            }\n        }\n        return this;\n    }\n    /**\n       * Handles writing or insert of a Buffer.\n       *\n       * @param value { Buffer } The Buffer to write.\n       * @param offset { Number } The offset to write the Buffer to.\n       */\n    _handleBuffer(value, isInsert, offset) {\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure there is enough internal Buffer capacity.\n        if (isInsert) {\n            this.ensureInsertable(value.length, offsetVal);\n        }\n        else {\n            this._ensureWriteable(value.length, offsetVal);\n        }\n        // Write buffer value\n        value.copy(this._buff, offsetVal);\n        // Increment internal Buffer write offset;\n        if (isInsert) {\n            this._writeOffset += value.length;\n        }\n        else {\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\n            if (typeof offset === 'number') {\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);\n            }\n            else {\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n                this._writeOffset += value.length;\n            }\n        }\n        return this;\n    }\n    /**\n       * Ensures that the internal Buffer is large enough to read data.\n       *\n       * @param length { Number } The length of the data that needs to be read.\n       * @param offset { Number } The offset of the data that needs to be read.\n       */\n    ensureReadable(length, offset) {\n        // Offset value defaults to managed read offset.\n        let offsetVal = this._readOffset;\n        // If an offset was provided, use it.\n        if (typeof offset !== 'undefined') {\n            // Checks for valid numberic value;\n            utils_1.checkOffsetValue(offset);\n            // Overide with custom offset.\n            offsetVal = offset;\n        }\n        // Checks if offset is below zero, or the offset+length offset is beyond the total length of the managed data.\n        if (offsetVal < 0 || offsetVal + length > this.length) {\n            throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);\n        }\n    }\n    /**\n       * Ensures that the internal Buffer is large enough to insert data.\n       *\n       * @param dataLength { Number } The length of the data that needs to be written.\n       * @param offset { Number } The offset of the data to be written.\n       */\n    ensureInsertable(dataLength, offset) {\n        // Checks for valid numberic value;\n        utils_1.checkOffsetValue(offset);\n        // Ensure there is enough internal Buffer capacity.\n        this._ensureCapacity(this.length + dataLength);\n        // If an offset was provided and its not the very end of the buffer, copy data into appropriate location in regards to the offset.\n        if (offset < this.length) {\n            this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);\n        }\n        // Adjust tracked smart buffer length\n        if (offset + dataLength > this.length) {\n            this.length = offset + dataLength;\n        }\n        else {\n            this.length += dataLength;\n        }\n    }\n    /**\n       * Ensures that the internal Buffer is large enough to write data.\n       *\n       * @param dataLength { Number } The length of the data that needs to be written.\n       * @param offset { Number } The offset of the data to be written (defaults to writeOffset).\n       */\n    _ensureWriteable(dataLength, offset) {\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure enough capacity to write data.\n        this._ensureCapacity(offsetVal + dataLength);\n        // Adjust SmartBuffer length (if offset + length is larger than managed length, adjust length)\n        if (offsetVal + dataLength > this.length) {\n            this.length = offsetVal + dataLength;\n        }\n    }\n    /**\n       * Ensures that the internal Buffer is large enough to write at least the given amount of data.\n       *\n       * @param minLength { Number } The minimum length of the data needs to be written.\n       */\n    _ensureCapacity(minLength) {\n        const oldLength = this._buff.length;\n        if (minLength > oldLength) {\n            let data = this._buff;\n            let newLength = oldLength * 3 / 2 + 1;\n            if (newLength < minLength) {\n                newLength = minLength;\n            }\n            this._buff = Buffer.allocUnsafe(newLength);\n            data.copy(this._buff, 0, 0, oldLength);\n        }\n    }\n    /**\n       * Reads a numeric number value using the provided function.\n       *\n       * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.\n       * @param byteSize { Number } The number of bytes read.\n       * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.\n       *\n       * @param { Number }\n       */\n    _readNumberValue(func, byteSize, offset) {\n        this.ensureReadable(byteSize, offset);\n        // Call Buffer.readXXXX();\n        const value = func.call(this._buff, typeof offset === 'number' ? offset : this._readOffset);\n        // Adjust internal read offset if an optional read offset was not provided.\n        if (typeof offset === 'undefined') {\n            this._readOffset += byteSize;\n        }\n        return value;\n    }\n    /**\n       * Inserts a numeric number value based on the given offset and value.\n       *\n       * @param func { Function(offset: number, offset?) => number} The function to write data on the internal Buffer with.\n       * @param byteSize { Number } The number of bytes written.\n       * @param value { Number } The number value to write.\n       * @param offset { Number } the offset to write the number at (REQUIRED).\n       *\n       */\n    _insertNumberValue(func, byteSize, value, offset) {\n        // Check for invalid offset values.\n        utils_1.checkOffsetValue(offset);\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this.ensureInsertable(byteSize, offset);\n        // Call buffer.writeXXXX();\n        func.call(this._buff, value, offset);\n        // Adjusts internally managed write offset.\n        this._writeOffset += byteSize;\n    }\n    /**\n       * Writes a numeric number value based on the given offset and value.\n       *\n       * @param func { Function(offset: number, offset?) => number} The function to write data on the internal Buffer with.\n       * @param byteSize { Number } The number of bytes written.\n       * @param value { Number } The number value to write.\n       * @param offset { Number } the offset to write the number at (REQUIRED).\n       *\n       */\n    _writeNumberValue(func, byteSize, value, offset) {\n        // If an offset was provided, validate it.\n        if (typeof offset === 'number') {\n            // Check if we're writing beyond the bounds of the managed data.\n            if (offset < 0) {\n                throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);\n            }\n            utils_1.checkOffsetValue(offset);\n        }\n        // Default to writeOffset if no offset value was given.\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this._ensureWriteable(byteSize, offsetVal);\n        func.call(this._buff, value, offsetVal);\n        // If an offset was given, check to see if we wrote beyond the current writeOffset.\n        if (typeof offset === 'number') {\n            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);\n        }\n        else {\n            // If no numeric offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n            this._writeOffset += byteSize;\n        }\n    }\n}\nexports.SmartBuffer = SmartBuffer;\n//# sourceMappingURL=smartbuffer.js.map"]}