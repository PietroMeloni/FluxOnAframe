'use strict';

var _templateObject = _taggedTemplateLiteral(['Unable to guess a binary name from ', '. Please use --package.'], ['Unable to guess a binary name from ', '. Please use --package.']),
    _templateObject2 = _taggedTemplateLiteral(['options'], ['options']),
    _templateObject3 = _taggedTemplateLiteral(['command'], ['command']),
    _templateObject4 = _taggedTemplateLiteral(['version'], ['version']),
    _templateObject5 = _taggedTemplateLiteral(['command-arg'], ['command-arg']),
    _templateObject6 = _taggedTemplateLiteral(['package'], ['package']),
    _templateObject7 = _taggedTemplateLiteral(['command-string'], ['command-string']),
    _templateObject8 = _taggedTemplateLiteral(['shell'], ['shell']),
    _templateObject9 = _taggedTemplateLiteral(['Execute binaries from npm packages.\n', ''], ['Execute binaries from npm packages.\\n', '']),
    _templateObject10 = _taggedTemplateLiteral(['Package to be installed.'], ['Package to be installed.']),
    _templateObject11 = _taggedTemplateLiteral(['Location of the npm cache.'], ['Location of the npm cache.']),
    _templateObject12 = _taggedTemplateLiteral(['Always spawn a child process to execute the command.'], ['Always spawn a child process to execute the command.']),
    _templateObject13 = _taggedTemplateLiteral(['Skip installation if a package is missing.'], ['Skip installation if a package is missing.']),
    _templateObject14 = _taggedTemplateLiteral(['Path to user npmrc.'], ['Path to user npmrc.']),
    _templateObject15 = _taggedTemplateLiteral(['Execute string as if inside `npm run-script`.'], ['Execute string as if inside \\`npm run-script\\`.']),
    _templateObject16 = _taggedTemplateLiteral(['Shell to execute the command with, if any.'], ['Shell to execute the command with, if any.']),
    _templateObject17 = _taggedTemplateLiteral(['Generate shell code to use npx as the "command not found" fallback.'], ['Generate shell code to use npx as the "command not found" fallback.']),
    _templateObject18 = _taggedTemplateLiteral(['Ignores existing binaries in $PATH, or in the local project. This forces npx to do a temporary install and use the latest version.'], ['Ignores existing binaries in $PATH, or in the local project. This forces npx to do a temporary install and use the latest version.']),
    _templateObject19 = _taggedTemplateLiteral(['Suppress output from npx itself. Subcommands will not be affected.'], ['Suppress output from npx itself. Subcommands will not be affected.']),
    _templateObject20 = _taggedTemplateLiteral(['npm binary to use for internal operations.'], ['npm binary to use for internal operations.']),
    _templateObject21 = _taggedTemplateLiteral(['Extra node argument when calling a node binary.'], ['Extra node argument when calling a node binary.']),
    _templateObject22 = _taggedTemplateLiteral(['For the full documentation, see the manual page for npx(1).'], ['For the full documentation, see the manual page for npx(1).']);

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var npa = void 0;
var path = require('path');

module.exports = parseArgs;
function parseArgs(argv, defaultNpm) {
  argv = argv || process.argv;
  if (argv.length > 2 && argv[2][0] !== '-') {
    // fast-path around arg parsing! Don't even need to load yargs here.
    return fastPathArgs(argv, defaultNpm);
  }

  npa = require('npm-package-arg');

  var parser = yargsParser(argv, defaultNpm);

  var opts = parser.getOptions();
  var bools = new Set(opts.boolean);

  var cmdIndex = void 0;
  var hasDashDash = void 0;
  for (var i = 2; i < argv.length; i++) {
    var opt = argv[i];
    if (opt === '--') {
      hasDashDash = true;
      break;
    } else if (opt === '--node-arg' || opt === '-n') {
      argv[i] = opt + '=' + argv[i + 1];
      argv.splice(i + 1, 1);
    } else if (opt[0] === '-') {
      if (
      // --no-install needs to be special-cased because we're abusing
      // yargs a bit in order to get the --help text right.
      opt !== '--no-install' && !bools.has(opt.replace(/^--?(no-)?/i, '')) && opt.indexOf('=') === -1) {
        i++;
      }
    } else {
      cmdIndex = i;
      break;
    }
  }
  if (cmdIndex) {
    var parsed = parser.parse(argv.slice(0, cmdIndex));
    var parsedCmd = npa(argv[cmdIndex]);
    parsed.command = parsed.package && parsedCmd.type !== 'directory' ? argv[cmdIndex] : guessCmdName(parsedCmd);
    parsed.isLocal = parsedCmd.type === 'directory';
    parsed.cmdOpts = argv.slice(cmdIndex + 1);
    if (typeof parsed.package === 'string') {
      parsed.package = [parsed.package];
    }
    parsed.packageRequested = !!parsed.package;
    parsed.cmdHadVersion = parsed.package || parsedCmd.type === 'directory' ? false : parsedCmd.name !== parsedCmd.raw;
    var pkg = parsed.package || [argv[cmdIndex]];
    parsed.p = parsed.package = pkg.map(function (p) {
      return npa(p).toString();
    });
    return parsed;
  } else {
    var _parsed = parser.parse(argv);
    if (typeof _parsed.package === 'string') {
      _parsed.package = [_parsed.package];
    }
    // -c *requires* -p, because the -c string should not be touched by npx
    if (_parsed.call && _parsed.package) {
      _parsed.packageRequested = !!_parsed.package;
      _parsed.cmdHadVersion = false;
      var _pkg = _parsed.package;
      _parsed.p = _parsed.package = _pkg.map(function (p) {
        return npa(p).toString();
      });
    } else if (_parsed.call && !_parsed.package) {
      _parsed.packageRequested = false;
      _parsed.cmdHadVersion = false;
      _parsed.p = _parsed.package = [];
    } else if (hasDashDash) {
      var splitCmd = _parsed._.slice(2);
      var _parsedCmd = npa(splitCmd[0]);
      _parsed.command = _parsed.package ? splitCmd[0] : guessCmdName(_parsedCmd);
      _parsed.cmdOpts = splitCmd.slice(1);
      _parsed.packageRequested = !!_parsed.package;
      _parsed.cmdHadVersion = _parsed.package ? false : _parsedCmd.name !== _parsedCmd.raw;
      var _pkg2 = _parsed.package || [splitCmd[0]];
      _parsed.p = _parsed.package = _pkg2.map(function (p) {
        return npa(p).toString();
      });
    }
    return _parsed;
  }
}

function fastPathArgs(argv, defaultNpm) {
  var parsedCmd = void 0;
  var pkg = void 0;
  if (argv[2].match(/^[a-z0-9_-]+$/i)) {
    parsedCmd = { registry: true, name: argv[2], raw: argv[2] };
    pkg = [argv[2] + '@latest'];
  } else {
    npa = require('npm-package-arg');
    parsedCmd = npa(argv[2]);
    if (parsedCmd.type === 'directory') {
      pkg = [];
    } else {
      pkg = [parsedCmd.toString()];
    }
  }
  return {
    command: guessCmdName(parsedCmd),
    cmdOpts: argv.slice(3),
    packageRequested: false,
    isLocal: parsedCmd.type === 'directory',
    cmdHadVersion: parsedCmd.name !== parsedCmd.raw && parsedCmd.type !== 'directory',
    package: pkg,
    p: pkg,
    shell: false,
    noYargs: true,
    npm: defaultNpm || 'npm'
  };
}

parseArgs.showHelp = function () {
  return require('yargs').showHelp();
};

module.exports._guessCmdName = guessCmdName;
function guessCmdName(spec) {
  if (typeof spec === 'string') {
    if (!npa) {
      npa = require('npm-package-arg');
    }
    spec = npa(spec);
  }
  if (spec.scope) {
    return spec.name.slice(spec.scope.length + 1);
  } else if (spec.registry) {
    return spec.name;
  } else if (spec.hosted && spec.hosted.project) {
    return spec.hosted.project;
  } else if (spec.type === 'git') {
    var match = spec.fetchSpec.match(/([a-z0-9-]+)(?:\.git)?$/i);
    return match[1];
  } else if (spec.type === 'directory') {
    return spec.raw;
  } else if (spec.type === 'file' || spec.type === 'remote') {
    var ext = path.extname(spec.fetchSpec);
    if (ext === '.gz') {
      ext = path.extname(path.basename(spec.fetchSpec, ext)) + ext;
    }
    return path.basename(spec.fetchSpec, ext).replace(/-\d+\.\d+\.\d+(?:-[a-z0-9.\-+]+)?$/i, '');
  }

  console.error(Y()(_templateObject, spec.raw));
  return null;
}

function yargsParser(argv, defaultNpm) {
  var usage = '\n  npx [' + Y()(_templateObject2) + '] <' + Y()(_templateObject3) + '>[@' + Y()(_templateObject4) + '] [' + Y()(_templateObject5) + ']...\n\n  npx [' + Y()(_templateObject2) + '] [-p|--package <' + Y()(_templateObject6) + '>]... <' + Y()(_templateObject3) + '> [' + Y()(_templateObject5) + ']...\n\n  npx [' + Y()(_templateObject2) + '] -c \'<' + Y()(_templateObject7) + '>\'\n\n  npx --shell-auto-fallback [' + Y()(_templateObject8) + ']\n  ';

  return require('yargs').usage(Y()(_templateObject9, usage)).option('package', {
    alias: 'p',
    type: 'string',
    describe: Y()(_templateObject10)
  }).option('cache', {
    type: 'string',
    describe: Y()(_templateObject11)
  }).option('always-spawn', {
    describe: Y()(_templateObject12),
    type: 'boolean'
  }).option('no-install', {
    type: 'boolean',
    describe: Y()(_templateObject13)
  }).option('userconfig', {
    type: 'string',
    describe: Y()(_templateObject14)
  }).option('call', {
    alias: 'c',
    type: 'string',
    describe: Y()(_templateObject15)
  }).option('shell', {
    alias: 's',
    type: 'string',
    describe: Y()(_templateObject16),
    default: false
  }).option('shell-auto-fallback', {
    choices: ['', 'bash', 'fish', 'zsh'],
    describe: Y()(_templateObject17),
    requireArg: false,
    type: 'string'
  }).option('ignore-existing', {
    describe: Y()(_templateObject18),
    type: 'boolean'
  }).option('quiet', {
    alias: 'q',
    describe: Y()(_templateObject19),
    type: 'boolean'
  }).option('npm', {
    describe: Y()(_templateObject20),
    type: 'string',
    default: defaultNpm || 'npm'
  }).option('node-arg', {
    alias: 'n',
    type: 'string',
    describe: Y()(_templateObject21)
  }).version().alias('version', 'v').help().alias('help', 'h').epilogue(Y()(_templateObject22));
}

var _y;
function Y() {
  if (!_y) {
    _y = require('./y.js');
  }
  return _y;
}
//# sourceMappingURL=parse-args.js.map