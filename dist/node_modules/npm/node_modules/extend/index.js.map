{"version":3,"sources":["../../../../../node_modules/npm/node_modules/extend/index.js"],"names":["hasOwn","Object","prototype","hasOwnProperty","toStr","toString","isArray","arr","Array","call","isPlainObject","obj","hasOwnConstructor","hasIsPrototypeOf","constructor","key","module","exports","extend","options","name","src","copy","copyIsArray","clone","target","arguments","i","length","deep"],"mappings":"AAAA;;;;AAEA,IAAIA,SAASC,OAAOC,SAAP,CAAiBC,cAA9B;AACA,IAAIC,QAAQH,OAAOC,SAAP,CAAiBG,QAA7B;;AAEA,IAAIC,UAAU,SAASA,OAAT,CAAiBC,GAAjB,EAAsB;AACnC,KAAI,OAAOC,MAAMF,OAAb,KAAyB,UAA7B,EAAyC;AACxC,SAAOE,MAAMF,OAAN,CAAcC,GAAd,CAAP;AACA;;AAED,QAAOH,MAAMK,IAAN,CAAWF,GAAX,MAAoB,gBAA3B;AACA,CAND;;AAQA,IAAIG,gBAAgB,SAASA,aAAT,CAAuBC,GAAvB,EAA4B;AAC/C,KAAI,CAACA,GAAD,IAAQP,MAAMK,IAAN,CAAWE,GAAX,MAAoB,iBAAhC,EAAmD;AAClD,SAAO,KAAP;AACA;;AAED,KAAIC,oBAAoBZ,OAAOS,IAAP,CAAYE,GAAZ,EAAiB,aAAjB,CAAxB;AACA,KAAIE,mBAAmBF,IAAIG,WAAJ,IAAmBH,IAAIG,WAAJ,CAAgBZ,SAAnC,IAAgDF,OAAOS,IAAP,CAAYE,IAAIG,WAAJ,CAAgBZ,SAA5B,EAAuC,eAAvC,CAAvE;AACA;AACA,KAAIS,IAAIG,WAAJ,IAAmB,CAACF,iBAApB,IAAyC,CAACC,gBAA9C,EAAgE;AAC/D,SAAO,KAAP;AACA;;AAED;AACA;AACA,KAAIE,GAAJ;AACA,MAAKA,GAAL,IAAYJ,GAAZ,EAAiB,CAAE,IAAM;;AAEzB,QAAO,OAAOI,GAAP,KAAe,WAAf,IAA8Bf,OAAOS,IAAP,CAAYE,GAAZ,EAAiBI,GAAjB,CAArC;AACA,CAlBD;;AAoBAC,OAAOC,OAAP,GAAiB,SAASC,MAAT,GAAkB;AAClC,KAAIC,OAAJ,EAAaC,IAAb,EAAmBC,GAAnB,EAAwBC,IAAxB,EAA8BC,WAA9B,EAA2CC,KAA3C;AACA,KAAIC,SAASC,UAAU,CAAV,CAAb;AACA,KAAIC,IAAI,CAAR;AACA,KAAIC,SAASF,UAAUE,MAAvB;AACA,KAAIC,OAAO,KAAX;;AAEA;AACA,KAAI,OAAOJ,MAAP,KAAkB,SAAtB,EAAiC;AAChCI,SAAOJ,MAAP;AACAA,WAASC,UAAU,CAAV,KAAgB,EAAzB;AACA;AACAC,MAAI,CAAJ;AACA;AACD,KAAIF,UAAU,IAAV,IAAmB,QAAOA,MAAP,yCAAOA,MAAP,OAAkB,QAAlB,IAA8B,OAAOA,MAAP,KAAkB,UAAvE,EAAoF;AACnFA,WAAS,EAAT;AACA;;AAED,QAAOE,IAAIC,MAAX,EAAmB,EAAED,CAArB,EAAwB;AACvBR,YAAUO,UAAUC,CAAV,CAAV;AACA;AACA,MAAIR,WAAW,IAAf,EAAqB;AACpB;AACA,QAAKC,IAAL,IAAaD,OAAb,EAAsB;AACrBE,UAAMI,OAAOL,IAAP,CAAN;AACAE,WAAOH,QAAQC,IAAR,CAAP;;AAEA;AACA,QAAIK,WAAWH,IAAf,EAAqB;AACpB;AACA,SAAIO,QAAQP,IAAR,KAAiBZ,cAAcY,IAAd,MAAwBC,cAAcjB,QAAQgB,IAAR,CAAtC,CAAjB,CAAJ,EAA4E;AAC3E,UAAIC,WAAJ,EAAiB;AAChBA,qBAAc,KAAd;AACAC,eAAQH,OAAOf,QAAQe,GAAR,CAAP,GAAsBA,GAAtB,GAA4B,EAApC;AACA,OAHD,MAGO;AACNG,eAAQH,OAAOX,cAAcW,GAAd,CAAP,GAA4BA,GAA5B,GAAkC,EAA1C;AACA;;AAED;AACAI,aAAOL,IAAP,IAAeF,OAAOW,IAAP,EAAaL,KAAb,EAAoBF,IAApB,CAAf;;AAED;AACC,MAZD,MAYO,IAAI,OAAOA,IAAP,KAAgB,WAApB,EAAiC;AACvCG,aAAOL,IAAP,IAAeE,IAAf;AACA;AACD;AACD;AACD;AACD;;AAED;AACA,QAAOG,MAAP;AACA,CApDD","file":"index.js","sourcesContent":["'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = target[name];\n\t\t\t\tcopy = options[name];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n"]}