{"version":3,"sources":["../../../../../node_modules/npm/node_modules/minizlib/index.js"],"names":["assert","require","Buffer","binding","process","constants","exports","MiniPass","ZlibError","msg","errno","code","codes","get","Error","Map","Z_OK","Z_STREAM_END","Z_NEED_DICT","Z_ERRNO","Z_STREAM_ERROR","Z_DATA_ERROR","Z_MEM_ERROR","Z_BUF_ERROR","Z_VERSION_ERROR","validFlushFlags","Set","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_SYNC_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","strategies","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","_opts","Symbol","_chunkSize","_flushFlag","_finishFlush","_handle","_hadError","_buffer","_offset","_level","_strategy","_ended","_writeState","Zlib","opts","mode","chunkSize","Z_DEFAULT_CHUNK","flush","has","TypeError","finishFlush","Z_MIN_CHUNK","RangeError","windowBits","Z_MIN_WINDOWBITS","Z_MAX_WINDOWBITS","level","Z_MIN_LEVEL","Z_MAX_LEVEL","memLevel","Z_MIN_MEMLEVEL","Z_MAX_MEMLEVEL","strategy","dictionary","onerror","message","close","error","emit","Z_DEFAULT_COMPRESSION","Uint32Array","window","Z_DEFAULT_WINDOWBITS","Z_DEFAULT_MEMLEVEL","test","version","init","allocUnsafe","once","params","reset","kind","undefined","ended","flushFlag","write","alloc","chunk","encoding","cb","availInBefore","length","availOutBefore","inOff","writeReturn","res","writeSync","availInAfter","availOutAfter","have","out","slice","Deflate","DEFLATE","Inflate","INFLATE","Gzip","GZIP","Gunzip","GUNZIP","DeflateRaw","DEFLATERAW","InflateRaw","INFLATERAW","Unzip","UNZIP"],"mappings":"AAAA;;;;;;;;;;;;AAEA,IAAMA,SAASC,QAAQ,QAAR,CAAf;AACA,IAAMC,SAASD,QAAQ,QAAR,EAAkBC,MAAjC;AACA,IAAMC,UAAUC,QAAQD,OAAR,CAAgB,MAAhB,CAAhB;;AAEA,IAAME,YAAYC,QAAQD,SAAR,GAAoBJ,QAAQ,gBAAR,CAAtC;AACA,IAAMM,WAAWN,QAAQ,UAAR,CAAjB;;IAEMO,S;;;AACJ,qBAAaC,GAAb,EAAkBC,KAAlB,EAAyB;AAAA;;AAAA,sHACjB,WAAWD,GADM;;AAEvB,UAAKC,KAAL,GAAaA,KAAb;AACA,UAAKC,IAAL,GAAYC,MAAMC,GAAN,CAAUH,KAAV,CAAZ;AAHuB;AAIxB;;;;wBAEW;AACV,aAAO,WAAP;AACD;;;;EATqBI,K;;AAYxB;;;AACA,IAAMF,QAAQ,IAAIG,GAAJ,CAAQ,CACpB,CAACV,UAAUW,IAAX,EAAiB,MAAjB,CADoB,EAEpB,CAACX,UAAUY,YAAX,EAAyB,cAAzB,CAFoB,EAGpB,CAACZ,UAAUa,WAAX,EAAwB,aAAxB,CAHoB,EAIpB,CAACb,UAAUc,OAAX,EAAoB,SAApB,CAJoB,EAKpB,CAACd,UAAUe,cAAX,EAA2B,gBAA3B,CALoB,EAMpB,CAACf,UAAUgB,YAAX,EAAyB,cAAzB,CANoB,EAOpB,CAAChB,UAAUiB,WAAX,EAAwB,aAAxB,CAPoB,EAQpB,CAACjB,UAAUkB,WAAX,EAAwB,aAAxB,CARoB,EASpB,CAAClB,UAAUmB,eAAX,EAA4B,iBAA5B,CAToB,CAAR,CAAd;;AAYA,IAAMC,kBAAkB,IAAIC,GAAJ,CAAQ,CAC9BrB,UAAUsB,UADoB,EAE9BtB,UAAUuB,eAFoB,EAG9BvB,UAAUwB,YAHoB,EAI9BxB,UAAUyB,YAJoB,EAK9BzB,UAAU0B,QALoB,EAM9B1B,UAAU2B,OANoB,CAAR,CAAxB;;AASA,IAAMC,aAAa,IAAIP,GAAJ,CAAQ,CACzBrB,UAAU6B,UADe,EAEzB7B,UAAU8B,cAFe,EAGzB9B,UAAU+B,KAHe,EAIzB/B,UAAUgC,OAJe,EAKzBhC,UAAUiC,kBALe,CAAR,CAAnB;;AAQA;AACA;AACA;AACA;AACA,IAAMC,QAAQC,OAAO,MAAP,CAAd;AACA,IAAMC,aAAaD,OAAO,WAAP,CAAnB;AACA,IAAME,aAAaF,OAAO,WAAP,CAAnB;AACA,IAAMG,eAAeH,OAAO,aAAP,CAArB;AACA,IAAMI,UAAUJ,OAAO,QAAP,CAAhB;AACA,IAAMK,YAAYL,OAAO,UAAP,CAAlB;AACA,IAAMM,UAAUN,OAAO,QAAP,CAAhB;AACA,IAAMO,UAAUP,OAAO,QAAP,CAAhB;AACA,IAAMQ,SAASR,OAAO,OAAP,CAAf;AACA,IAAMS,YAAYT,OAAO,UAAP,CAAlB;AACA,IAAMU,SAASV,OAAO,OAAP,CAAf;AACA,IAAMW,cAAcX,OAAO,YAAP,CAApB;;IAEMY,I;;;AACJ,gBAAaC,IAAb,EAAmBC,IAAnB,EAAyB;AAAA;;AAAA,6GACjBD,IADiB;;AAEvB,WAAKH,MAAL,IAAe,KAAf;AACA,WAAKX,KAAL,IAAcc,OAAOA,QAAQ,EAA7B;AACA,WAAKZ,UAAL,IAAmBY,KAAKE,SAAL,IAAkBlD,UAAUmD,eAA/C;AACA,QAAIH,KAAKI,KAAL,IAAc,CAAChC,gBAAgBiC,GAAhB,CAAoBL,KAAKI,KAAzB,CAAnB,EAAoD;AAClD,YAAM,IAAIE,SAAJ,CAAc,yBAAyBN,KAAKI,KAA5C,CAAN;AACD;AACD,QAAIJ,KAAKO,WAAL,IAAoB,CAACnC,gBAAgBiC,GAAhB,CAAoBL,KAAKO,WAAzB,CAAzB,EAAgE;AAC9D,YAAM,IAAID,SAAJ,CAAc,yBAAyBN,KAAKO,WAA5C,CAAN;AACD;;AAED,WAAKlB,UAAL,IAAmBW,KAAKI,KAAL,IAAcpD,UAAUsB,UAA3C;AACA,WAAKgB,YAAL,IAAqB,OAAOU,KAAKO,WAAZ,KAA4B,WAA5B,GACnBP,KAAKO,WADc,GACAvD,UAAU0B,QAD/B;;AAGA,QAAIsB,KAAKE,SAAT,EAAoB;AAClB,UAAIF,KAAKE,SAAL,GAAiBlD,UAAUwD,WAA/B,EAA4C;AAC1C,cAAM,IAAIC,UAAJ,CAAe,yBAAyBT,KAAKE,SAA7C,CAAN;AACD;AACF;;AAED,QAAIF,KAAKU,UAAT,EAAqB;AACnB,UAAIV,KAAKU,UAAL,GAAkB1D,UAAU2D,gBAA5B,IACAX,KAAKU,UAAL,GAAkB1D,UAAU4D,gBADhC,EACkD;AAChD,cAAM,IAAIH,UAAJ,CAAe,yBAAyBT,KAAKU,UAA7C,CAAN;AACD;AACF;;AAED,QAAIV,KAAKa,KAAT,EAAgB;AACd,UAAIb,KAAKa,KAAL,GAAa7D,UAAU8D,WAAvB,IACAd,KAAKa,KAAL,GAAa7D,UAAU+D,WAD3B,EACwC;AACtC,cAAM,IAAIN,UAAJ,CAAe,gCAAgCT,KAAKa,KAApD,CAAN;AACD;AACF;;AAED,QAAIb,KAAKgB,QAAT,EAAmB;AACjB,UAAIhB,KAAKgB,QAAL,GAAgBhE,UAAUiE,cAA1B,IACAjB,KAAKgB,QAAL,GAAgBhE,UAAUkE,cAD9B,EAC8C;AAC5C,cAAM,IAAIT,UAAJ,CAAe,uBAAuBT,KAAKgB,QAA3C,CAAN;AACD;AACF;;AAED,QAAIhB,KAAKmB,QAAL,IAAiB,CAAEvC,WAAWyB,GAAX,CAAeL,KAAKmB,QAApB,CAAvB,EACE,MAAM,IAAIb,SAAJ,CAAc,uBAAuBN,KAAKmB,QAA1C,CAAN;;AAEF,QAAInB,KAAKoB,UAAT,EAAqB;AACnB,UAAI,EAAEpB,KAAKoB,UAAL,YAA2BvE,MAA7B,CAAJ,EAA0C;AACxC,cAAM,IAAIyD,SAAJ,CAAc,oDAAd,CAAN;AACD;AACF;;AAED,WAAKf,OAAL,IAAgB,IAAIzC,QAAQiD,IAAZ,CAAiBE,IAAjB,CAAhB;;AAEA,WAAKT,SAAL,IAAkB,KAAlB;AACA,WAAKD,OAAL,EAAc8B,OAAd,GAAwB,UAACC,OAAD,EAAUjE,KAAV,EAAoB;AAC1C;AACA;AACA,aAAKkE,KAAL;AACA,aAAK/B,SAAL,IAAkB,IAAlB;;AAEA,UAAMgC,QAAQ,IAAIrE,SAAJ,CAAcmE,OAAd,EAAuBjE,KAAvB,CAAd;AACA,aAAKoE,IAAL,CAAU,OAAV,EAAmBD,KAAnB;AACD,KARD;;AAUA,QAAMX,QAAQ,OAAOb,KAAKa,KAAZ,KAAsB,QAAtB,GAAiCb,KAAKa,KAAtC,GACA7D,UAAU0E,qBADxB;;AAGA,QAAIP,WAAW,OAAOnB,KAAKmB,QAAZ,KAAyB,QAAzB,GAAoCnB,KAAKmB,QAAzC,GACAnE,UAAUiC,kBADzB;;AAGA,WAAKa,WAAL,IAAoB,IAAI6B,WAAJ,CAAgB,CAAhB,CAApB;AACA,QAAMC,SAAS5B,KAAKU,UAAL,IAAmB1D,UAAU6E,oBAA5C;AACA,QAAMb,WAAWhB,KAAKgB,QAAL,IAAiBhE,UAAU8E,kBAA5C;;AAEA;AACA;AACA,QAAI,YAAYC,IAAZ,CAAiBhF,QAAQiF,OAAzB,CAAJ,EAAuC;AACrC,aAAKzC,OAAL,EAAc0C,IAAd,CAAmBL,MAAnB,EACmBf,KADnB,EAEmBG,QAFnB,EAGmBG,QAHnB,EAImBnB,KAAKoB,UAJxB;AAKD,KAND,MAMO;AACL,aAAK7B,OAAL,EAAc0C,IAAd,CAAmBL,MAAnB,EACmBf,KADnB,EAEmBG,QAFnB,EAGmBG,QAHnB,EAImB,OAAKrB,WAAL,CAJnB,EAKmB,YAAM,CAAE,CAL3B,EAMmBE,KAAKoB,UANxB;AAOD;;AAED,WAAK3B,OAAL,IAAgB5C,OAAOqF,WAAP,CAAmB,OAAK9C,UAAL,CAAnB,CAAhB;AACA,WAAKM,OAAL,IAAgB,CAAhB;AACA,WAAKC,MAAL,IAAekB,KAAf;AACA,WAAKjB,SAAL,IAAkBuB,QAAlB;;AAEA,WAAKgB,IAAL,CAAU,KAAV,EAAiB,OAAKZ,KAAtB;AAlGuB;AAmGxB;;;;4BAEQ;AACP,UAAI,KAAKhC,OAAL,CAAJ,EAAmB;AACjB,aAAKA,OAAL,EAAcgC,KAAd;AACA,aAAKhC,OAAL,IAAgB,IAAhB;AACA,aAAKkC,IAAL,CAAU,OAAV;AACD;AACF;;;2BAEOZ,K,EAAOM,Q,EAAU;AACvB,UAAI,CAAC,KAAK5B,OAAL,CAAL,EACE,MAAM,IAAI9B,KAAJ,CAAU,6CAAV,CAAN;;AAEF;AACA;AACA,UAAI,CAAC,KAAK8B,OAAL,EAAc6C,MAAnB,EACE,MAAM,IAAI3E,KAAJ,CAAU,sCAAV,CAAN;;AAEF,UAAIoD,QAAQ7D,UAAU8D,WAAlB,IACAD,QAAQ7D,UAAU+D,WADtB,EACmC;AACjC,cAAM,IAAIN,UAAJ,CAAe,gCAAgCI,KAA/C,CAAN;AACD;;AAED,UAAI,CAAEjC,WAAWyB,GAAX,CAAec,QAAf,CAAN,EACE,MAAM,IAAIb,SAAJ,CAAc,uBAAuBa,QAArC,CAAN;;AAEF,UAAI,KAAKxB,MAAL,MAAiBkB,KAAjB,IAA0B,KAAKjB,SAAL,MAAoBuB,QAAlD,EAA4D;AAC1D,aAAKf,KAAL,CAAWpD,UAAUwB,YAArB;AACA7B,eAAO,KAAK4C,OAAL,CAAP,EAAsB,qBAAtB;AACA,aAAKA,OAAL,EAAc6C,MAAd,CAAqBvB,KAArB,EAA4BM,QAA5B;AACA;AACA,YAAI,CAAC,KAAK3B,SAAL,CAAL,EAAsB;AACpB,eAAKG,MAAL,IAAekB,KAAf;AACA,eAAKjB,SAAL,IAAkBuB,QAAlB;AACD;AACF;AACF;;;4BAEQ;AACPxE,aAAO,KAAK4C,OAAL,CAAP,EAAsB,qBAAtB;AACA,aAAO,KAAKA,OAAL,EAAc8C,KAAd,EAAP;AACD;;;0BAEMC,I,EAAM;AACX,UAAIA,SAASC,SAAb,EACED,OAAOtF,UAAUyB,YAAjB;;AAEF,UAAI,KAAK+D,KAAT,EACE;;AAEF,UAAMC,YAAY,KAAKpD,UAAL,CAAlB;AACA,WAAKA,UAAL,IAAmBiD,IAAnB;AACA,WAAKI,KAAL,CAAW7F,OAAO8F,KAAP,CAAa,CAAb,CAAX;AACA,WAAKtD,UAAL,IAAmBoD,SAAnB;AACD;;;wBAEIG,K,EAAOC,Q,EAAUC,E,EAAI;AACxB,UAAIF,KAAJ,EACE,KAAKF,KAAL,CAAWE,KAAX,EAAkBC,QAAlB;AACF,WAAKzC,KAAL,CAAW,KAAKd,YAAL,CAAX;AACA,WAAKO,MAAL,IAAe,IAAf;AACA,6GAAiB,IAAjB,EAAuB,IAAvB,EAA6BiD,EAA7B;AACD;;;0BAMMF,K,EAAOC,Q,EAAUC,E,EAAI;AAC1B;AACA;AACA,UAAI,OAAOD,QAAP,KAAoB,UAAxB,EACEC,KAAKD,QAAL,EAAeA,WAAW,MAA1B;;AAEF,UAAI,OAAOD,KAAP,KAAiB,QAArB,EACEA,QAAQ,IAAI/F,MAAJ,CAAW+F,KAAX,EAAkBC,QAAlB,CAAR;;AAEF,UAAIE,gBAAgBH,SAASA,MAAMI,MAAnC;AACA,UAAIC,iBAAiB,KAAK7D,UAAL,IAAmB,KAAKM,OAAL,CAAxC;AACA,UAAIwD,QAAQ,CAAZ,CAX0B,CAWZ;AACd,UAAMT,YAAY,KAAKpD,UAAL,CAAlB;AACA,UAAI8D,cAAc,IAAlB;;AAEAxG,aAAO,KAAK4C,OAAL,CAAP,EAAsB,qBAAtB;AACA,SAAG;AACD,YAAI6D,MAAM,KAAK7D,OAAL,EAAc8D,SAAd,CACRZ,SADQ,EAERG,KAFQ,EAED;AACPM,aAHQ,EAGD;AACPH,qBAJQ,EAIO;AACf,aAAKtD,OAAL,CALQ,EAKO;AACf,aAAKC,OAAL,CANQ,EAMO;AACfuD,sBAPQ,CAOO;AAPP,SAAV;;AAUA,YAAI,KAAKzD,SAAL,CAAJ,EACE;;AAEF;AACA;AACA,YAAI8D,eAAeF,MAAMA,IAAI,CAAJ,CAAN,GAAe,KAAKtD,WAAL,EAAkB,CAAlB,CAAlC;AACA;AACA,YAAIyD,gBAAgBH,MAAMA,IAAI,CAAJ,CAAN,GAAe,KAAKtD,WAAL,EAAkB,CAAlB,CAAnC;;AAEA,YAAM0D,OAAOP,iBAAiBM,aAA9B;AACA5G,eAAO6G,QAAQ,CAAf,EAAkB,yBAAlB;;AAEA,YAAIA,OAAO,CAAX,EAAc;AACZ,cAAMC,MAAM,KAAKhE,OAAL,EAAciE,KAAd,CACV,KAAKhE,OAAL,CADU,EACK,KAAKA,OAAL,IAAgB8D,IADrB,CAAZ;;AAIA,eAAK9D,OAAL,KAAiB8D,IAAjB;AACA;AACAL,wBAAc,kGAAYM,GAAZ,KAAoBN,WAAlC;AACD;;AAED;AACA,YAAII,kBAAkB,CAAlB,IAAuB,KAAK7D,OAAL,KAAiB,KAAKN,UAAL,CAA5C,EAA8D;AAC5D6D,2BAAiB,KAAK7D,UAAL,CAAjB;AACA,eAAKM,OAAL,IAAgB,CAAhB;AACA,eAAKD,OAAL,IAAgB5C,OAAOqF,WAAP,CAAmB,KAAK9C,UAAL,CAAnB,CAAhB;AACD;;AAED,YAAImE,kBAAkB,CAAtB,EAAyB;AACvB;AACA;AACA;AACA;AACAL,mBAAUH,gBAAgBO,YAA1B;AACAP,0BAAgBO,YAAhB;AACA;AACD;AACD;AACD,OAlDD,QAkDS,CAAC,KAAK9D,SAAL,CAlDV;;AAoDA,UAAIsD,EAAJ,EACEA;AACF,aAAOK,WAAP;AACD;;;wBA3EY;AACX,aAAO,KAAKtD,MAAL,CAAP;AACD;;;;EAvKgB3C,Q;;AAmPnB;;;IACMyG,O;;;AACJ,mBAAa3D,IAAb,EAAmB;AAAA;;AAAA,6GACXA,IADW,EACLhD,UAAU4G,OADL;AAElB;;;EAHmB7D,I;;IAMhB8D,O;;;AACJ,mBAAa7D,IAAb,EAAmB;AAAA;;AAAA,6GACXA,IADW,EACLhD,UAAU8G,OADL;AAElB;;;EAHmB/D,I;;AAMtB;;;IACMgE,I;;;AACJ,gBAAa/D,IAAb,EAAmB;AAAA;;AAAA,uGACXA,IADW,EACLhD,UAAUgH,IADL;AAElB;;;EAHgBjE,I;;IAMbkE,M;;;AACJ,kBAAajE,IAAb,EAAmB;AAAA;;AAAA,2GACXA,IADW,EACLhD,UAAUkH,MADL;AAElB;;;EAHkBnE,I;;AAMrB;;;IACMoE,U;;;AACJ,sBAAanE,IAAb,EAAmB;AAAA;;AAAA,mHACXA,IADW,EACLhD,UAAUoH,UADL;AAElB;;;EAHsBrE,I;;IAMnBsE,U;;;AACJ,sBAAarE,IAAb,EAAmB;AAAA;;AAAA,mHACXA,IADW,EACLhD,UAAUsH,UADL;AAElB;;;EAHsBvE,I;;AAMzB;;;IACMwE,K;;;AACJ,iBAAavE,IAAb,EAAmB;AAAA;;AAAA,yGACXA,IADW,EACLhD,UAAUwH,KADL;AAElB;;;EAHiBzE,I;;AAMpB9C,QAAQ0G,OAAR,GAAkBA,OAAlB;AACA1G,QAAQ4G,OAAR,GAAkBA,OAAlB;AACA5G,QAAQ8G,IAAR,GAAeA,IAAf;AACA9G,QAAQgH,MAAR,GAAiBA,MAAjB;AACAhH,QAAQkH,UAAR,GAAqBA,UAArB;AACAlH,QAAQoH,UAAR,GAAqBA,UAArB;AACApH,QAAQsH,KAAR,GAAgBA,KAAhB","file":"index.js","sourcesContent":["'use strict'\n\nconst assert = require('assert')\nconst Buffer = require('buffer').Buffer\nconst binding = process.binding('zlib')\n\nconst constants = exports.constants = require('./constants.js')\nconst MiniPass = require('minipass')\n\nclass ZlibError extends Error {\n  constructor (msg, errno) {\n    super('zlib: ' + msg)\n    this.errno = errno\n    this.code = codes.get(errno)\n  }\n\n  get name () {\n    return 'ZlibError'\n  }\n}\n\n// translation table for return codes.\nconst codes = new Map([\n  [constants.Z_OK, 'Z_OK'],\n  [constants.Z_STREAM_END, 'Z_STREAM_END'],\n  [constants.Z_NEED_DICT, 'Z_NEED_DICT'],\n  [constants.Z_ERRNO, 'Z_ERRNO'],\n  [constants.Z_STREAM_ERROR, 'Z_STREAM_ERROR'],\n  [constants.Z_DATA_ERROR, 'Z_DATA_ERROR'],\n  [constants.Z_MEM_ERROR, 'Z_MEM_ERROR'],\n  [constants.Z_BUF_ERROR, 'Z_BUF_ERROR'],\n  [constants.Z_VERSION_ERROR, 'Z_VERSION_ERROR']\n])\n\nconst validFlushFlags = new Set([\n  constants.Z_NO_FLUSH,\n  constants.Z_PARTIAL_FLUSH,\n  constants.Z_SYNC_FLUSH,\n  constants.Z_FULL_FLUSH,\n  constants.Z_FINISH,\n  constants.Z_BLOCK\n])\n\nconst strategies = new Set([\n  constants.Z_FILTERED,\n  constants.Z_HUFFMAN_ONLY,\n  constants.Z_RLE,\n  constants.Z_FIXED,\n  constants.Z_DEFAULT_STRATEGY\n])\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _opts = Symbol('opts')\nconst _chunkSize = Symbol('chunkSize')\nconst _flushFlag = Symbol('flushFlag')\nconst _finishFlush = Symbol('finishFlush')\nconst _handle = Symbol('handle')\nconst _hadError = Symbol('hadError')\nconst _buffer = Symbol('buffer')\nconst _offset = Symbol('offset')\nconst _level = Symbol('level')\nconst _strategy = Symbol('strategy')\nconst _ended = Symbol('ended')\nconst _writeState = Symbol('writeState')\n\nclass Zlib extends MiniPass {\n  constructor (opts, mode) {\n    super(opts)\n    this[_ended] = false\n    this[_opts] = opts = opts || {}\n    this[_chunkSize] = opts.chunkSize || constants.Z_DEFAULT_CHUNK\n    if (opts.flush && !validFlushFlags.has(opts.flush)) {\n      throw new TypeError('Invalid flush flag: ' + opts.flush)\n    }\n    if (opts.finishFlush && !validFlushFlags.has(opts.finishFlush)) {\n      throw new TypeError('Invalid flush flag: ' + opts.finishFlush)\n    }\n\n    this[_flushFlag] = opts.flush || constants.Z_NO_FLUSH\n    this[_finishFlush] = typeof opts.finishFlush !== 'undefined' ?\n      opts.finishFlush : constants.Z_FINISH\n\n    if (opts.chunkSize) {\n      if (opts.chunkSize < constants.Z_MIN_CHUNK) {\n        throw new RangeError('Invalid chunk size: ' + opts.chunkSize)\n      }\n    }\n\n    if (opts.windowBits) {\n      if (opts.windowBits < constants.Z_MIN_WINDOWBITS ||\n          opts.windowBits > constants.Z_MAX_WINDOWBITS) {\n        throw new RangeError('Invalid windowBits: ' + opts.windowBits)\n      }\n    }\n\n    if (opts.level) {\n      if (opts.level < constants.Z_MIN_LEVEL ||\n          opts.level > constants.Z_MAX_LEVEL) {\n        throw new RangeError('Invalid compression level: ' + opts.level)\n      }\n    }\n\n    if (opts.memLevel) {\n      if (opts.memLevel < constants.Z_MIN_MEMLEVEL ||\n          opts.memLevel > constants.Z_MAX_MEMLEVEL) {\n        throw new RangeError('Invalid memLevel: ' + opts.memLevel)\n      }\n    }\n\n    if (opts.strategy && !(strategies.has(opts.strategy)))\n      throw new TypeError('Invalid strategy: ' + opts.strategy)\n\n    if (opts.dictionary) {\n      if (!(opts.dictionary instanceof Buffer)) {\n        throw new TypeError('Invalid dictionary: it should be a Buffer instance')\n      }\n    }\n\n    this[_handle] = new binding.Zlib(mode)\n\n    this[_hadError] = false\n    this[_handle].onerror = (message, errno) => {\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      this.close()\n      this[_hadError] = true\n\n      const error = new ZlibError(message, errno)\n      this.emit('error', error)\n    }\n\n    const level = typeof opts.level === 'number' ? opts.level\n                : constants.Z_DEFAULT_COMPRESSION\n\n    var strategy = typeof opts.strategy === 'number' ? opts.strategy\n                 : constants.Z_DEFAULT_STRATEGY\n\n    this[_writeState] = new Uint32Array(2);\n    const window = opts.windowBits || constants.Z_DEFAULT_WINDOWBITS\n    const memLevel = opts.memLevel || constants.Z_DEFAULT_MEMLEVEL\n\n    // API changed in node v9\n    /* istanbul ignore next */\n    if (/^v[0-8]\\./.test(process.version)) {\n      this[_handle].init(window,\n                         level,\n                         memLevel,\n                         strategy,\n                         opts.dictionary)\n    } else {\n      this[_handle].init(window,\n                         level,\n                         memLevel,\n                         strategy,\n                         this[_writeState],\n                         () => {},\n                         opts.dictionary)\n    }\n\n    this[_buffer] = Buffer.allocUnsafe(this[_chunkSize])\n    this[_offset] = 0\n    this[_level] = level\n    this[_strategy] = strategy\n\n    this.once('end', this.close)\n  }\n\n  close () {\n    if (this[_handle]) {\n      this[_handle].close()\n      this[_handle] = null\n      this.emit('close')\n    }\n  }\n\n  params (level, strategy) {\n    if (!this[_handle])\n      throw new Error('cannot switch params when binding is closed')\n\n    // no way to test this without also not supporting params at all\n    /* istanbul ignore if */\n    if (!this[_handle].params)\n      throw new Error('not supported in this implementation')\n\n    if (level < constants.Z_MIN_LEVEL ||\n        level > constants.Z_MAX_LEVEL) {\n      throw new RangeError('Invalid compression level: ' + level)\n    }\n\n    if (!(strategies.has(strategy)))\n      throw new TypeError('Invalid strategy: ' + strategy)\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH)\n      assert(this[_handle], 'zlib binding closed')\n      this[_handle].params(level, strategy)\n      /* istanbul ignore else */\n      if (!this[_hadError]) {\n        this[_level] = level\n        this[_strategy] = strategy\n      }\n    }\n  }\n\n  reset () {\n    assert(this[_handle], 'zlib binding closed')\n    return this[_handle].reset()\n  }\n\n  flush (kind) {\n    if (kind === undefined)\n      kind = constants.Z_FULL_FLUSH\n\n    if (this.ended)\n      return\n\n    const flushFlag = this[_flushFlag]\n    this[_flushFlag] = kind\n    this.write(Buffer.alloc(0))\n    this[_flushFlag] = flushFlag\n  }\n\n  end (chunk, encoding, cb) {\n    if (chunk)\n      this.write(chunk, encoding)\n    this.flush(this[_finishFlush])\n    this[_ended] = true\n    return super.end(null, null, cb)\n  }\n\n  get ended () {\n    return this[_ended]\n  }\n\n  write (chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (typeof chunk === 'string')\n      chunk = new Buffer(chunk, encoding)\n\n    let availInBefore = chunk && chunk.length\n    let availOutBefore = this[_chunkSize] - this[_offset]\n    let inOff = 0 // the offset of the input buffer\n    const flushFlag = this[_flushFlag]\n    let writeReturn = true\n\n    assert(this[_handle], 'zlib binding closed')\n    do {\n      let res = this[_handle].writeSync(\n        flushFlag,\n        chunk, // in\n        inOff, // in_off\n        availInBefore, // in_len\n        this[_buffer], // out\n        this[_offset], //out_off\n        availOutBefore // out_len\n      )\n\n      if (this[_hadError])\n        break\n\n      // API changed in v9\n      /* istanbul ignore next */\n      let availInAfter = res ? res[0] : this[_writeState][1]\n      /* istanbul ignore next */\n      let availOutAfter = res ? res[1] : this[_writeState][0]\n\n      const have = availOutBefore - availOutAfter\n      assert(have >= 0, 'have should not go down')\n\n      if (have > 0) {\n        const out = this[_buffer].slice(\n          this[_offset], this[_offset] + have\n        )\n\n        this[_offset] += have\n        // serve some output to the consumer.\n        writeReturn = super.write(out) && writeReturn\n      }\n\n      // exhausted the output buffer, or used all the input create a new one.\n      if (availOutAfter === 0 || this[_offset] >= this[_chunkSize]) {\n        availOutBefore = this[_chunkSize]\n        this[_offset] = 0\n        this[_buffer] = Buffer.allocUnsafe(this[_chunkSize])\n      }\n\n      if (availOutAfter === 0) {\n        // Not actually done.  Need to reprocess.\n        // Also, update the availInBefore to the availInAfter value,\n        // so that if we have to hit it a third (fourth, etc.) time,\n        // it'll have the correct byte counts.\n        inOff += (availInBefore - availInAfter)\n        availInBefore = availInAfter\n        continue\n      }\n      break\n    } while (!this[_hadError])\n\n    if (cb)\n      cb()\n    return writeReturn\n  }\n}\n\n// minimal 2-byte header\nclass Deflate extends Zlib {\n  constructor (opts) {\n    super(opts, constants.DEFLATE)\n  }\n}\n\nclass Inflate extends Zlib {\n  constructor (opts) {\n    super(opts, constants.INFLATE)\n  }\n}\n\n// gzip - bigger header, same deflate compression\nclass Gzip extends Zlib {\n  constructor (opts) {\n    super(opts, constants.GZIP)\n  }\n}\n\nclass Gunzip extends Zlib {\n  constructor (opts) {\n    super(opts, constants.GUNZIP)\n  }\n}\n\n// raw - no header\nclass DeflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, constants.DEFLATERAW)\n  }\n}\n\nclass InflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, constants.INFLATERAW)\n  }\n}\n\n// auto-detect header.\nclass Unzip extends Zlib {\n  constructor (opts) {\n    super(opts, constants.UNZIP)\n  }\n}\n\nexports.Deflate = Deflate\nexports.Inflate = Inflate\nexports.Gzip = Gzip\nexports.Gunzip = Gunzip\nexports.DeflateRaw = DeflateRaw\nexports.InflateRaw = InflateRaw\nexports.Unzip = Unzip\n"]}