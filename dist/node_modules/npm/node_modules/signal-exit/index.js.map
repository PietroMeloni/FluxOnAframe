{"version":3,"sources":["../../../../../node_modules/npm/node_modules/signal-exit/index.js"],"names":["assert","require","signals","EE","EventEmitter","emitter","process","__signal_exit_emitter__","count","emitted","infinite","setMaxListeners","Infinity","module","exports","cb","opts","equal","loaded","load","ev","alwaysLast","remove","removeListener","listeners","length","unload","on","forEach","sig","sigListeners","er","emit","originalProcessEmit","reallyExit","originalProcessReallyExit","event","code","signal","listener","kill","pid","filter","processEmit","processReallyExit","exitCode","call","arg","undefined","ret","apply","arguments"],"mappings":"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","file":"index.js","sourcesContent":["// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\nvar assert = require('assert')\nvar signals = require('./signals.js')\n\nvar EE = require('events')\n/* istanbul ignore if */\nif (typeof EE !== 'function') {\n  EE = EE.EventEmitter\n}\n\nvar emitter\nif (process.__signal_exit_emitter__) {\n  emitter = process.__signal_exit_emitter__\n} else {\n  emitter = process.__signal_exit_emitter__ = new EE()\n  emitter.count = 0\n  emitter.emitted = {}\n}\n\n// Because this emitter is a global, we have to check to see if a\n// previous version of this library failed to enable infinite listeners.\n// I know what you're about to say.  But literally everything about\n// signal-exit is a compromise with evil.  Get used to it.\nif (!emitter.infinite) {\n  emitter.setMaxListeners(Infinity)\n  emitter.infinite = true\n}\n\nmodule.exports = function (cb, opts) {\n  assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')\n\n  if (loaded === false) {\n    load()\n  }\n\n  var ev = 'exit'\n  if (opts && opts.alwaysLast) {\n    ev = 'afterexit'\n  }\n\n  var remove = function () {\n    emitter.removeListener(ev, cb)\n    if (emitter.listeners('exit').length === 0 &&\n        emitter.listeners('afterexit').length === 0) {\n      unload()\n    }\n  }\n  emitter.on(ev, cb)\n\n  return remove\n}\n\nmodule.exports.unload = unload\nfunction unload () {\n  if (!loaded) {\n    return\n  }\n  loaded = false\n\n  signals.forEach(function (sig) {\n    try {\n      process.removeListener(sig, sigListeners[sig])\n    } catch (er) {}\n  })\n  process.emit = originalProcessEmit\n  process.reallyExit = originalProcessReallyExit\n  emitter.count -= 1\n}\n\nfunction emit (event, code, signal) {\n  if (emitter.emitted[event]) {\n    return\n  }\n  emitter.emitted[event] = true\n  emitter.emit(event, code, signal)\n}\n\n// { <signal>: <listener fn>, ... }\nvar sigListeners = {}\nsignals.forEach(function (sig) {\n  sigListeners[sig] = function listener () {\n    // If there are no other listeners, an exit is coming!\n    // Simplest way: remove us and then re-send the signal.\n    // We know that this will kill the process, so we can\n    // safely emit now.\n    var listeners = process.listeners(sig)\n    if (listeners.length === emitter.count) {\n      unload()\n      emit('exit', null, sig)\n      /* istanbul ignore next */\n      emit('afterexit', null, sig)\n      /* istanbul ignore next */\n      process.kill(process.pid, sig)\n    }\n  }\n})\n\nmodule.exports.signals = function () {\n  return signals\n}\n\nmodule.exports.load = load\n\nvar loaded = false\n\nfunction load () {\n  if (loaded) {\n    return\n  }\n  loaded = true\n\n  // This is the number of onSignalExit's that are in play.\n  // It's important so that we can count the correct number of\n  // listeners on signals, and don't wait for the other one to\n  // handle it instead of us.\n  emitter.count += 1\n\n  signals = signals.filter(function (sig) {\n    try {\n      process.on(sig, sigListeners[sig])\n      return true\n    } catch (er) {\n      return false\n    }\n  })\n\n  process.emit = processEmit\n  process.reallyExit = processReallyExit\n}\n\nvar originalProcessReallyExit = process.reallyExit\nfunction processReallyExit (code) {\n  process.exitCode = code || 0\n  emit('exit', process.exitCode, null)\n  /* istanbul ignore next */\n  emit('afterexit', process.exitCode, null)\n  /* istanbul ignore next */\n  originalProcessReallyExit.call(process, process.exitCode)\n}\n\nvar originalProcessEmit = process.emit\nfunction processEmit (ev, arg) {\n  if (ev === 'exit') {\n    if (arg !== undefined) {\n      process.exitCode = arg\n    }\n    var ret = originalProcessEmit.apply(this, arguments)\n    emit('exit', process.exitCode, null)\n    /* istanbul ignore next */\n    emit('afterexit', process.exitCode, null)\n    return ret\n  } else {\n    return originalProcessEmit.apply(this, arguments)\n  }\n}\n"]}