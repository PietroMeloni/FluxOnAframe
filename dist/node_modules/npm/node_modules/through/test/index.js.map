{"version":3,"sources":["../../../../../../node_modules/npm/node_modules/through/test/index.js"],"names":["test","require","spec","through","write","array","stream","slice","next","length","shift","once","end","read","callback","actual","on","data","push","err","assert","l","expected","Math","random","t","s","pausable","ifError","deepEqual","validate","emit","map","pause","process","nextTick","resume","count","undefined","equal"],"mappings":"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","file":"index.js","sourcesContent":["\nvar test = require('tape')\nvar spec = require('stream-spec')\nvar through = require('../')\n\n/*\n  I'm using these two functions, and not streams and pipe\n  so there is less to break. if this test fails it must be\n  the implementation of _through_\n*/\n\nfunction write(array, stream) {\n  array = array.slice()\n  function next() {\n    while(array.length)\n      if(stream.write(array.shift()) === false)\n        return stream.once('drain', next)\n    \n    stream.end()\n  }\n\n  next()\n}\n\nfunction read(stream, callback) {\n  var actual = []\n  stream.on('data', function (data) {\n    actual.push(data)\n  })\n  stream.once('end', function () {\n    callback(null, actual)\n  })\n  stream.once('error', function (err) {\n    callback(err)\n  })\n}\n\ntest('simple defaults', function(assert) {\n\n  var l = 1000\n    , expected = []\n\n  while(l--) expected.push(l * Math.random())\n\n  var t = through()\n  var s = spec(t).through().pausable()\n\n  read(t, function (err, actual) {\n    assert.ifError(err)\n    assert.deepEqual(actual, expected)\n    assert.end()\n  })\n\n  t.on('close', s.validate)\n\n  write(expected, t)\n});\n\ntest('simple functions', function(assert) {\n\n  var l = 1000\n    , expected = [] \n\n  while(l--) expected.push(l * Math.random())\n\n  var t = through(function (data) {\n      this.emit('data', data*2)\n    }) \n  var s = spec(t).through().pausable()\n      \n\n  read(t, function (err, actual) {\n    assert.ifError(err)\n    assert.deepEqual(actual, expected.map(function (data) {\n      return data*2\n    }))\n    assert.end()\n  })\n\n  t.on('close', s.validate)\n\n  write(expected, t)\n})\n\ntest('pauses', function(assert) {\n\n  var l = 1000\n    , expected = [] \n\n  while(l--) expected.push(l) //Math.random())\n\n  var t = through()    \n \n  var s = spec(t)\n      .through()\n      .pausable()\n\n  t.on('data', function () {\n    if(Math.random() > 0.1) return\n    t.pause()\n    process.nextTick(function () {\n      t.resume()\n    })\n  })\n\n  read(t, function (err, actual) {\n    assert.ifError(err)\n    assert.deepEqual(actual, expected)\n  })\n\n  t.on('close', function () {\n    s.validate()\n    assert.end()\n  })\n\n  write(expected, t)\n})\n\ntest('does not soft-end on `undefined`', function(assert) {\n  var stream = through()\n    , count = 0\n\n  stream.on('data', function (data) {\n    count++\n  })\n\n  stream.write(undefined)\n  stream.write(undefined)\n\n  assert.equal(count, 2)\n\n  assert.end()\n})\n"]}