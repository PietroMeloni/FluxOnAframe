{"version":3,"sources":["../../../../../node_modules/npm/node_modules/dot-prop/index.js"],"names":["isObj","require","getPathSegments","path","pathArr","split","parts","i","length","p","undefined","slice","push","module","exports","get","obj","value","Object","prototype","propertyIsEnumerable","call","set","root","delete","has"],"mappings":"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","file":"index.js","sourcesContent":["'use strict';\nconst isObj = require('is-obj');\n\nfunction getPathSegments(path) {\n\tconst pathArr = path.split('.');\n\tconst parts = [];\n\n\tfor (let i = 0; i < pathArr.length; i++) {\n\t\tlet p = pathArr[i];\n\n\t\twhile (p[p.length - 1] === '\\\\' && pathArr[i + 1] !== undefined) {\n\t\t\tp = p.slice(0, -1) + '.';\n\t\t\tp += pathArr[++i];\n\t\t}\n\n\t\tparts.push(p);\n\t}\n\n\treturn parts;\n}\n\nmodule.exports = {\n\tget(obj, path, value) {\n\t\tif (!isObj(obj) || typeof path !== 'string') {\n\t\t\treturn value === undefined ? obj : value;\n\t\t}\n\n\t\tconst pathArr = getPathSegments(path);\n\n\t\tfor (let i = 0; i < pathArr.length; i++) {\n\t\t\tif (!Object.prototype.propertyIsEnumerable.call(obj, pathArr[i])) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tobj = obj[pathArr[i]];\n\n\t\t\tif (obj === undefined || obj === null) {\n\t\t\t\t// `obj` is either `undefined` or `null` so we want to stop the loop, and\n\t\t\t\t// if this is not the last bit of the path, and\n\t\t\t\t// if it did't return `undefined`\n\t\t\t\t// it would return `null` if `obj` is `null`\n\t\t\t\t// but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n\t\t\t\tif (i !== pathArr.length - 1) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\tset(obj, path, value) {\n\t\tif (!isObj(obj) || typeof path !== 'string') {\n\t\t\treturn obj;\n\t\t}\n\n\t\tconst root = obj;\n\t\tconst pathArr = getPathSegments(path);\n\n\t\tfor (let i = 0; i < pathArr.length; i++) {\n\t\t\tconst p = pathArr[i];\n\n\t\t\tif (!isObj(obj[p])) {\n\t\t\t\tobj[p] = {};\n\t\t\t}\n\n\t\t\tif (i === pathArr.length - 1) {\n\t\t\t\tobj[p] = value;\n\t\t\t}\n\n\t\t\tobj = obj[p];\n\t\t}\n\n\t\treturn root;\n\t},\n\n\tdelete(obj, path) {\n\t\tif (!isObj(obj) || typeof path !== 'string') {\n\t\t\treturn;\n\t\t}\n\n\t\tconst pathArr = getPathSegments(path);\n\n\t\tfor (let i = 0; i < pathArr.length; i++) {\n\t\t\tconst p = pathArr[i];\n\n\t\t\tif (i === pathArr.length - 1) {\n\t\t\t\tdelete obj[p];\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tobj = obj[p];\n\n\t\t\tif (!isObj(obj)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t},\n\n\thas(obj, path) {\n\t\tif (!isObj(obj) || typeof path !== 'string') {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst pathArr = getPathSegments(path);\n\n\t\tfor (let i = 0; i < pathArr.length; i++) {\n\t\t\tif (isObj(obj)) {\n\t\t\t\tif (!(pathArr[i] in obj)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tobj = obj[pathArr[i]];\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n};\n"]}